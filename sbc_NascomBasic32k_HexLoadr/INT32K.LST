0001   0000             ;==============================================================================
0002   0000             ; Contents of parts of this file are copyright Grant Searle
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; http://searle.hostei.com/grant/index.html
0008   0000             ;
0009   0000             ; eMail: home.micros01@btinternet.com
0010   0000             ;
0011   0000             ; If the above don't work, please perform an Internet search to see if I have
0012   0000             ; updated the web page hosting service.
0013   0000             ;
0014   0000             ;==============================================================================
0015   0000             ;
0016   0000             ; ACIA 6850 interrupt driven serial I/O to run modified NASCOM Basic 4.7.
0017   0000             ; Full input and output buffering with incoming data hardware handshaking.
0018   0000             ; Handshake shows full before the buffer is totally filled to
0019   0000             ; allow run-on from the sender. Transmit and receive are interrupt driven.
0020   0000             ;
0021   0000             ; https://github.com/feilipu/
0022   0000             ; https://feilipu.me/
0023   0000             ;
0024   0000             ;==============================================================================
0025   0000             ;
0026   0000             ; HexLoadr option by @feilipu,
0027   0000             ; derived from the work of @fbergama and @foxweb at RC2014
0028   0000             ; https://github.com/RC2014Z80
0029   0000             ;
0030   0000             
0031   0000             ;==============================================================================
0032   0000             ;
0033   0000             ; INCLUDES SECTION
0034   0000             ;
0035   0000             
0036   0000             #include    "d:/rc2014.h"
0001+  0000             ;==============================================================================
0002+  0000             ; Contents of this file are copyright Phillip Stevens
0003+  0000             ;
0004+  0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005+  0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006+  0000             ;
0007+  0000             ; https://github.com/feilipu/
0008+  0000             ;
0009+  0000             ; https://feilipu.me/
0010+  0000             ;
0011+  0000             ;==================================================================================
0012+  0000             ;
0013+  0000             ; ACIA 68B50 interrupt driven serial I/O to run modified NASCOM Basic 4.7.
0014+  0000             ; Full input and output buffering with incoming data hardware handshaking.
0015+  0000             ; Handshake shows full before the buffer is totally filled to
0016+  0000             ; allow run-on from the sender. Transmit and receive are interrupt driven.
0017+  0000             ;
0018+  0000             ; https://github.com/feilipu/
0019+  0000             ; https://feilipu.me/
0020+  0000             ;
0021+  0000             ;==================================================================================
0022+  0000             ;
0023+  0000             ; HexLoadr option by @feilipu,
0024+  0000             ; derived from the work of @fbergama and @foxweb at RC2014
0025+  0000             ; https://github.com/RC2014Z80
0026+  0000             ;
0027+  0000             
0028+  0000             ;==============================================================================
0029+  0000             ;
0030+  0000             ; Some definitions used with the RC2014 on-board peripherals:
0031+  0000             ;
0032+  0000             
0033+  0000             ; ACIA 68B50 Register Mnemonics
0034+  0000             
0035+  0000             SER_CTRL_ADDR   .EQU   $80    ; Address of Control Register (write only)
0036+  0000             SER_STATUS_ADDR .EQU   $80    ; Address of Status Register (read only)
0037+  0000             SER_DATA_ADDR   .EQU   $81    ; Address of Data Register
0038+  0000             
0039+  0000             SER_CLK_DIV_01  .EQU   $00    ; Divide the Clock by 1
0040+  0000             SER_CLK_DIV_16  .EQU   $01    ; Divide the Clock by 16
0041+  0000             SER_CLK_DIV_64  .EQU   $02    ; Divide the Clock by 64 (default value)
0042+  0000             SER_RESET       .EQU   $03    ; Master Reset (issue before any other Control word)
0043+  0000             
0044+  0000             SER_7E2         .EQU   $00    ; 7 Bits Even Parity 2 Stop Bits
0045+  0000             SER_7O2         .EQU   $04    ; 7 Bits  Odd Parity 2 Stop Bits
0046+  0000             SER_7E1         .EQU   $08    ; 7 Bits Even Parity 1 Stop Bit
0047+  0000             SER_7O1         .EQU   $0C    ; 7 Bits  Odd Parity 1 Stop Bit
0048+  0000             SER_8N2         .EQU   $10    ; 8 Bits   No Parity 2 Stop Bits
0049+  0000             SER_8N1         .EQU   $14    ; 8 Bits   No Parity 1 Stop Bit
0050+  0000             SER_8E1         .EQU   $18    ; 8 Bits Even Parity 1 Stop Bit
0051+  0000             SER_8O1         .EQU   $1C    ; 8 Bits  Odd Parity 1 Stop Bit
0052+  0000             
0053+  0000             SER_TDI_RTS0    .EQU   $00    ; _RTS low,  Transmitting Interrupt Disabled
0054+  0000             SER_TEI_RTS0    .EQU   $20    ; _RTS low,  Transmitting Interrupt Enabled
0055+  0000             SER_TDI_RTS1    .EQU   $40    ; _RTS high, Transmitting Interrupt Disabled
0056+  0000             SER_TDI_BRK     .EQU   $60    ; _RTS low,  Transmitting Interrupt Disabled, BRK on Tx
0057+  0000             
0058+  0000             SER_TEI_MASK    .EQU   $60    ; Mask for the Tx Interrupt & RTS bits   
0059+  0000             
0060+  0000             SER_REI         .EQU   $80    ; Receive Interrupt Enabled
0061+  0000             
0062+  0000             SER_RDRF        .EQU   $01    ; Receive Data Register Full
0063+  0000             SER_TDRE        .EQU   $02    ; Transmit Data Register Empty
0064+  0000             SER_DCD         .EQU   $04    ; Data Carrier Detect
0065+  0000             SER_CTS         .EQU   $08    ; Clear To Send
0066+  0000             SER_FE          .EQU   $10    ; Framing Error (Received Byte)
0067+  0000             SER_OVRN        .EQU   $20    ; Overrun (Received Byte
0068+  0000             SER_PE          .EQU   $40    ; Parity Error (Received Byte)
0069+  0000             SER_IRQ         .EQU   $80    ; IRQ (Either Transmitted or Received Byte)
0070+  0000             
0071+  0000             ; General TTY
0072+  0000             
0073+  0000             CTRLC           .EQU    03H     ; Control "C"
0074+  0000             CTRLG           .EQU    07H     ; Control "G"
0075+  0000             BKSP            .EQU    08H     ; Back space
0076+  0000             LF              .EQU    0AH     ; Line feed
0077+  0000             CS              .EQU    0CH     ; Clear screen
0078+  0000             CR              .EQU    0DH     ; Carriage return
0079+  0000             CTRLO           .EQU    0FH     ; Control "O"
0080+  0000             CTRLQ	        .EQU	11H     ; Control "Q"
0081+  0000             CTRLR           .EQU    12H     ; Control "R"
0082+  0000             CTRLS           .EQU    13H     ; Control "S"
0083+  0000             CTRLU           .EQU    15H     ; Control "U"
0084+  0000             ESC             .EQU    1BH     ; Escape
0085+  0000             DEL             .EQU    7FH     ; Delete
0086+  0000             
0087+  0000             ;==============================================================================
0088+  0000             ;
0089+  0000             ; DEFINES SECTION
0090+  0000             ;
0091+  0000             
0092+  0000             
0093+  0000             ROMSTART        .EQU    $0000   ; Bottom of ROM
0094+  0000             ROMSTOP         .EQU    $1FFF   ; Top of ROM
0095+  0000             
0096+  0000             RAM_START       .EQU    $8000   ; Bottom of RAM
0097+  0000             RAMSTOP         .EQU    $FFFF   ; Top of RAM
0098+  0000             
0099+  0000             SER_RX_BUFSIZE  .EQU    $FF  ; FIXED Rx buffer size, 256 Bytes, no range checking
0100+  0000             SER_RX_FULLSIZE .EQU    SER_RX_BUFSIZE - $08
0101+  0000                                           ; Fullness of the Rx Buffer, when not_RTS is signalled
0102+  0000             SER_RX_EMPTYSIZE .EQU   $08  ; Fullness of the Rx Buffer, when RTS is signalled
0103+  0000             
0104+  0000             SER_TX_BUFSIZE  .EQU    $0F  ; Size of the Tx Buffer, 15 Bytes
0105+  0000             
0106+  0000             ;==============================================================================
0107+  0000             ;
0108+  0000             ; Interrupt vectors (offsets) for Z80 internal interrupts
0109+  0000             ;
0110+  0000             
0111+  0000             Z80_VECTOR_TABLE .EQU   RAM_START   ; RAM vector address for Z80 RST 
0112+  0000                                                 ; <<< SET THIS AS DESIRED >>>
0113+  0000             
0114+  0000             VECTOR_PROTO     .EQU   $0040
0115+  0000             VECTOR_PROTO_SIZE .EQU  $1F
0116+  0000             
0117+  0000             ;   Prototype Vector Defaults to be defined in initialisation code.
0118+  0000             ;   RST_08      .EQU    TX0         TX a character over ASCI0
0119+  0000             ;   RST_10      .EQU    RX0         RX a character over ASCI0, block no bytes available
0120+  0000             ;   RST_18      .EQU    RX0_CHK     Check ASCI0 status, return # bytes available
0121+  0000             ;   RST_20      .EQU    NULL_INT
0122+  0000             ;   RST_28      .EQU    NULL_INT
0123+  0000             ;   RST_30      .EQU    NULL_INT
0124+  0000             ;   INT_00      .EQU    NULL_INT
0125+  0000             ;   INT_NMI     .EQU    NULL_NMI
0126+  0000             
0127+  0000             ;   Z80 RAM VECTOR ADDRESS TABLE
0128+  0000             
0129+  0000             NULL_RET_ADDR   .EQU    VECTOR_PROTO    ; Write the NULL return location when removing an ISR
0130+  0000             NULL_INT_ADDR   .EQU    $0060
0131+  0000             NULL_NMI_ADDR   .EQU    $0062
0132+  0000             
0133+  0000             RST_08_ADDR     .EQU    Z80_VECTOR_TABLE+$02   ; Write your ISR address to this location
0134+  0000             RST_10_ADDR     .EQU    Z80_VECTOR_TABLE+$06
0135+  0000             RST_18_ADDR     .EQU    Z80_VECTOR_TABLE+$0A
0136+  0000             RST_20_ADDR     .EQU    Z80_VECTOR_TABLE+$0E
0137+  0000             RST_28_ADDR     .EQU    Z80_VECTOR_TABLE+$12
0138+  0000             RST_30_ADDR     .EQU    Z80_VECTOR_TABLE+$16
0139+  0000             INT_00_ADDR     .EQU    Z80_VECTOR_TABLE+$1A
0140+  0000             INT_NMI_ADDR    .EQU    Z80_VECTOR_TABLE+$1E
0141+  0000             
0142+  0000             ;==============================================================================
0143+  0000             ;
0144+  0000             ; GLOBAL VARIABLES SECTION
0145+  0000             ;
0146+  0000             
0147+  0000             serRxInPtr      .EQU     Z80_VECTOR_TABLE+VECTOR_PROTO_SIZE+1
0148+  0000             serRxOutPtr     .EQU     serRxInPtr+2
0149+  0000             serTxInPtr      .EQU     serRxOutPtr+2
0150+  0000             serTxOutPtr     .EQU     serTxInPtr+2
0151+  0000             serRxBufUsed    .EQU     serTxOutPtr+2
0152+  0000             serTxBufUsed    .EQU     serRxBufUsed+1
0153+  0000             serControl      .EQU     serTxBufUsed+1
0154+  0000             
0155+  0000             basicStarted    .EQU     serControl+1
0156+  0000             
0157+  0000             serRxBuf        .EQU     RAM_START+$100 ; must start on 0xnn00 for low byte roll-over
0158+  0000             serTxBuf        .EQU     serRxBuf+SER_RX_BUFSIZE+1
0159+  0000             
0160+  0000             ;==============================================================================
0161+  0000             ;
0162+  0000                             .END
0163+  0000             ;
0164+  0000             ;==============================================================================
0165+  0000             
0037   0000             #include    "d:/z80intr.asm"
0001+  0000             ;==============================================================================
0002+  0000             ; Contents of this file are copyright Phillip Stevens
0003+  0000             ;
0004+  0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005+  0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006+  0000             ;
0007+  0000             ; https://github.com/feilipu/
0008+  0000             ;
0009+  0000             ; https://feilipu.me/
0010+  0000             ;
0011+  0000             
0012+  0000             ;==============================================================================
0013+  0000             ;
0014+  0000             ; REQUIRES
0015+  0000             ;
0016+  0000             ; Z80_VECTOR_TABLE  .EQU   RAM vector address for Z80 RST eg.
0017+  0000             ;
0018+  0000             ; Z80_VECTOR_TABLE  .EQU   RAMSTART_CA0    ; RAM vector address for Z80 RST
0019+  0000             ;
0020+  0000             ; #include          "d:/yaz180.h"   ; OR
0021+  0000             ; #include          "d:/rc2014.h"
0022+  0000             
0023+  0000             ;==============================================================================
0024+  0000             ;
0025+  0000             ; Z80 INTERRUPT VECTOR PROTOTYPE TABLE
0026+  0000             ;
0027+  0000             
0028+  0000             ;------------------------------------------------------------------------------
0029+  0000             ; RESET / TRAP
0030+  0000                             .ORG    0000H
0031+  0000 F3                          DI                  ; Disable interrupts
0032+  0001 C3 6D 02                    JP      INIT        ; Initialize Hardware and go
0033+  0004             
0034+  0004             ;------------------------------------------------------------------------------
0035+  0004             ; RST08
0036+  0008                             .ORG    0008H
0037+  0008 C3 01 80                    JP      Z80_VECTOR_TABLE-VECTOR_PROTO+RST_08_LBL
0038+  000B             
0039+  000B             ;------------------------------------------------------------------------------
0040+  000B             ; RST10
0041+  0010                             .ORG    0010H
0042+  0010 C3 05 80                    JP      Z80_VECTOR_TABLE-VECTOR_PROTO+RST_10_LBL
0043+  0013             
0044+  0013             ;------------------------------------------------------------------------------
0045+  0013             ; RST18
0046+  0018                             .ORG    0018H
0047+  0018 C3 09 80                    JP      Z80_VECTOR_TABLE-VECTOR_PROTO+RST_18_LBL
0048+  001B             
0049+  001B             ;------------------------------------------------------------------------------
0050+  001B             ; RST 20
0051+  0020                             .ORG    0020H
0052+  0020 C3 0D 80                    JP      Z80_VECTOR_TABLE-VECTOR_PROTO+RST_20_LBL
0053+  0023             
0054+  0023             ;------------------------------------------------------------------------------
0055+  0023             ; RST 28
0056+  0028                             .ORG    0028H
0057+  0028 C3 11 80                    JP      Z80_VECTOR_TABLE-VECTOR_PROTO+RST_28_LBL
0058+  002B             
0059+  002B             ;------------------------------------------------------------------------------
0060+  002B             ; RST 30
0061+  0030                             .ORG    0030H
0062+  0030 C3 15 80                    JP      Z80_VECTOR_TABLE-VECTOR_PROTO+RST_30_LBL
0063+  0033             
0064+  0033             ;------------------------------------------------------------------------------
0065+  0033             ; RST 38 - INTERRUPT VECTOR INT0 [ with IM 1 ]
0066+  0033             
0067+  0038                             .ORG    0038H
0068+  0038 C3 19 80                    JP      Z80_VECTOR_TABLE-VECTOR_PROTO+INT_00_LBL
0069+  003B             
0070+  003B             ;------------------------------------------------------------------------------
0071+  003B             ; Z80 INTERRUPT VECTOR TABLE PROTOTYPE [ Originating at $40 ]
0072+  003B             
0073+  0040                             .ORG    VECTOR_PROTO
0074+  0040             
0075+  0040             ; WILL BE DUPLICATED DURING INIT TO
0076+  0040             ;
0077+  0040             ;               .ORG    Z80_VECTOR_TABLE
0078+  0040             NULL_RET:
0079+  0040 C9                          RET
0080+  0041             RST_08_LBL:
0081+  0041 C3 91 01                    JP      RST_08
0082+  0044 00                          NOP
0083+  0045             RST_10_LBL:
0084+  0045 C3 67 01                    JP      RST_10
0085+  0048 00                          NOP
0086+  0049             RST_18_LBL:
0087+  0049 C3 D0 01                    JP      RST_18
0088+  004C 00                          NOP
0089+  004D             RST_20_LBL:
0090+  004D C3 40 00                    JP      RST_20
0091+  0050 00                          NOP
0092+  0051             RST_28_LBL:
0093+  0051 C3 40 00                    JP      RST_28
0094+  0054 00                          NOP
0095+  0055             RST_30_LBL:
0096+  0055 C3 40 00                    JP      RST_30
0097+  0058 00                          NOP
0098+  0059             INT_00_LBL:
0099+  0059 C3 00 01                    JP      INT_00
0100+  005C 00                          NOP
0101+  005D             INT_NMI_LBL:
0102+  005D C3 62 00                    JP      INT_NMI
0103+  0060             
0104+  0060             ;------------------------------------------------------------------------------
0105+  0060             ; NULL RETURN INSTRUCTIONS
0106+  0060             
0107+  0060                             .ORG    0060H
0108+  0060             NULL_INT:
0109+  0060 ED 4D                       RETI
0110+  0062             NULL_NMI:
0111+  0062 ED 45                       RETN
0112+  0064             
0113+  0064             ;------------------------------------------------------------------------------
0114+  0064             ; NMI - INTERRUPT VECTOR NMI
0115+  0064             
0116+  0066                             .ORG    0066H
0117+  0066 C3 1D 80                    JP      Z80_VECTOR_TABLE-VECTOR_PROTO+INT_NMI_LBL
0118+  0069             
0119+  0069             ;==============================================================================
0120+  0069             ;
0121+  0069                             .END
0122+  0069             ;
0123+  0069             ;==============================================================================
0124+  0069             
0125+  0069             
0038   0069             
0039   0069             ;==============================================================================
0040   0069             ;
0041   0069             ; DEFINES SECTION
0042   0069             ;
0043   0069             
0044   0069             ; Top of BASIC line input buffer (CURPOS WRKSPC+0ABH)
0045   0069             ; so it is "free ram" when BASIC resets
0046   0069             ; set BASIC Work space WRKSPC $8000, in RAM
0047   0069             
0048   0069             
0049   0069             WRKSPC          .EQU     RAM_START+$0220 ; set BASIC Work space WRKSPC
0050   0069                                                      ; beyond the end of ACIA stuff
0051   0069             
0052   0069             TEMPSTACK       .EQU     WRKSPC+$0AB ; Top of BASIC line input buffer
0053   0069                                                  ; (CURPOS = WRKSPC+0ABH)
0054   0069                                                  ; so it is "free ram" when BASIC resets
0055   0069             
0056   0069             ;==================================================================================
0057   0069             ;
0058   0069             ; CODE SECTION
0059   0069             ;
0060   0069             
0061   0100                     .ORG    0100H
0062   0100             
0063   0100             ;------------------------------------------------------------------------------
0064   0100             serialInt:
0065   0100 F5                  push af
0066   0101 E5                  push hl
0067   0102                                                 ; start doing the Rx stuff
0068   0102             
0069   0102 DB 80               in a, (SER_STATUS_ADDR)     ; get the status of the ACIA
0070   0104 E6 01               and SER_RDRF                ; check whether a byte has been received
0071   0106 28 17               jr z, im1_tx_check          ; if not, go check for bytes to transmit 
0072   0108             
0073   0108 DB 81               in a, (SER_DATA_ADDR)       ; Get the received byte from the ACIA 
0074   010A 6F                  ld l, a                     ; Move Rx byte to l
0075   010B             
0076   010B 3A 28 80            ld a, (serRxBufUsed)        ; Get the number of bytes in the Rx buffer
0077   010E FE FF               cp SER_RX_BUFSIZE           ; check whether there is space in the buffer
0078   0110 30 0D               jr nc, im1_tx_check         ; buffer full, check if we can send something
0079   0112             
0080   0112 7D                  ld a, l                     ; get Rx byte from l
0081   0113 2A 20 80            ld hl, (serRxInPtr)         ; get the pointer to where we poke
0082   0116 77                  ld (hl), a                  ; write the Rx byte to the serRxInPtr address
0083   0117             
0084   0117 2C                  inc l                       ; move the Rx pointer low byte along
0085   0118 22 20 80            ld (serRxInPtr), hl         ; write where the next byte should be poked
0086   011B             
0087   011B 21 28 80            ld hl, serRxBufUsed
0088   011E 34                  inc (hl)                    ; atomically increment Rx buffer count
0089   011F             
0090   011F             
0091   011F             im1_tx_check:                       ; now start doing the Tx stuff
0092   011F             
0093   011F 3A 29 80            ld a, (serTxBufUsed)        ; get the number of bytes in the Tx buffer
0094   0122 B7                  or a                        ; check whether it is zero
0095   0123 28 1E               jr z, im1_tei_clear         ; if the count is zero, then disable the Tx Interrupt
0096   0125             
0097   0125 DB 80               in a, (SER_STATUS_ADDR)     ; get the status of the ACIA
0098   0127 E6 02               and SER_TDRE                ; check whether a byte can be transmitted
0099   0129 28 24               jr z, im1_rts_check         ; if not, go check for the receive RTS selection
0100   012B             
0101   012B 2A 26 80            ld hl, (serTxOutPtr)        ; get the pointer to place where we pop the Tx byte
0102   012E 7E                  ld a, (hl)                  ; get the Tx byte
0103   012F D3 81               out (SER_DATA_ADDR), a      ; output the Tx byte to the ACIA
0104   0131             
0105   0131 23                  inc hl                      ; move the Tx pointer along
0106   0132 7D                  ld a, l                     ; get the low byte of the Tx pointer
0107   0133 FE 0F               cp (serTxBuf + SER_TX_BUFSIZE) & $FF
0108   0135 20 03               jr nz, im1_tx_no_wrap
0109   0137 21 00 82            ld hl, serTxBuf             ; we wrapped, so go back to start of buffer
0110   013A             
0111   013A             im1_tx_no_wrap:
0112   013A                     
0113   013A 22 26 80            ld (serTxOutPtr), hl        ; write where the next byte should be popped
0114   013D             
0115   013D 21 29 80            ld hl, serTxBufUsed
0116   0140 35                  dec (hl)                    ; atomically decrement current Tx count
0117   0141 20 1F               jr nz, im1_txa_end          ; if we've more Tx bytes to send, we're done for now
0118   0143                     
0119   0143             im1_tei_clear:
0120   0143             
0121   0143 3A 2A 80            ld a, (serControl)          ; get the ACIA control echo byte
0122   0146 E6 9F               and ~SER_TEI_MASK           ; mask out the Tx interrupt bits
0123   0148 F6 00               or SER_TDI_RTS0             ; mask out (disable) the Tx Interrupt, keep RTS low
0124   014A 32 2A 80            ld (serControl), a          ; write the ACIA control byte back
0125   014D D3 80               out (SER_CTRL_ADDR), a      ; Set the ACIA CTRL register
0126   014F             
0127   014F             im1_rts_check:
0128   014F             
0129   014F 3A 28 80            ld a, (serRxBufUsed)        ; get the current Rx count    	
0130   0152 FE F7               cp SER_RX_FULLSIZE          ; compare the count with the preferred full size
0131   0154 38 0C               jr c, im1_txa_end           ; leave the RTS low, and end
0132   0156             
0133   0156 3A 2A 80            ld a, (serControl)          ; get the ACIA control echo byte
0134   0159 E6 9F               and ~SER_TEI_MASK           ; mask out the Tx interrupt bits
0135   015B F6 40               or SER_TDI_RTS1             ; Set RTS high, and disable Tx Interrupt
0136   015D 32 2A 80            ld (serControl), a          ; write the ACIA control echo byte back
0137   0160 D3 80               out (SER_CTRL_ADDR), a	    ; Set the ACIA CTRL register
0138   0162             
0139   0162             im1_txa_end:
0140   0162             
0141   0162 E1                  pop hl
0142   0163 F1                  pop af
0143   0164             
0144   0164 FB                  ei
0145   0165 ED 4D               reti
0146   0167             
0147   0167             ;------------------------------------------------------------------------------
0148   0167             RXA:
0149   0167             rxa_wait_for_byte:
0150   0167             
0151   0167 3A 28 80            ld a, (serRxBufUsed)        ; get the number of bytes in the Rx buffer
0152   016A             
0153   016A B7                  or a                        ; see if there are zero bytes available
0154   016B 28 FA               jr z, rxa_wait_for_byte     ; wait, if there are no bytes available
0155   016D                     
0156   016D E5                  push hl                     ; Store HL so we don't clobber it
0157   016E             
0158   016E 2A 22 80            ld hl, (serRxOutPtr)        ; get the pointer to place where we pop the Rx byte
0159   0171 7E                  ld a, (hl)                  ; get the Rx byte
0160   0172 F5                  push af                     ; save the Rx byte on stack
0161   0173             
0162   0173 2C                  inc l                       ; move the Rx pointer low byte along
0163   0174 22 22 80            ld (serRxOutPtr), hl        ; write where the next byte should be popped
0164   0177             
0165   0177 21 28 80            ld hl,serRxBufUsed
0166   017A 35                  dec (hl)                    ; atomically decrement Rx count
0167   017B 7E                  ld a,(hl)                   ; get the newly decremented Rx count
0168   017C             
0169   017C FE 08               cp SER_RX_EMPTYSIZE         ; compare the count with the preferred empty size
0170   017E 30 0E               jr nc, rxa_clean_up         ; if the buffer is too full, don't change the RTS
0171   0180             
0172   0180 F3                  di                          ; critical section begin
0173   0181                     
0174   0181 3A 2A 80            ld a, (serControl)          ; get the ACIA control echo byte
0175   0184 E6 9F               and ~SER_TEI_MASK           ; mask out the Tx interrupt bits
0176   0186 F6 00               or SER_TDI_RTS0             ; set RTS low.
0177   0188 32 2A 80            ld (serControl), a          ; write the ACIA control echo byte back
0178   018B D3 80               out (SER_CTRL_ADDR), a      ; set the ACIA CTRL register
0179   018D                     
0180   018D FB                  ei                          ; critical section end
0181   018E             
0182   018E             rxa_clean_up:
0183   018E             
0184   018E F1                  pop af                      ; get the Rx byte from stack
0185   018F E1                  pop hl                      ; recover HL
0186   0190             
0187   0190 C9                  ret                         ; char ready in A
0188   0191             
0189   0191             ;------------------------------------------------------------------------------
0190   0191             TXA:
0191   0191 E5                  push hl                     ; Store HL so we don't clobber it        
0192   0192 6F                  ld l, a                     ; Store Tx character
0193   0193             
0194   0193 3A 29 80            ld a, (serTxBufUsed)        ; Get the number of bytes in the Tx buffer
0195   0196 B7                  or a                        ; check whether the buffer is empty
0196   0197 20 0B               jr nz, txa_buffer_out       ; buffer not empty, so abandon immediate Tx
0197   0199                     
0198   0199 DB 80               in a, (SER_STATUS_ADDR)     ; get the status of the ACIA
0199   019B E6 02               and SER_TDRE                ; check whether a byte can be transmitted
0200   019D 28 05               jr z, txa_buffer_out        ; if not, so abandon immediate Tx
0201   019F                     
0202   019F 7D                  ld a, l                     ; Retrieve Tx character
0203   01A0 D3 81               out (SER_DATA_ADDR), a      ; immediately output the Tx byte to the ACIA
0204   01A2                     
0205   01A2 18 2A               jr txa_end                  ; and just complete
0206   01A4             
0207   01A4             txa_buffer_out:
0208   01A4             
0209   01A4 3A 29 80            ld a, (serTxBufUsed)        ; Get the number of bytes in the Tx buffer
0210   01A7 FE 0F               cp SER_TX_BUFSIZE           ; check whether there is space in the buffer
0211   01A9 30 F9               jr nc, txa_buffer_out       ; buffer full, so wait till it has space
0212   01AB             
0213   01AB 7D                  ld a, l                     ; Retrieve Tx character
0214   01AC 2A 24 80            ld hl, (serTxInPtr)         ; get the pointer to where we poke
0215   01AF 77                  ld (hl), a                  ; write the Tx byte to the serTxInPtr
0216   01B0             
0217   01B0 23                  inc hl                      ; move the Tx pointer along
0218   01B1 7D                  ld a, l                     ; move low byte of the Tx pointer
0219   01B2 FE 0F               cp (serTxBuf + SER_TX_BUFSIZE) & $FF
0220   01B4 20 03               jr nz, txa_no_wrap
0221   01B6 21 00 82            ld hl, serTxBuf             ; we wrapped, so go back to start of buffer
0222   01B9             
0223   01B9             txa_no_wrap:
0224   01B9                     
0225   01B9 22 24 80            ld (serTxInPtr), hl         ; write where the next byte should be poked
0226   01BC             
0227   01BC 21 29 80            ld hl, serTxBufUsed
0228   01BF 34                  inc (hl)                    ; atomic increment of Tx count
0229   01C0             
0230   01C0             txa_clean_up:
0231   01C0                     
0232   01C0 F3                  di                          ; critical section begin
0233   01C1                     
0234   01C1 3A 2A 80            ld a, (serControl)          ; get the ACIA control echo byte
0235   01C4 E6 9F               and ~SER_TEI_MASK           ; mask out the Tx interrupt bits
0236   01C6 F6 20               or SER_TEI_RTS0             ; set RTS low. if the TEI was not set, it will work again
0237   01C8 32 2A 80            ld (serControl), a          ; write the ACIA control echo byte back
0238   01CB D3 80               out (SER_CTRL_ADDR), a      ; set the ACIA CTRL register
0239   01CD             
0240   01CD FB                  ei                          ; critical section end
0241   01CE             
0242   01CE             txa_end:
0243   01CE             
0244   01CE E1                  pop hl                      ; recover HL
0245   01CF C9                  ret
0246   01D0             
0247   01D0             ;------------------------------------------------------------------------------
0248   01D0             RXA_CHK:
0249   01D0 3A 28 80                LD        A,(serRxBufUsed)
0250   01D3 FE 00                   CP        $0
0251   01D5 C9                      RET
0252   01D6             
0253   01D6             ;------------------------------------------------------------------------------
0254   01D6             PRINT:
0255   01D6 7E                      LD        A,(HL)          ; Get character
0256   01D7 B7                      OR        A               ; Is it $00 ?
0257   01D8 C8                      RET       Z               ; Then RETurn on terminator
0258   01D9 CF                      RST       08H             ; Print it
0259   01DA 23                      INC       HL              ; Next Character
0260   01DB 18 F9                   JR        PRINT           ; Continue until $00
0261   01DD             
0262   01DD             ;------------------------------------------------------------------------------
0263   01DD             HEX_START:
0264   01DD 21 30 03                ld hl, initString
0265   01E0 CD D6 01                call PRINT
0266   01E3             HEX_WAIT_COLON:
0267   01E3 CD 67 01                call RXA        ; Rx byte
0268   01E6 FE 3A                   cp ':'          ; wait for ':'
0269   01E8 20 F9                   jr nz, HEX_WAIT_COLON
0270   01EA 21 00 00                ld hl, 0        ; reset hl to compute checksum
0271   01ED CD 4A 02                call HEX_READ_BYTE  ; read byte count
0272   01F0 47                      ld b, a         ; store it in b
0273   01F1 CD 4A 02                call HEX_READ_BYTE  ; read upper byte of address
0274   01F4 57                      ld d, a         ; store in d
0275   01F5 CD 4A 02                call HEX_READ_BYTE  ; read lower byte of address
0276   01F8 5F                      ld e, a         ; store in e
0277   01F9 CD 4A 02                call HEX_READ_BYTE  ; read record type
0278   01FC FE 01                   cp 01           ; check if record type is 01 (end of file)
0279   01FE 28 28                   jr z, HEX_END_LOAD
0280   0200 FE 00                   cp 00           ; check if record type is 00 (data)
0281   0202 20 34                   jr nz, HEX_INVAL_TYPE ; if not, error
0282   0204             HEX_READ_DATA:
0283   0204 3E 2A                   ld a, '*'       ; "*" per byte loaded  # DEBUG
0284   0206 CD 91 01                call TXA        ; Print it             # DEBUG
0285   0209 CD 4A 02                call HEX_READ_BYTE
0286   020C 12                      ld (de), a      ; write the byte at the RAM address
0287   020D 13                      inc de
0288   020E 10 F4                   djnz HEX_READ_DATA  ; if b non zero, loop to get more data
0289   0210             HEX_READ_CHKSUM:
0290   0210 CD 4A 02                call HEX_READ_BYTE  ; read checksum, but we don't need to keep it
0291   0213 7D                      ld a, l         ; lower byte of hl checksum should be 0
0292   0214 B7                      or a
0293   0215 20 2A                   jr nz, HEX_BAD_CHK  ; non zero, we have an issue
0294   0217 3E 23                   ld a, '#'       ; "#" per line loaded
0295   0219 CD 91 01                call TXA        ; Print it
0296   021C 3E 0D                   ld a, CR        ; CR                   # DEBUG
0297   021E CD 91 01                call TXA        ; Print it             # DEBUG
0298   0221 3E 0A                   ld a, LF        ; LF                   # DEBUG
0299   0223 CD 91 01                call TXA        ; Print it             # DEBUG
0300   0226 18 BB                   jr HEX_WAIT_COLON
0301   0228             
0302   0228             HEX_END_LOAD:
0303   0228 CD 4A 02                call HEX_READ_BYTE  ; read checksum, but we don't need to keep it
0304   022B 7D                      ld a, l         ; lower byte of hl checksum should be 0
0305   022C B7                      or a
0306   022D 20 12                   jr nz, HEX_BAD_CHK  ; non zero, we have an issue
0307   022F 21 5B 03                ld hl, LoadOKStr
0308   0232 CD D6 01                call PRINT
0309   0235 C3 DB 02                jp WARMSTART    ; ready to run our loaded program from Basic
0310   0238                         
0311   0238             HEX_INVAL_TYPE:
0312   0238 21 3F 03                ld hl, invalidTypeStr
0313   023B CD D6 01                call PRINT
0314   023E C3 A2 02                jp START        ; go back to start
0315   0241             
0316   0241             HEX_BAD_CHK:
0317   0241 21 4C 03                ld hl, badCheckSumStr
0318   0244 CD D6 01                call PRINT
0319   0247 C3 A2 02                jp START        ; go back to start
0320   024A             
0321   024A             HEX_READ_BYTE:              ; Returns byte in a, checksum in hl
0322   024A C5                      push bc
0323   024B CD 67 01                call RXA        ; Rx byte
0324   024E D6 30                   sub '0'
0325   0250 FE 0A                   cp 10
0326   0252 38 02                   jr c, HEX_READ_NBL2 ; if a<10 read the second nibble
0327   0254 D6 07                   sub 7           ; else subtract 'A'-'0' (17) and add 10
0328   0256             HEX_READ_NBL2:
0329   0256 07                      rlca            ; shift accumulator left by 4 bits
0330   0257 07                      rlca
0331   0258 07                      rlca
0332   0259 07                      rlca
0333   025A 4F                      ld c, a         ; temporarily store the first nibble in c
0334   025B CD 67 01                call RXA        ; Rx byte
0335   025E D6 30                   sub '0'
0336   0260 FE 0A                   cp 10
0337   0262 38 02                   jr c, HEX_READ_END  ; if a<10 finalize
0338   0264 D6 07                   sub 7           ; else subtract 'A' (17) and add 10
0339   0266             HEX_READ_END:
0340   0266 B1                      or c            ; assemble two nibbles into one byte in a
0341   0267 06 00                   ld b, 0         ; add the byte read to hl (for checksum)
0342   0269 4F                      ld c, a
0343   026A 09                      add hl, bc
0344   026B C1                      pop bc
0345   026C C9                      ret             ; return the byte read in a
0346   026D             
0347   026D             
0348   026D             ;------------------------------------------------------------------------------
0349   026D             INIT:
0350   026D 31 CB 82                   LD        SP,TEMPSTACK    ; Set up a temporary stack
0351   0270             
0352   0270 21 40 00                   LD        HL,VECTOR_PROTO ; Establish Z80 RST Vector Table
0353   0273 11 00 80                   LD        DE,Z80_VECTOR_TABLE
0354   0276 01 1F 00                   LD        BC,VECTOR_PROTO_SIZE
0355   0279 ED B0                      LDIR
0356   027B             
0357   027B 21 00 81                   LD        HL,serRxBuf     ; Initialise Rx Buffer
0358   027E 22 20 80                   LD        (serRxInPtr),HL
0359   0281 22 22 80                   LD        (serRxOutPtr),HL
0360   0284             
0361   0284 21 00 82                   LD        HL,serTxBuf     ; Initialise Tx Buffer
0362   0287 22 24 80                   LD        (serTxInPtr),HL
0363   028A 22 26 80                   LD        (serTxOutPtr),HL              
0364   028D             
0365   028D AF                         XOR       A               ; 0 the accumulator
0366   028E 32 28 80                   LD        (serRxBufUsed),A
0367   0291 32 29 80                   LD        (serTxBufUsed),A
0368   0294                            
0369   0294 3E 03                      LD        A, SER_RESET    ; Master Reset the ACIA
0370   0296 D3 80                      OUT       (SER_CTRL_ADDR),A
0371   0298             
0372   0298 3E 96                      LD        A, SER_REI|SER_TDI_RTS0|SER_8N1|SER_CLK_DIV_64
0373   029A                                                      ; load the default ACIA configuration
0374   029A                                                      ; 8n1 at 115200 baud
0375   029A                                                      ; receive interrupt enabled
0376   029A                                                      ; transmit interrupt disabled
0377   029A                                                 
0378   029A 32 2A 80                   LD        (serControl),A     ; write the ACIA control byte echo
0379   029D D3 80                      OUT       (SER_CTRL_ADDR),A  ; output to the ACIA control byte
0380   029F                            
0381   029F ED 56                      IM        1               ; interrupt mode 1
0382   02A1 FB                         EI
0383   02A2             START:
0384   02A2 21 DE 02                   LD        HL, SIGNON1     ; Sign-on message
0385   02A5 CD D6 01                   CALL      PRINT           ; Output string
0386   02A8 3A 2B 80                   LD        A,(basicStarted); Check the BASIC STARTED flag
0387   02AB FE 59                      CP        'Y'             ; to see if this is power-up
0388   02AD 20 19                      JR        NZ, COLDSTART   ; If not BASIC started then always do cold start
0389   02AF 21 03 03                   LD        HL, SIGNON2     ; Cold/warm message
0390   02B2 CD D6 01                   CALL      PRINT           ; Output string
0391   02B5             CORW:
0392   02B5 D7                         RST       10H
0393   02B6 E6 DF                      AND       %11011111       ; lower to uppercase
0394   02B8 FE 48                      CP        'H'             ; are we trying to load an Intel HEX program?
0395   02BA CA DD 01                   JP        Z, HEX_START    ; then jump to HexLoadr
0396   02BD FE 43                      CP        'C'
0397   02BF 20 0F                      JR        NZ, CHECKWARM
0398   02C1 CF                         RST       08H
0399   02C2 3E 0D                      LD        A,$0D
0400   02C4 CF                         RST       08H
0401   02C5 3E 0A                      LD        A,$0A
0402   02C7 CF                         RST       08H
0403   02C8             COLDSTART:
0404   02C8 3E 59                      LD        A,'Y'           ; Set the BASIC STARTED flag
0405   02CA 32 2B 80                   LD        (basicStarted),A
0406   02CD C3 90 03                   JP        $0390           ; <<<< Start Basic COLD:
0407   02D0             CHECKWARM:
0408   02D0 FE 57                      CP        'W'
0409   02D2 20 E1                      JR        NZ, CORW
0410   02D4 CF                         RST       08H
0411   02D5 3E 0D                      LD        A,$0D
0412   02D7 CF                         RST       08H
0413   02D8 3E 0A                      LD        A,$0A
0414   02DA CF                         RST       08H
0415   02DB             WARMSTART:
0416   02DB C3 93 03                   JP        $0393           ; <<<< Start Basic WARM:
0417   02DE             
0418   02DE             ;==============================================================================
0419   02DE             ;
0420   02DE             ; STRINGS
0421   02DE             ;
0422   02DE 534243202D20SIGNON1:        .BYTE   "SBC - Grant Searle",CR,LF
0422   02E4 4772616E7420536561726C650D0A
0423   02F2 41434941202D                .BYTE   "ACIA - feilipu",CR,LF,0
0423   02F8 206665696C6970750D0A00
0424   0303 0D 0A       SIGNON2:        .BYTE   CR,LF
0425   0305 436F6C64206F                .BYTE   "Cold or Warm start, "
0425   030B 72205761726D2073746172742C20
0426   0319 6F7220486578                .BYTE   "or HexLoadr (C|W|H) ? ",0
0426   031F 4C6F6164722028437C577C4829203F2000
0427   0330             
0428   0330 0D 0A       initString:     .BYTE   CR,LF
0429   0332 4865784C6F61                .BYTE   "HexLoadr: "
0429   0338 64723A20
0430   033C 0D 0A 00                    .BYTE   CR,LF,0
0431   033F             
0432   033F 496E76616C20invalidTypeStr: .BYTE   "Inval Type",CR,LF,0
0432   0345 547970650D0A00
0433   034C 43686B73756DbadCheckSumStr: .BYTE   "Chksum Error",CR,LF,0
0433   0352 204572726F720D0A00
0434   035B 446F6E650D0ALoadOKStr:      .BYTE   "Done",CR,LF,0
0434   0361 00
0435   0362             
0436   0362             ;==============================================================================
0437   0362             ;
0438   0362             ; Z80 INTERRUPT VECTOR PROTOTYPE ASSIGNMENTS
0439   0362             ;
0440   0362             
0441   0362             RST_08      .EQU    TXA             ; TX a character over ACIA
0442   0362             RST_10      .EQU    RXA             ; RX a character over ACIA, loop byte available
0443   0362             RST_18      .EQU    RXA_CHK         ; Check ACIA status, return # bytes available
0444   0362             RST_20      .EQU    NULL_RET        ; RET
0445   0362             RST_28      .EQU    NULL_RET        ; RET
0446   0362             RST_30      .EQU    NULL_RET        ; RET
0447   0362             INT_00      .EQU    serialInt       ; ACIA interrupt
0448   0362             INT_NMI     .EQU    NULL_NMI        ; RETN
0449   0362             
0450   0362             ;==============================================================================
0451   0362             ;
0452   0362                         .END
0453   0362             ;
0454   0362             ;==============================================================================
0455   0362             
0456   0362             



Label        Value      Label        Value      Label        Value
------------------      ------------------      ------------------
BKSP          0008      CTRLC         0003      CTRLG         0007      
CS            000C      CR            000D      CTRLO         000F      
CTRLQ         0011      CTRLR         0012      CTRLS         0013      
CTRLU         0015      CORW          02B5      COLDSTART     02C8      
CHECKWARM     02D0      DEL           007F      ESC           001B      
HEX_START     01DD      HEX_WAIT_COLON 01E3      HEX_READ_DATA 0204      
HEX_READ_CHKSUM 0210      HEX_END_LOAD  0228      HEX_INVAL_TYPE 0238      
HEX_BAD_CHK   0241      HEX_READ_BYTE 024A      HEX_READ_NBL2 0256      
HEX_READ_END  0266      INT_00_ADDR   801A      INT_NMI_ADDR  801E      
INT_00_LBL    0059      INT_NMI_LBL   005D      INIT          026D      
INT_00        0100      INT_NMI       0062      LF            000A      
LoadOKStr     035B      NULL_RET_ADDR 0040      NULL_INT_ADDR 0060      
NULL_NMI_ADDR 0062      NULL_RET      0040      NULL_INT      0060      
NULL_NMI      0062      PRINT         01D6      ROMSTART      0000      
ROMSTOP       1FFF      RAM_START     8000      RAMSTOP       FFFF      
RST_08_ADDR   8002      RST_10_ADDR   8006      RST_18_ADDR   800A      
RST_20_ADDR   800E      RST_28_ADDR   8012      RST_30_ADDR   8016      
RST_08_LBL    0041      RST_10_LBL    0045      RST_18_LBL    0049      
RST_20_LBL    004D      RST_28_LBL    0051      RST_30_LBL    0055      
RXA           0167      RXA_CHK       01D0      RST_08        0191      
RST_10        0167      RST_18        01D0      RST_20        0040      
RST_28        0040      RST_30        0040      SER_CTRL_ADDR 0080      
SER_STATUS_ADDR 0080      SER_DATA_ADDR 0081      SER_CLK_DIV_01 0000      
SER_CLK_DIV_16 0001      SER_CLK_DIV_64 0002      SER_RESET     0003      
SER_7E2       0000      SER_7O2       0004      SER_7E1       0008      
SER_7O1       000C      SER_8N2       0010      SER_8N1       0014      
SER_8E1       0018      SER_8O1       001C      SER_TDI_RTS0  0000      
SER_TEI_RTS0  0020      SER_TDI_RTS1  0040      SER_TDI_BRK   0060      
SER_TEI_MASK  0060      SER_REI       0080      SER_RDRF      0001      
SER_TDRE      0002      SER_DCD       0004      SER_CTS       0008      
SER_FE        0010      SER_OVRN      0020      SER_PE        0040      
SER_IRQ       0080      SER_RX_BUFSIZE 00FF      SER_RX_FULLSIZE 00F7      
SER_RX_EMPTYSIZE 0008      SER_TX_BUFSIZE 000F      START         02A2      
SIGNON1       02DE      SIGNON2       0303      TEMPSTACK     82CB      
TXA           0191      VECTOR_PROTO  0040      VECTOR_PROTO_SIZE 001F      
WRKSPC        8220      WARMSTART     02DB      Z80_VECTOR_TABLE 8000      
basicStarted  802B      badCheckSumStr 034C      im1_tx_check  011F      
im1_tx_no_wrap 013A      im1_tei_clear 0143      im1_rts_check 014F      
im1_txa_end   0162      initString    0330      invalidTypeStr 033F      
rxa_wait_for_byte 0167      rxa_clean_up  018E      serRxInPtr    8020      
serRxOutPtr   8022      serTxInPtr    8024      serTxOutPtr   8026      
serRxBufUsed  8028      serTxBufUsed  8029      serControl    802A      
serRxBuf      8100      serTxBuf      8200      serialInt     0100      
txa_buffer_out 01A4      txa_no_wrap   01B9      txa_clean_up  01C0      
txa_end       01CE      

tasm: Number of errors = 0
