0001   0000             ;==================================================================================
0002   0000             ; The updates to the original BASIC within this file are copyright Grant Searle
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; http://searle.hostei.com/grant/index.html
0008   0000             ;
0009   0000             ; eMail: home.micros01@btinternet.com
0010   0000             ;
0011   0000             ; If the above don't work, please perform an Internet search to see if I have
0012   0000             ; updated the web page hosting service.
0013   0000             ;
0014   0000             ;==================================================================================
0015   0000             
0016   0000             ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
0017   0000             ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
0018   0000             ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
0019   0000             ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
0020   0000             ; the original ROM code (checksum A934H). PA
0021   0000             
0022   0000             ; GENERAL EQUATES
0023   0000             
0024   0000             CTRLC   .EQU    03H             ; Control "C"
0025   0000             CTRLG   .EQU    07H             ; Control "G"
0026   0000             BKSP    .EQU    08H             ; Back space
0027   0000             LF      .EQU    0AH             ; Line feed
0028   0000             CS      .EQU    0CH             ; Clear screen
0029   0000             CR      .EQU    0DH             ; Carriage return
0030   0000             CTRLO   .EQU    0FH             ; Control "O"
0031   0000             CTRLQ	.EQU	11H             ; Control "Q"
0032   0000             CTRLR   .EQU    12H             ; Control "R"
0033   0000             CTRLS   .EQU    13H             ; Control "S"
0034   0000             CTRLU   .EQU    15H             ; Control "U"
0035   0000             ESC     .EQU    1BH             ; Escape
0036   0000             DEL     .EQU    7FH             ; Delete
0037   0000             
0038   0000             ; BASIC WORK SPACE LOCATIONS
0039   0000             
0040   0000             WRKSPC  .EQU    2120H           ; <<<< BASIC Work space ** larger Rx buffer & Tx buffer **
0041   0000             USR     .EQU    WRKSPC+3H       ; "USR (x)" jump
0042   0000             OUTSUB  .EQU    WRKSPC+6H       ; "OUT p,n"
0043   0000             OTPORT  .EQU    WRKSPC+7H       ; Port (p)
0044   0000             DIVSUP  .EQU    WRKSPC+9H       ; Division support routine
0045   0000             DIV1    .EQU    WRKSPC+0AH      ; <- Values
0046   0000             DIV2    .EQU    WRKSPC+0EH      ; <-   to
0047   0000             DIV3    .EQU    WRKSPC+12H      ; <-   be
0048   0000             DIV4    .EQU    WRKSPC+15H      ; <-inserted
0049   0000             SEED    .EQU    WRKSPC+17H      ; Random number seed
0050   0000             LSTRND  .EQU    WRKSPC+3AH      ; Last random number
0051   0000             INPSUB  .EQU    WRKSPC+3EH      ; #INP (x)" Routine
0052   0000             INPORT  .EQU    WRKSPC+3FH      ; PORT (x)
0053   0000             NULLS   .EQU    WRKSPC+41H      ; Number of nulls
0054   0000             LWIDTH  .EQU    WRKSPC+42H      ; Terminal width
0055   0000             COMMAN  .EQU    WRKSPC+43H      ; Width for commas
0056   0000             NULFLG  .EQU    WRKSPC+44H      ; Null after input byte flag
0057   0000             CTLOFG  .EQU    WRKSPC+45H      ; Control "O" flag
0058   0000             LINESC  .EQU    WRKSPC+46H      ; Lines counter
0059   0000             LINESN  .EQU    WRKSPC+48H      ; Lines number
0060   0000             CHKSUM  .EQU    WRKSPC+4AH      ; Array load/save check sum
0061   0000             NMIFLG  .EQU    WRKSPC+4CH      ; Flag for NMI break routine
0062   0000             BRKFLG  .EQU    WRKSPC+4DH      ; Break flag
0063   0000             RINPUT  .EQU    WRKSPC+4EH      ; Input reflection
0064   0000             POINT   .EQU    WRKSPC+51H      ; "POINT" reflection (unused)
0065   0000             PSET    .EQU    WRKSPC+54H      ; "SET"   reflection
0066   0000             RESET   .EQU    WRKSPC+57H      ; "RESET" reflection
0067   0000             STRSPC  .EQU    WRKSPC+5AH      ; Bottom of string space
0068   0000             LINEAT  .EQU    WRKSPC+5CH      ; Current line number
0069   0000             BASTXT  .EQU    WRKSPC+5EH      ; Pointer to start of program
0070   0000             BUFFER  .EQU    WRKSPC+61H      ; Input buffer
0071   0000             STACK   .EQU    WRKSPC+66H      ; Initial stack
0072   0000             CURPOS  .EQU    WRKSPC+0ABH     ; <<<< Character position on line ** Top of TEMPSTACK **
0073   0000             LCRFLG  .EQU    WRKSPC+0ACH     ; Locate/Create flag
0074   0000             TYPE    .EQU    WRKSPC+0ADH     ; Data type flag
0075   0000             DATFLG  .EQU    WRKSPC+0AEH     ; Literal statement flag
0076   0000             LSTRAM  .EQU    WRKSPC+0AFH     ; Last available RAM
0077   0000             TMSTPT  .EQU    WRKSPC+0B1H     ; Temporary string pointer
0078   0000             TMSTPL  .EQU    WRKSPC+0B3H     ; Temporary string pool
0079   0000             TMPSTR  .EQU    WRKSPC+0BFH     ; Temporary string
0080   0000             STRBOT  .EQU    WRKSPC+0C3H     ; Bottom of string space
0081   0000             CUROPR  .EQU    WRKSPC+0C5H     ; Current operator in EVAL
0082   0000             LOOPST  .EQU    WRKSPC+0C7H     ; First statement of loop
0083   0000             DATLIN  .EQU    WRKSPC+0C9H     ; Line of current DATA item
0084   0000             FORFLG  .EQU    WRKSPC+0CBH     ; "FOR" loop flag
0085   0000             LSTBIN  .EQU    WRKSPC+0CCH     ; Last byte entered
0086   0000             READFG  .EQU    WRKSPC+0CDH     ; Read/Input flag
0087   0000             BRKLIN  .EQU    WRKSPC+0CEH     ; Line of break
0088   0000             NXTOPR  .EQU    WRKSPC+0D0H     ; Next operator in EVAL
0089   0000             ERRLIN  .EQU    WRKSPC+0D2H     ; Line of error
0090   0000             CONTAD  .EQU    WRKSPC+0D4H     ; Where to CONTinue
0091   0000             PROGND  .EQU    WRKSPC+0D6H     ; End of program
0092   0000             VAREND  .EQU    WRKSPC+0D8H     ; End of variables
0093   0000             ARREND  .EQU    WRKSPC+0DAH     ; End of arrays
0094   0000             NXTDAT  .EQU    WRKSPC+0DCH     ; Next data item
0095   0000             FNRGNM  .EQU    WRKSPC+0DEH     ; Name of FN argument
0096   0000             FNARG   .EQU    WRKSPC+0E0H     ; FN argument value
0097   0000             FPREG   .EQU    WRKSPC+0E4H     ; Floating point register
0098   0000             FPEXP   .EQU    FPREG+3         ; Floating point exponent
0099   0000             SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0100   0000             PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0101   0000             MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0102   0000             PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
0103   0000             STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0104   0000             
0105   0000             ; BASIC ERROR CODE VALUES
0106   0000             
0107   0000             NF      .EQU    00H             ; NEXT without FOR
0108   0000             SN      .EQU    02H             ; Syntax error
0109   0000             RG      .EQU    04H             ; RETURN without GOSUB
0110   0000             OD      .EQU    06H             ; Out of DATA
0111   0000             FC      .EQU    08H             ; Function call error
0112   0000             OV      .EQU    0AH             ; Overflow
0113   0000             OM      .EQU    0CH             ; Out of memory
0114   0000             UL      .EQU    0EH             ; Undefined line number
0115   0000             BS      .EQU    10H             ; Bad subscript
0116   0000             DD      .EQU    12H             ; Re-DIMensioned array
0117   0000             DZ      .EQU    14H             ; Division by zero (/0)
0118   0000             ID      .EQU    16H             ; Illegal direct
0119   0000             TM      .EQU    18H             ; Type miss-match
0120   0000             OS      .EQU    1AH             ; Out of string space
0121   0000             LS      .EQU    1CH             ; String too long
0122   0000             ST      .EQU    1EH             ; String formula too complex
0123   0000             CN      .EQU    20H             ; Can't CONTinue
0124   0000             UF      .EQU    22H             ; UnDEFined FN function
0125   0000             MO      .EQU    24H             ; Missing operand
0126   0000             HX      .EQU    26H             ; HEX error
0127   0000             BN      .EQU    28H             ; BIN error
0128   0000             
0129   0290                     .ORG    00290H          ; <<<< Modified to allow for Z180 Tx/Rx interrupt code
0130   0290             
0131   0290 C3 96 02    COLD:   JP      STARTB          ; Jump in for cold start (00290H)
0132   0293 C3 34 03    WARM:   JP      WARMST          ; Jump in for warm start (00293H)
0133   0296             STARTB: 
0134   0296 DD 21 00 00         LD      IX,0            ; Flag cold start
0135   029A C3 A1 02            JP      CSTART          ; Jump to initialise
0136   029D             
0137   029D 47 0B               .WORD   DEINT           ; Get integer -32768 to 32767
0138   029F BD 12               .WORD   ABPASS          ; Return integer in AB
0139   02A1             
0140   02A1             
0141   02A1 21 20 21    CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0142   02A4 F9                  LD      SP,HL           ; Set up a temporary stack
0143   02A5 C3 DC 1E            JP      INITST          ; Go to initialise
0144   02A8             
0145   02A8 11 6E 05    INIT:   LD      DE,INITAB       ; Initialise workspace
0146   02AB 06 63               LD      B,INITBE-INITAB+3; Bytes to copy
0147   02AD 21 20 21            LD      HL,WRKSPC       ; Into workspace RAM
0148   02B0 1A          COPY:   LD      A,(DE)          ; Get source
0149   02B1 77                  LD      (HL),A          ; To destination
0150   02B2 23                  INC     HL              ; Next destination
0151   02B3 13                  INC     DE              ; Next source
0152   02B4 05                  DEC     B               ; Count bytes
0153   02B5 C2 B0 02            JP      NZ,COPY         ; More to move
0154   02B8 F9                  LD      SP,HL           ; Temporary stack
0155   02B9 CD 6F 07            CALL    CLREG           ; Clear registers and stack
0156   02BC CD 3D 0D            CALL    PRNTCRLF        ; Output CRLF
0157   02BF 32 CA 21            LD      (BUFFER+72+1),A ; Mark end of buffer
0158   02C2 32 19 22            LD      (PROGST),A      ; Initialise program area
0159   02C5 21 83 03    MSIZE:  LD      HL,MEMMSG       ; Point to message
0160   02C8 CD DB 13            CALL    PRS             ; Output "Memory size"
0161   02CB CD 8C 07            CALL    PROMPT          ; Get input with '?'
0162   02CE CD 95 0A            CALL    GETCHR          ; Get next character
0163   02D1 B7                  OR      A               ; Set flags
0164   02D2 C2 EA 02            JP      NZ,TSTMEM       ; If number - Test if RAM there
0165   02D5 21 7D 22            LD      HL,STLOOK       ; Point to start of RAM
0166   02D8 23          MLOOP:  INC     HL              ; Next byte
0167   02D9 7C                  LD      A,H             ; Above address FFFF ?
0168   02DA B5                  OR      L
0169   02DB CA FC 02            JP      Z,SETTOP        ; Yes - 64K RAM
0170   02DE 7E                  LD      A,(HL)          ; Get contents
0171   02DF 47                  LD      B,A             ; Save it
0172   02E0 2F                  CPL                     ; Flip all bits
0173   02E1 77                  LD      (HL),A          ; Put it back
0174   02E2 BE                  CP      (HL)            ; RAM there if same
0175   02E3 70                  LD      (HL),B          ; Restore old contents
0176   02E4 CA D8 02            JP      Z,MLOOP         ; If RAM - test next byte
0177   02E7 C3 FC 02            JP      SETTOP          ; Top of RAM found
0178   02EA             
0179   02EA CD 61 0B    TSTMEM: CALL    ATOH            ; Get high memory into DE
0180   02ED B7                  OR      A               ; Set flags on last byte
0181   02EE C2 3D 06            JP      NZ,SNERR        ; ?SN Error if bad character
0182   02F1 EB                  EX      DE,HL           ; Address into HL
0183   02F2 2B                  DEC     HL              ; Back one byte
0184   02F3 3E D9               LD      A,11011001B     ; Test byte
0185   02F5 46                  LD      B,(HL)          ; Get old contents
0186   02F6 77                  LD      (HL),A          ; Load test byte
0187   02F7 BE                  CP      (HL)            ; RAM there if same
0188   02F8 70                  LD      (HL),B          ; Restore old contents
0189   02F9 C2 C5 02            JP      NZ,MSIZE        ; Ask again if no RAM
0190   02FC             
0191   02FC 2B          SETTOP: DEC     HL              ; Back one byte
0192   02FD 11 7C 22            LD      DE,STLOOK-1     ; See if enough RAM
0193   0300 CD 05 09            CALL    CPDEHL          ; Compare DE with HL
0194   0303 DA C5 02            JP      C,MSIZE         ; Ask again if not enough RAM
0195   0306 11 CE FF            LD      DE,0-50         ; 50 Bytes string space
0196   0309 22 CF 21            LD      (LSTRAM),HL     ; Save last available RAM
0197   030C 19                  ADD     HL,DE           ; Allocate string space
0198   030D 22 7A 21            LD      (STRSPC),HL     ; Save string space
0199   0310 CD 4A 07            CALL    CLRPTR          ; Clear program area
0200   0313 2A 7A 21            LD      HL,(STRSPC)     ; Get end of memory
0201   0316 11 EF FF            LD      DE,0-17         ; Offset for free bytes
0202   0319 19                  ADD     HL,DE           ; Adjust HL
0203   031A 11 19 22            LD      DE,PROGST       ; Start of program text
0204   031D 7D                  LD      A,L             ; Get LSB
0205   031E 93                  SUB     E               ; Adjust it
0206   031F 6F                  LD      L,A             ; Re-save
0207   0320 7C                  LD      A,H             ; Get MSB
0208   0321 9A                  SBC     A,D             ; Adjust it
0209   0322 67                  LD      H,A             ; Re-save
0210   0323 E5                  PUSH    HL              ; Save bytes free
0211   0324 21 4C 03            LD      HL,SIGNON       ; Sign-on message
0212   0327 CD DB 13            CALL    PRS             ; Output string
0213   032A E1                  POP     HL              ; Get bytes free back
0214   032B CD 7E 1A            CALL    PRNTHL          ; Output amount of free memory
0215   032E 21 3D 03            LD      HL,BFREE        ; " Bytes free" message
0216   0331 CD DB 13            CALL    PRS             ; Output string
0217   0334             
0218   0334 31 86 21    WARMST: LD      SP,STACK        ; Temporary stack
0219   0337 CD 6F 07    BRKRET: CALL    CLREG           ; Clear registers and stack
0220   033A C3 88 06            JP      PRNTOK          ; Go to get command line
0221   033D             
0222   033D 204279746573BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0222   0343 20667265650D0A0000
0223   034C             
0224   034C 5A3830204241SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
0224   0352 5349432056657220342E37620D0A
0225   0360 436F70797269        .BYTE   "Copyright ",40,"C",41
0225   0366 67687420284329
0226   036D 203139373820        .BYTE   " 1978 by Microsoft",CR,LF,0,0
0226   0373 6279204D6963726F736F66740D0A0000
0227   0383             
0228   0383 4D656D6F7279MEMMSG: .BYTE   "Memory top",0
0228   0389 20746F7000
0229   038E             
0230   038E             ; FUNCTION ADDRESS TABLE
0231   038E             
0232   038E F3 18       FNCTAB: .WORD   SGN
0233   0390 B7 19               .WORD   INT
0234   0392 09 19               .WORD   ABS
0235   0394 23 21               .WORD   USR
0236   0396 9B 12               .WORD   FRE
0237   0398 20 16               .WORD   INP
0238   039A C9 12               .WORD   POS
0239   039C 7D 1B               .WORD   SQR
0240   039E 5C 1C               .WORD   RND
0241   03A0 98 17               .WORD   LOG
0242   03A2 CB 1B               .WORD   EXP
0243   03A4 D1 1C               .WORD   COS
0244   03A6 D7 1C               .WORD   SIN
0245   03A8 38 1D               .WORD   TAN
0246   03AA 4D 1D               .WORD   ATN
0247   03AC 74 16               .WORD   PEEK
0248   03AE B8 1D               .WORD   DEEK
0249   03B0 71 21               .WORD   POINT
0250   03B2 4D 15               .WORD   LEN
0251   03B4 65 13               .WORD   STR
0252   03B6 E7 15               .WORD   VAL
0253   03B8 5C 15               .WORD   ASC
0254   03BA 6D 15               .WORD   CHR
0255   03BC DA 1D               .WORD   HEX
0256   03BE 6D 1E               .WORD   BIN
0257   03C0 7D 15               .WORD   LEFT
0258   03C2 AD 15               .WORD   RIGHT
0259   03C4 B7 15               .WORD   MID
0260   03C6             
0261   03C6             ; RESERVED WORD LIST
0262   03C6             
0263   03C6 C5 4E 44    WORDS:  .BYTE   'E'+80H,"ND"
0264   03C9 C6 4F 52            .BYTE   'F'+80H,"OR"
0265   03CC CE 45 58 54         .BYTE   'N'+80H,"EXT"
0266   03D0 C4 41 54 41         .BYTE   'D'+80H,"ATA"
0267   03D4 C94E505554          .BYTE   'I'+80H,"NPUT"
0268   03D9 C4 49 4D            .BYTE   'D'+80H,"IM"
0269   03DC D2 45 41 44         .BYTE   'R'+80H,"EAD"
0270   03E0 CC 45 54            .BYTE   'L'+80H,"ET"
0271   03E3 C7 4F 54 4F         .BYTE   'G'+80H,"OTO"
0272   03E7 D2 55 4E            .BYTE   'R'+80H,"UN"
0273   03EA C9 46               .BYTE   'I'+80H,"F"
0274   03EC D24553544F52        .BYTE   'R'+80H,"ESTORE"
0274   03F2 45
0275   03F3 C74F535542          .BYTE   'G'+80H,"OSUB"
0276   03F8 D2455455524E        .BYTE   'R'+80H,"ETURN"
0277   03FE D2 45 4D            .BYTE   'R'+80H,"EM"
0278   0401 D3 54 4F 50         .BYTE   'S'+80H,"TOP"
0279   0405 CF 55 54            .BYTE   'O'+80H,"UT"
0280   0408 CF 4E               .BYTE   'O'+80H,"N"
0281   040A CE 55 4C 4C         .BYTE   'N'+80H,"ULL"
0282   040E D7 41 49 54         .BYTE   'W'+80H,"AIT"
0283   0412 C4 45 46            .BYTE   'D'+80H,"EF"
0284   0415 D0 4F 4B 45         .BYTE   'P'+80H,"OKE"
0285   0419 C4 4F 4B 45         .BYTE   'D'+80H,"OKE"
0286   041D D3435245454E        .BYTE   'S'+80H,"CREEN"
0287   0423 CC494E4553          .BYTE   'L'+80H,"INES"
0288   0428 C3 4C 53            .BYTE   'C'+80H,"LS"
0289   042B D749445448          .BYTE   'W'+80H,"IDTH"
0290   0430 CD4F4E49544F        .BYTE   'M'+80H,"ONITOR"
0290   0436 52
0291   0437 D3 45 54            .BYTE   'S'+80H,"ET"
0292   043A D245534554          .BYTE   'R'+80H,"ESET"
0293   043F D052494E54          .BYTE   'P'+80H,"RINT"
0294   0444 C3 4F 4E 54         .BYTE   'C'+80H,"ONT"
0295   0448 CC 49 53 54         .BYTE   'L'+80H,"IST"
0296   044C C34C454152          .BYTE   'C'+80H,"LEAR"
0297   0451 C34C4F4144          .BYTE   'C'+80H,"LOAD"
0298   0456 C353415645          .BYTE   'C'+80H,"SAVE"
0299   045B CE 45 57            .BYTE   'N'+80H,"EW"
0300   045E             
0301   045E D4 41 42 28         .BYTE   'T'+80H,"AB("
0302   0462 D4 4F               .BYTE   'T'+80H,"O"
0303   0464 C6 4E               .BYTE   'F'+80H,"N"
0304   0466 D3 50 43 28         .BYTE   'S'+80H,"PC("
0305   046A D4 48 45 4E         .BYTE   'T'+80H,"HEN"
0306   046E CE 4F 54            .BYTE   'N'+80H,"OT"
0307   0471 D3 54 45 50         .BYTE   'S'+80H,"TEP"
0308   0475             
0309   0475 AB                  .BYTE   '+'+80H
0310   0476 AD                  .BYTE   '-'+80H
0311   0477 AA                  .BYTE   '*'+80H
0312   0478 AF                  .BYTE   '/'+80H
0313   0479 DE                  .BYTE   '^'+80H
0314   047A C1 4E 44            .BYTE   'A'+80H,"ND"
0315   047D CF 52               .BYTE   'O'+80H,"R"
0316   047F BE                  .BYTE   '>'+80H
0317   0480 BD                  .BYTE   '='+80H
0318   0481 BC                  .BYTE   '<'+80H
0319   0482             
0320   0482 D3 47 4E            .BYTE   'S'+80H,"GN"
0321   0485 C9 4E 54            .BYTE   'I'+80H,"NT"
0322   0488 C1 42 53            .BYTE   'A'+80H,"BS"
0323   048B D5 53 52            .BYTE   'U'+80H,"SR"
0324   048E C6 52 45            .BYTE   'F'+80H,"RE"
0325   0491 C9 4E 50            .BYTE   'I'+80H,"NP"
0326   0494 D0 4F 53            .BYTE   'P'+80H,"OS"
0327   0497 D3 51 52            .BYTE   'S'+80H,"QR"
0328   049A D2 4E 44            .BYTE   'R'+80H,"ND"
0329   049D CC 4F 47            .BYTE   'L'+80H,"OG"
0330   04A0 C5 58 50            .BYTE   'E'+80H,"XP"
0331   04A3 C3 4F 53            .BYTE   'C'+80H,"OS"
0332   04A6 D3 49 4E            .BYTE   'S'+80H,"IN"
0333   04A9 D4 41 4E            .BYTE   'T'+80H,"AN"
0334   04AC C1 54 4E            .BYTE   'A'+80H,"TN"
0335   04AF D0 45 45 4B         .BYTE   'P'+80H,"EEK"
0336   04B3 C4 45 45 4B         .BYTE   'D'+80H,"EEK"
0337   04B7 D04F494E54          .BYTE   'P'+80H,"OINT"
0338   04BC CC 45 4E            .BYTE   'L'+80H,"EN"
0339   04BF D3 54 52 24         .BYTE   'S'+80H,"TR$"
0340   04C3 D6 41 4C            .BYTE   'V'+80H,"AL"
0341   04C6 C1 53 43            .BYTE   'A'+80H,"SC"
0342   04C9 C3 48 52 24         .BYTE   'C'+80H,"HR$"
0343   04CD C8 45 58 24         .BYTE   'H'+80H,"EX$"
0344   04D1 C2 49 4E 24         .BYTE   'B'+80H,"IN$"
0345   04D5 CC45465424          .BYTE   'L'+80H,"EFT$"
0346   04DA D24947485424        .BYTE   'R'+80H,"IGHT$"
0347   04E0 CD 49 44 24         .BYTE   'M'+80H,"ID$"
0348   04E4 80                  .BYTE   80H             ; End of list marker
0349   04E5             
0350   04E5             ; KEYWORD ADDRESS TABLE
0351   04E5             
0352   04E5 DF 0A       WORDTB: .WORD   PEND
0353   04E7 DC 09               .WORD   FOR
0354   04E9 B7 0E               .WORD   NEXT
0355   04EB 2C 0C               .WORD   DATA
0356   04ED BE 0D               .WORD   INPUT
0357   04EF F3 10               .WORD   DIM
0358   04F1 ED 0D               .WORD   READ
0359   04F3 43 0C               .WORD   LET
0360   04F5 E9 0B               .WORD   GOTO
0361   04F7 CC 0B               .WORD   RUN
0362   04F9 BB 0C               .WORD   IF
0363   04FB A5 0A               .WORD   RESTOR
0364   04FD D8 0B               .WORD   GOSUB
0365   04FF 07 0C               .WORD   RETURN
0366   0501 2E 0C               .WORD   REM
0367   0503 DD 0A               .WORD   STOP
0368   0505 2C 16               .WORD   POUT
0369   0507 9D 0C               .WORD   ON
0370   0509 1E 0B               .WORD   NULL
0371   050B 32 16               .WORD   WAIT
0372   050D D1 12               .WORD   DEF
0373   050F 7B 16               .WORD   POKE
0374   0511 C3 1D               .WORD   DOKE
0375   0513 2E 0C               .WORD   REM
0376   0515 A9 1D               .WORD   LINES
0377   0517 9C 1D               .WORD   CLS
0378   0519 A1 1D               .WORD   WIDTH
0379   051B D9 1E               .WORD   MONITR
0380   051D 74 21               .WORD   PSET
0381   051F 77 21               .WORD   RESET
0382   0521 DF 0C               .WORD   PRINT
0383   0523 0B 0B               .WORD   CONT
0384   0525 51 09               .WORD   LIST
0385   0527 86 0B               .WORD   CLEAR
0386   0529 2E 0C               .WORD   REM
0387   052B 2E 0C               .WORD   REM
0388   052D 49 07               .WORD   NEW
0389   052F             
0390   052F             ; RESERVED WORD TOKEN VALUES
0391   052F             
0392   052F             ZEND    .EQU    080H            ; END
0393   052F             ZFOR    .EQU    081H            ; FOR
0394   052F             ZDATA   .EQU    083H            ; DATA
0395   052F             ZGOTO   .EQU    088H            ; GOTO
0396   052F             ZGOSUB  .EQU    08CH            ; GOSUB
0397   052F             ZREM    .EQU    08EH            ; REM
0398   052F             ZPRINT  .EQU    09EH            ; PRINT
0399   052F             ZNEW    .EQU    0A4H            ; NEW
0400   052F             
0401   052F             ZTAB    .EQU    0A5H            ; TAB
0402   052F             ZTO     .EQU    0A6H            ; TO
0403   052F             ZFN     .EQU    0A7H            ; FN
0404   052F             ZSPC    .EQU    0A8H            ; SPC
0405   052F             ZTHEN   .EQU    0A9H            ; THEN
0406   052F             ZNOT    .EQU    0AAH            ; NOT
0407   052F             ZSTEP   .EQU    0ABH            ; STEP
0408   052F             
0409   052F             ZPLUS   .EQU    0ACH            ; +
0410   052F             ZMINUS  .EQU    0ADH            ; -
0411   052F             ZTIMES  .EQU    0AEH            ; *
0412   052F             ZDIV    .EQU    0AFH            ; /
0413   052F             ZOR     .EQU    0B2H            ; OR
0414   052F             ZGTR    .EQU    0B3H            ; >
0415   052F             ZEQUAL  .EQU    0B4H            ; M
0416   052F             ZLTH    .EQU    0B5H            ; <
0417   052F             ZSGN    .EQU    0B6H            ; SGN
0418   052F             ZPOINT  .EQU    0C7H            ; POINT
0419   052F             ZLEFT   .EQU    0CDH +2         ; LEFT$
0420   052F             
0421   052F             ; ARITHMETIC PRECEDENCE TABLE
0422   052F             
0423   052F 79          PRITAB: .BYTE   79H             ; Precedence value
0424   0530 65 1A               .WORD   PADD            ; FPREG = <last> + FPREG
0425   0532             
0426   0532 79                  .BYTE   79H             ; Precedence value
0427   0533 99 16               .WORD   PSUB            ; FPREG = <last> - FPREG
0428   0535             
0429   0535 7C                  .BYTE   7CH             ; Precedence value
0430   0536 D7 17               .WORD   MULT            ; PPREG = <last> * FPREG
0431   0538             
0432   0538 7C                  .BYTE   7CH             ; Precedence value
0433   0539 38 18               .WORD   DIV             ; FPREG = <last> / FPREG
0434   053B             
0435   053B 7F                  .BYTE   7FH             ; Precedence value
0436   053C 86 1B               .WORD   POWER           ; FPREG = <last> ^ FPREG
0437   053E             
0438   053E 50                  .BYTE   50H             ; Precedence value
0439   053F 4C 10               .WORD   PAND            ; FPREG = <last> AND FPREG
0440   0541             
0441   0541 46                  .BYTE   46H             ; Precedence value
0442   0542 4B 10               .WORD   POR             ; FPREG = <last> OR FPREG
0443   0544             
0444   0544             ; BASIC ERROR CODE LIST
0445   0544             
0446   0544 4E 46       ERRORS: .BYTE   "NF"            ; NEXT without FOR
0447   0546 53 4E               .BYTE   "SN"            ; Syntax error
0448   0548 52 47               .BYTE   "RG"            ; RETURN without GOSUB
0449   054A 4F 44               .BYTE   "OD"            ; Out of DATA
0450   054C 46 43               .BYTE   "FC"            ; Illegal function call
0451   054E 4F 56               .BYTE   "OV"            ; Overflow error
0452   0550 4F 4D               .BYTE   "OM"            ; Out of memory
0453   0552 55 4C               .BYTE   "UL"            ; Undefined line
0454   0554 42 53               .BYTE   "BS"            ; Bad subscript
0455   0556 44 44               .BYTE   "DD"            ; Re-DIMensioned array
0456   0558 2F 30               .BYTE   "/0"            ; Division by zero
0457   055A 49 44               .BYTE   "ID"            ; Illegal direct
0458   055C 54 4D               .BYTE   "TM"            ; Type mis-match
0459   055E 4F 53               .BYTE   "OS"            ; Out of string space
0460   0560 4C 53               .BYTE   "LS"            ; String too long
0461   0562 53 54               .BYTE   "ST"            ; String formula too complex
0462   0564 43 4E               .BYTE   "CN"            ; Can't CONTinue
0463   0566 55 46               .BYTE   "UF"            ; Undefined FN function
0464   0568 4D 4F               .BYTE   "MO"            ; Missing operand
0465   056A 48 58               .BYTE   "HX"            ; HEX error
0466   056C 42 4E               .BYTE   "BN"            ; BIN error
0467   056E             
0468   056E             ; INITIALISATION TABLE -------------------------------------------------------
0469   056E             
0470   056E C3 34 03    INITAB: JP      WARMST          ; Warm start jump
0471   0571 C3 5C 0B            JP      FCERR           ; "USR (X)" jump (Set to Error)
0472   0574 D3 00               OUT     (0),A           ; "OUT p,n" skeleton
0473   0576 C9                  RET
0474   0577 D6 00               SUB     0               ; Division support routine
0475   0579 6F                  LD      L,A
0476   057A 7C                  LD      A,H
0477   057B DE 00               SBC     A,0
0478   057D 67                  LD      H,A
0479   057E 78                  LD      A,B
0480   057F DE 00               SBC     A,0
0481   0581 47                  LD      B,A
0482   0582 3E 00               LD      A,0
0483   0584 C9                  RET
0484   0585 00 00 00            .BYTE   0,0,0                   ; Random number seed table used by RND
0485   0588 35 4A CA 99         .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
0486   058C 39 1C 76 98         .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
0487   0590 22 95 B3 98         .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
0488   0594 0A DD 47 98         .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
0489   0598 53 D1 99 99         .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
0490   059C 0A 1A 9F 98         .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
0491   05A0 65 BC CD 98         .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
0492   05A4 D6 77 3E 98         .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
0493   05A8 52 C7 4F 80         .BYTE   052H,0C7H,04FH,080H     ; Last random number
0494   05AC DB 00               IN      A,(0)           ; INP (x) skeleton
0495   05AE C9                  RET
0496   05AF 01                  .BYTE   1               ; POS (x) number (1)
0497   05B0 FF                  .BYTE   255             ; Terminal width (255 = no auto CRLF)
0498   05B1 1C                  .BYTE   28              ; Width for commas (3 columns)
0499   05B2 00                  .BYTE   0               ; No nulls after input bytes
0500   05B3 00                  .BYTE   0               ; Output enabled (^O off)
0501   05B4 14 00               .WORD   20              ; Initial lines counter
0502   05B6 14 00               .WORD   20              ; Initial lines number
0503   05B8 00 00               .WORD   0               ; Array load/save check sum
0504   05BA 00                  .BYTE   0               ; Break not by NMI
0505   05BB 00                  .BYTE   0               ; Break flag
0506   05BC C3 82 08            JP      TTYLIN          ; Input reflection (set to TTY)
0507   05BF C3 00 00            JP      $0000           ; POINT reflection unused
0508   05C2 C3 00 00            JP      $0000           ; SET reflection
0509   05C5 C3 00 00            JP      $0000          	; RESET reflection
0510   05C8 7D 22               .WORD   STLOOK          ; Temp string space
0511   05CA FE FF               .WORD   -2              ; Current line number (cold)
0512   05CC 1A 22               .WORD   PROGST+1        ; Start of program text
0513   05CE             INITBE:                         
0514   05CE             
0515   05CE             ; END OF INITIALISATION TABLE ---------------------------------------------------
0516   05CE             
0517   05CE 204572726F72ERRMSG: .BYTE   " Error",0
0517   05D4 00
0518   05D5 20696E2000  INMSG:  .BYTE   " in ",0
0519   05DA             ZERBYT  .EQU    $-1             ; A zero byte
0520   05DA 4F6B0D0A0000OKMSG:  .BYTE   "Ok",CR,LF,0,0
0521   05E0 427265616B00BRKMSG: .BYTE   "Break",0
0522   05E6             
0523   05E6 21 04 00    BAKSTK: LD      HL,4            ; Look for "FOR" block with
0524   05E9 39                  ADD     HL,SP           ; same index as specified
0525   05EA 7E          LOKFOR: LD      A,(HL)          ; Get block ID
0526   05EB 23                  INC     HL              ; Point to index address
0527   05EC FE 81               CP      ZFOR            ; Is it a "FOR" token
0528   05EE C0                  RET     NZ              ; No - exit
0529   05EF 4E                  LD      C,(HL)          ; BC = Address of "FOR" index
0530   05F0 23                  INC     HL
0531   05F1 46                  LD      B,(HL)
0532   05F2 23                  INC     HL              ; Point to sign of STEP
0533   05F3 E5                  PUSH    HL              ; Save pointer to sign
0534   05F4 69                  LD      L,C             ; HL = address of "FOR" index
0535   05F5 60                  LD      H,B
0536   05F6 7A                  LD      A,D             ; See if an index was specified
0537   05F7 B3                  OR      E               ; DE = 0 if no index specified
0538   05F8 EB                  EX      DE,HL           ; Specified index into HL
0539   05F9 CA 00 06            JP      Z,INDFND        ; Skip if no index given
0540   05FC EB                  EX      DE,HL           ; Index back into DE
0541   05FD CD 05 09            CALL    CPDEHL          ; Compare index with one given
0542   0600 01 0D 00    INDFND: LD      BC,16-3         ; Offset to next block
0543   0603 E1                  POP     HL              ; Restore pointer to sign
0544   0604 C8                  RET     Z               ; Return if block found
0545   0605 09                  ADD     HL,BC           ; Point to next block
0546   0606 C3 EA 05            JP      LOKFOR          ; Keep on looking
0547   0609             
0548   0609 CD 23 06    MOVUP:  CALL    ENFMEM          ; See if enough memory
0549   060C C5          MOVSTR: PUSH    BC              ; Save end of source
0550   060D E3                  EX      (SP),HL         ; Swap source and dest" end
0551   060E C1                  POP     BC              ; Get end of destination
0552   060F CD 05 09    MOVLP:  CALL    CPDEHL          ; See if list moved
0553   0612 7E                  LD      A,(HL)          ; Get byte
0554   0613 02                  LD      (BC),A          ; Move it
0555   0614 C8                  RET     Z               ; Exit if all done
0556   0615 0B                  DEC     BC              ; Next byte to move to
0557   0616 2B                  DEC     HL              ; Next byte to move
0558   0617 C3 0F 06            JP      MOVLP           ; Loop until all bytes moved
0559   061A             
0560   061A E5          CHKSTK: PUSH    HL              ; Save code string address
0561   061B 2A FA 21            LD      HL,(ARREND)     ; Lowest free memory
0562   061E 06 00               LD      B,0             ; BC = Number of levels to test
0563   0620 09                  ADD     HL,BC           ; 2 Bytes for each level
0564   0621 09                  ADD     HL,BC
0565   0622 3E                  .BYTE   3EH             ; Skip "PUSH HL"
0566   0623 E5          ENFMEM: PUSH    HL              ; Save code string address
0567   0624 3E D0               LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
0568   0626 95                  SUB     L
0569   0627 6F                  LD      L,A
0570   0628 3E FF               LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
0571   062A 9C                  SBC     A,H
0572   062B DA 32 06            JP      C,OMERR         ; Not enough - ?OM Error
0573   062E 67                  LD      H,A
0574   062F 39                  ADD     HL,SP           ; Test if stack is overflowed
0575   0630 E1                  POP     HL              ; Restore code string address
0576   0631 D8                  RET     C               ; Return if enough mmory
0577   0632 1E 0C       OMERR:  LD      E,OM            ; ?OM Error
0578   0634 C3 51 06            JP      ERROR
0579   0637             
0580   0637 2A E9 21    DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
0581   063A 22 7C 21            LD      (LINEAT),HL     ; Save as current line
0582   063D 1E 02       SNERR:  LD      E,SN            ; ?SN Error
0583   063F 01                  .BYTE   01H             ; Skip "LD E,DZ"
0584   0640 1E 14       DZERR:  LD      E,DZ            ; ?/0 Error
0585   0642 01                  .BYTE   01H             ; Skip "LD E,NF"
0586   0643 1E 00       NFERR:  LD      E,NF            ; ?NF Error
0587   0645 01                  .BYTE   01H             ; Skip "LD E,DD"
0588   0646 1E 12       DDERR:  LD      E,DD            ; ?DD Error
0589   0648 01                  .BYTE   01H             ; Skip "LD E,UF"
0590   0649 1E 22       UFERR:  LD      E,UF            ; ?UF Error
0591   064B 01                  .BYTE   01H             ; Skip "LD E,OV
0592   064C 1E 0A       OVERR:  LD      E,OV            ; ?OV Error
0593   064E 01                  .BYTE   01H             ; Skip "LD E,TM"
0594   064F 1E 18       TMERR:  LD      E,TM            ; ?TM Error
0595   0651             
0596   0651 CD 6F 07    ERROR:  CALL    CLREG           ; Clear registers and stack
0597   0654 32 65 21            LD      (CTLOFG),A      ; Enable output (A is 0)
0598   0657 CD 30 0D            CALL    STTLIN          ; Start new line
0599   065A 21 44 05            LD      HL,ERRORS       ; Point to error codes
0600   065D 57                  LD      D,A             ; D = 0 (A is 0)
0601   065E 3E 3F               LD      A,'?'
0602   0660 CD 16 09            CALL    OUTC            ; Output '?'
0603   0663 19                  ADD     HL,DE           ; Offset to correct error code
0604   0664 7E                  LD      A,(HL)          ; First character
0605   0665 CD 16 09            CALL    OUTC            ; Output it
0606   0668 CD 95 0A            CALL    GETCHR          ; Get next character
0607   066B CD 16 09            CALL    OUTC            ; Output it
0608   066E 21 CE 05            LD      HL,ERRMSG       ; "Error" message
0609   0671 CD DB 13    ERRIN:  CALL    PRS             ; Output message
0610   0674 2A 7C 21            LD      HL,(LINEAT)     ; Get line of error
0611   0677 11 FE FF            LD      DE,-2           ; Cold start error if -2
0612   067A CD 05 09            CALL    CPDEHL          ; See if cold start error
0613   067D CA A1 02            JP      Z,CSTART        ; Cold start error - Restart
0614   0680 7C                  LD      A,H             ; Was it a direct error?
0615   0681 A5                  AND     L               ; Line = -1 if direct error
0616   0682 3C                  INC     A
0617   0683 C4 76 1A            CALL    NZ,LINEIN       ; No - output line of error
0618   0686 3E                  .BYTE   3EH             ; Skip "POP BC"
0619   0687 C1          POPNOK: POP     BC              ; Drop address in input buffer
0620   0688             
0621   0688 AF          PRNTOK: XOR     A               ; Output "Ok" and get command
0622   0689 32 65 21            LD      (CTLOFG),A      ; Enable output
0623   068C CD 30 0D            CALL    STTLIN          ; Start new line
0624   068F 21 DA 05            LD      HL,OKMSG        ; "Ok" message
0625   0692 CD DB 13            CALL    PRS             ; Output "Ok"
0626   0695 21 FF FF    GETCMD: LD      HL,-1           ; Flag direct mode
0627   0698 22 7C 21            LD      (LINEAT),HL     ; Save as current line
0628   069B CD 82 08            CALL    GETLIN          ; Get an input line
0629   069E DA 95 06            JP      C,GETCMD        ; Get line again if break
0630   06A1 CD 95 0A            CALL    GETCHR          ; Get first character
0631   06A4 3C                  INC     A               ; Test if end of line
0632   06A5 3D                  DEC     A               ; Without affecting Carry
0633   06A6 CA 95 06            JP      Z,GETCMD        ; Nothing entered - Get another
0634   06A9 F5                  PUSH    AF              ; Save Carry status
0635   06AA CD 61 0B            CALL    ATOH            ; Get line number into DE
0636   06AD D5                  PUSH    DE              ; Save line number
0637   06AE CD 99 07            CALL    CRUNCH          ; Tokenise rest of line
0638   06B1 47                  LD      B,A             ; Length of tokenised line
0639   06B2 D1                  POP     DE              ; Restore line number
0640   06B3 F1                  POP     AF              ; Restore Carry
0641   06B4 D2 75 0A            JP      NC,EXCUTE       ; No line number - Direct mode
0642   06B7 D5                  PUSH    DE              ; Save line number
0643   06B8 C5                  PUSH    BC              ; Save length of tokenised line
0644   06B9 AF                  XOR     A
0645   06BA 32 EC 21            LD      (LSTBIN),A      ; Clear last byte input
0646   06BD CD 95 0A            CALL    GETCHR          ; Get next character
0647   06C0 B7                  OR      A               ; Set flags
0648   06C1 F5                  PUSH    AF              ; And save them
0649   06C2 CD 29 07            CALL    SRCHLN          ; Search for line number in DE
0650   06C5 DA CE 06            JP      C,LINFND        ; Jump if line found
0651   06C8 F1                  POP     AF              ; Get status
0652   06C9 F5                  PUSH    AF              ; And re-save
0653   06CA CA 02 0C            JP      Z,ULERR         ; Nothing after number - Error
0654   06CD B7                  OR      A               ; Clear Carry
0655   06CE C5          LINFND: PUSH    BC              ; Save address of line in prog
0656   06CF D2 E5 06            JP      NC,INEWLN       ; Line not found - Insert new
0657   06D2 EB                  EX      DE,HL           ; Next line address in DE
0658   06D3 2A F6 21            LD      HL,(PROGND)     ; End of program
0659   06D6 1A          SFTPRG: LD      A,(DE)          ; Shift rest of program down
0660   06D7 02                  LD      (BC),A
0661   06D8 03                  INC     BC              ; Next destination
0662   06D9 13                  INC     DE              ; Next source
0663   06DA CD 05 09            CALL    CPDEHL          ; All done?
0664   06DD C2 D6 06            JP      NZ,SFTPRG       ; More to do
0665   06E0 60                  LD      H,B             ; HL - New end of program
0666   06E1 69                  LD      L,C
0667   06E2 22 F6 21            LD      (PROGND),HL     ; Update end of program
0668   06E5             
0669   06E5 D1          INEWLN: POP     DE              ; Get address of line,
0670   06E6 F1                  POP     AF              ; Get status
0671   06E7 CA 0C 07            JP      Z,SETPTR        ; No text - Set up pointers
0672   06EA 2A F6 21            LD      HL,(PROGND)     ; Get end of program
0673   06ED E3                  EX      (SP),HL         ; Get length of input line
0674   06EE C1                  POP     BC              ; End of program to BC
0675   06EF 09                  ADD     HL,BC           ; Find new end
0676   06F0 E5                  PUSH    HL              ; Save new end
0677   06F1 CD 09 06            CALL    MOVUP           ; Make space for line
0678   06F4 E1                  POP     HL              ; Restore new end
0679   06F5 22 F6 21            LD      (PROGND),HL     ; Update end of program pointer
0680   06F8 EB                  EX      DE,HL           ; Get line to move up in HL
0681   06F9 74                  LD      (HL),H          ; Save MSB
0682   06FA D1                  POP     DE              ; Get new line number
0683   06FB 23                  INC     HL              ; Skip pointer
0684   06FC 23                  INC     HL
0685   06FD 73                  LD      (HL),E          ; Save LSB of line number
0686   06FE 23                  INC     HL
0687   06FF 72                  LD      (HL),D          ; Save MSB of line number
0688   0700 23                  INC     HL              ; To first byte in line
0689   0701 11 81 21            LD      DE,BUFFER       ; Copy buffer to program
0690   0704 1A          MOVBUF: LD      A,(DE)          ; Get source
0691   0705 77                  LD      (HL),A          ; Save destinations
0692   0706 23                  INC     HL              ; Next source
0693   0707 13                  INC     DE              ; Next destination
0694   0708 B7                  OR      A               ; Done?
0695   0709 C2 04 07            JP      NZ,MOVBUF       ; No - Repeat
0696   070C CD 55 07    SETPTR: CALL    RUNFST          ; Set line pointers
0697   070F 23                  INC     HL              ; To LSB of pointer
0698   0710 EB                  EX      DE,HL           ; Address to DE
0699   0711 62          PTRLP:  LD      H,D             ; Address to HL
0700   0712 6B                  LD      L,E
0701   0713 7E                  LD      A,(HL)          ; Get LSB of pointer
0702   0714 23                  INC     HL              ; To MSB of pointer
0703   0715 B6                  OR      (HL)            ; Compare with MSB pointer
0704   0716 CA 95 06            JP      Z,GETCMD        ; Get command line if end
0705   0719 23                  INC     HL              ; To LSB of line number
0706   071A 23                  INC     HL              ; Skip line number
0707   071B 23                  INC     HL              ; Point to first byte in line
0708   071C AF                  XOR     A               ; Looking for 00 byte
0709   071D BE          FNDEND: CP      (HL)            ; Found end of line?
0710   071E 23                  INC     HL              ; Move to next byte
0711   071F C2 1D 07            JP      NZ,FNDEND       ; No - Keep looking
0712   0722 EB                  EX      DE,HL           ; Next line address to HL
0713   0723 73                  LD      (HL),E          ; Save LSB of pointer
0714   0724 23                  INC     HL
0715   0725 72                  LD      (HL),D          ; Save MSB of pointer
0716   0726 C3 11 07            JP      PTRLP           ; Do next line
0717   0729             
0718   0729 2A 7E 21    SRCHLN: LD      HL,(BASTXT)     ; Start of program text
0719   072C 44          SRCHLP: LD      B,H             ; BC = Address to look at
0720   072D 4D                  LD      C,L
0721   072E 7E                  LD      A,(HL)          ; Get address of next line
0722   072F 23                  INC     HL
0723   0730 B6                  OR      (HL)            ; End of program found?
0724   0731 2B                  DEC     HL
0725   0732 C8                  RET     Z               ; Yes - Line not found
0726   0733 23                  INC     HL
0727   0734 23                  INC     HL
0728   0735 7E                  LD      A,(HL)          ; Get LSB of line number
0729   0736 23                  INC     HL
0730   0737 66                  LD      H,(HL)          ; Get MSB of line number
0731   0738 6F                  LD      L,A
0732   0739 CD 05 09            CALL    CPDEHL          ; Compare with line in DE
0733   073C 60                  LD      H,B             ; HL = Start of this line
0734   073D 69                  LD      L,C
0735   073E 7E                  LD      A,(HL)          ; Get LSB of next line address
0736   073F 23                  INC     HL
0737   0740 66                  LD      H,(HL)          ; Get MSB of next line address
0738   0741 6F                  LD      L,A             ; Next line to HL
0739   0742 3F                  CCF
0740   0743 C8                  RET     Z               ; Lines found - Exit
0741   0744 3F                  CCF
0742   0745 D0                  RET     NC              ; Line not found,at line after
0743   0746 C3 2C 07            JP      SRCHLP          ; Keep looking
0744   0749             
0745   0749 C0          NEW:    RET     NZ              ; Return if any more on line
0746   074A 2A 7E 21    CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
0747   074D AF                  XOR     A               ; Set program area to empty
0748   074E 77                  LD      (HL),A          ; Save LSB = 00
0749   074F 23                  INC     HL
0750   0750 77                  LD      (HL),A          ; Save MSB = 00
0751   0751 23                  INC     HL
0752   0752 22 F6 21            LD      (PROGND),HL     ; Set program end
0753   0755             
0754   0755 2A 7E 21    RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0755   0758 2B                  DEC     HL
0756   0759             
0757   0759 22 EE 21    INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
0758   075C 2A CF 21            LD      HL,(LSTRAM)     ; Get end of RAM
0759   075F 22 E3 21            LD      (STRBOT),HL     ; Clear string space
0760   0762 AF                  XOR     A
0761   0763 CD A5 0A            CALL    RESTOR          ; Reset DATA pointers
0762   0766 2A F6 21            LD      HL,(PROGND)     ; Get end of program
0763   0769 22 F8 21            LD      (VAREND),HL     ; Clear variables
0764   076C 22 FA 21            LD      (ARREND),HL     ; Clear arrays
0765   076F             
0766   076F C1          CLREG:  POP     BC              ; Save return address
0767   0770 2A 7A 21            LD      HL,(STRSPC)     ; Get end of working RAN
0768   0773 F9                  LD      SP,HL           ; Set stack
0769   0774 21 D3 21            LD      HL,TMSTPL       ; Temporary string pool
0770   0777 22 D1 21            LD      (TMSTPT),HL     ; Reset temporary string ptr
0771   077A AF                  XOR     A               ; A = 00
0772   077B 6F                  LD      L,A             ; HL = 0000
0773   077C 67                  LD      H,A
0774   077D 22 F4 21            LD      (CONTAD),HL     ; No CONTinue
0775   0780 32 EB 21            LD      (FORFLG),A      ; Clear FOR flag
0776   0783 22 FE 21            LD      (FNRGNM),HL     ; Clear FN argument
0777   0786 E5                  PUSH    HL              ; HL = 0000
0778   0787 C5                  PUSH    BC              ; Put back return
0779   0788 2A EE 21    DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
0780   078B C9                  RET                     ; Return to execution driver
0781   078C             
0782   078C 3E 3F       PROMPT: LD      A,'?'           ; '?'
0783   078E CD 16 09            CALL    OUTC            ; Output character
0784   0791 3E 20               LD      A,' '           ; Space
0785   0793 CD 16 09            CALL    OUTC            ; Output character
0786   0796 C3 6E 21            JP      RINPUT          ; Get input line
0787   0799             
0788   0799 AF          CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
0789   079A 32 CE 21            LD      (DATFLG),A      ; Reset literal flag
0790   079D 0E 05               LD      C,2+3           ; 2 byte number and 3 nulls
0791   079F 11 81 21            LD      DE,BUFFER       ; Start of input buffer
0792   07A2 7E          CRNCLP: LD      A,(HL)          ; Get byte
0793   07A3 FE 20               CP      ' '             ; Is it a space?
0794   07A5 CA 21 08            JP      Z,MOVDIR        ; Yes - Copy direct
0795   07A8 47                  LD      B,A             ; Save character
0796   07A9 FE 22               CP      '"'             ; Is it a quote?
0797   07AB CA 41 08            JP      Z,CPYLIT        ; Yes - Copy literal string
0798   07AE B7                  OR      A               ; Is it end of buffer?
0799   07AF CA 48 08            JP      Z,ENDBUF        ; Yes - End buffer
0800   07B2 3A CE 21            LD      A,(DATFLG)      ; Get data type
0801   07B5 B7                  OR      A               ; Literal?
0802   07B6 7E                  LD      A,(HL)          ; Get byte to copy
0803   07B7 C2 21 08            JP      NZ,MOVDIR       ; Literal - Copy direct
0804   07BA FE 3F               CP      '?'             ; Is it '?' short for PRINT
0805   07BC 3E 9E               LD      A,ZPRINT        ; "PRINT" token
0806   07BE CA 21 08            JP      Z,MOVDIR        ; Yes - replace it
0807   07C1 7E                  LD      A,(HL)          ; Get byte again
0808   07C2 FE 30               CP      '0'             ; Is it less than '0'
0809   07C4 DA CC 07            JP      C,FNDWRD        ; Yes - Look for reserved words
0810   07C7 FE 3C               CP      60; ";"+1           ; Is it "0123456789:;" ?
0811   07C9 DA 21 08            JP      C,MOVDIR        ; Yes - copy it direct
0812   07CC D5          FNDWRD: PUSH    DE              ; Look for reserved words
0813   07CD 11 C5 03            LD      DE,WORDS-1      ; Point to table
0814   07D0 C5                  PUSH    BC              ; Save count
0815   07D1 01 1D 08            LD      BC,RETNAD       ; Where to return to
0816   07D4 C5                  PUSH    BC              ; Save return address
0817   07D5 06 7F               LD      B,ZEND-1        ; First token value -1
0818   07D7 7E                  LD      A,(HL)          ; Get byte
0819   07D8 FE 61               CP      'a'             ; Less than 'a' ?
0820   07DA DA E5 07            JP      C,SEARCH        ; Yes - search for words
0821   07DD FE 7B               CP      'z'+1           ; Greater than 'z' ?
0822   07DF D2 E5 07            JP      NC,SEARCH       ; Yes - search for words
0823   07E2 E6 5F               AND     01011111B       ; Force upper case
0824   07E4 77                  LD      (HL),A          ; Replace byte
0825   07E5 4E          SEARCH: LD      C,(HL)          ; Search for a word
0826   07E6 EB                  EX      DE,HL
0827   07E7 23          GETNXT: INC     HL              ; Get next reserved word
0828   07E8 B6                  OR      (HL)            ; Start of word?
0829   07E9 F2 E7 07            JP      P,GETNXT        ; No - move on
0830   07EC 04                  INC     B               ; Increment token value
0831   07ED 7E                  LD      A, (HL)         ; Get byte from table
0832   07EE E6 7F               AND     01111111B       ; Strip bit 7
0833   07F0 C8                  RET     Z               ; Return if end of list
0834   07F1 B9                  CP      C               ; Same character as in buffer?
0835   07F2 C2 E7 07            JP      NZ,GETNXT       ; No - get next word
0836   07F5 EB                  EX      DE,HL
0837   07F6 E5                  PUSH    HL              ; Save start of word
0838   07F7             
0839   07F7 13          NXTBYT: INC     DE              ; Look through rest of word
0840   07F8 1A                  LD      A,(DE)          ; Get byte from table
0841   07F9 B7                  OR      A               ; End of word ?
0842   07FA FA 19 08            JP      M,MATCH         ; Yes - Match found
0843   07FD 4F                  LD      C,A             ; Save it
0844   07FE 78                  LD      A,B             ; Get token value
0845   07FF FE 88               CP      ZGOTO           ; Is it "GOTO" token ?
0846   0801 C2 08 08            JP      NZ,NOSPC        ; No - Don't allow spaces
0847   0804 CD 95 0A            CALL    GETCHR          ; Get next character
0848   0807 2B                  DEC     HL              ; Cancel increment from GETCHR
0849   0808 23          NOSPC:  INC     HL              ; Next byte
0850   0809 7E                  LD      A,(HL)          ; Get byte
0851   080A FE 61               CP      'a'             ; Less than 'a' ?
0852   080C DA 11 08            JP      C,NOCHNG        ; Yes - don't change
0853   080F E6 5F               AND     01011111B       ; Make upper case
0854   0811 B9          NOCHNG: CP      C               ; Same as in buffer ?
0855   0812 CA F7 07            JP      Z,NXTBYT        ; Yes - keep testing
0856   0815 E1                  POP     HL              ; Get back start of word
0857   0816 C3 E5 07            JP      SEARCH          ; Look at next word
0858   0819             
0859   0819 48          MATCH:  LD      C,B             ; Word found - Save token value
0860   081A F1                  POP     AF              ; Throw away return
0861   081B EB                  EX      DE,HL
0862   081C C9                  RET                     ; Return to "RETNAD"
0863   081D EB          RETNAD: EX      DE,HL           ; Get address in string
0864   081E 79                  LD      A,C             ; Get token value
0865   081F C1                  POP     BC              ; Restore buffer length
0866   0820 D1                  POP     DE              ; Get destination address
0867   0821 23          MOVDIR: INC     HL              ; Next source in buffer
0868   0822 12                  LD      (DE),A          ; Put byte in buffer
0869   0823 13                  INC     DE              ; Move up buffer
0870   0824 0C                  INC     C               ; Increment length of buffer
0871   0825 D6 3A               SUB     ':'             ; End of statement?
0872   0827 CA 2F 08            JP      Z,SETLIT        ; Jump if multi-statement line
0873   082A FE 49               CP      ZDATA-3AH       ; Is it DATA statement ?
0874   082C C2 32 08            JP      NZ,TSTREM       ; No - see if REM
0875   082F 32 CE 21    SETLIT: LD      (DATFLG),A      ; Set literal flag
0876   0832 D6 54       TSTREM: SUB     ZREM-3AH        ; Is it REM?
0877   0834 C2 A2 07            JP      NZ,CRNCLP       ; No - Leave flag
0878   0837 47                  LD      B,A             ; Copy rest of buffer
0879   0838 7E          NXTCHR: LD      A,(HL)          ; Get byte
0880   0839 B7                  OR      A               ; End of line ?
0881   083A CA 48 08            JP      Z,ENDBUF        ; Yes - Terminate buffer
0882   083D B8                  CP      B               ; End of statement ?
0883   083E CA 21 08            JP      Z,MOVDIR        ; Yes - Get next one
0884   0841 23          CPYLIT: INC     HL              ; Move up source string
0885   0842 12                  LD      (DE),A          ; Save in destination
0886   0843 0C                  INC     C               ; Increment length
0887   0844 13                  INC     DE              ; Move up destination
0888   0845 C3 38 08            JP      NXTCHR          ; Repeat
0889   0848             
0890   0848 21 80 21    ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
0891   084B 12                  LD      (DE),A          ; Mark end of buffer (A = 00)
0892   084C 13                  INC     DE
0893   084D 12                  LD      (DE),A          ; A = 00
0894   084E 13                  INC     DE
0895   084F 12                  LD      (DE),A          ; A = 00
0896   0850 C9                  RET
0897   0851             
0898   0851 3A 64 21    DODEL:  LD      A,(NULFLG)      ; Get null flag status
0899   0854 B7                  OR      A               ; Is it zero?
0900   0855 3E 00               LD      A,0             ; Zero A - Leave flags
0901   0857 32 64 21            LD      (NULFLG),A      ; Zero null flag
0902   085A C2 65 08            JP      NZ,ECHDEL       ; Set - Echo it
0903   085D 05                  DEC     B               ; Decrement length
0904   085E CA 82 08            JP      Z,GETLIN        ; Get line again if empty
0905   0861 CD 16 09            CALL    OUTC            ; Output null character
0906   0864 3E                  .BYTE   3EH             ; Skip "DEC B"
0907   0865 05          ECHDEL: DEC     B               ; Count bytes in buffer
0908   0866 2B                  DEC     HL              ; Back space buffer
0909   0867 CA 79 08            JP      Z,OTKLN         ; No buffer - Try again
0910   086A 7E                  LD      A,(HL)          ; Get deleted byte
0911   086B CD 16 09            CALL    OUTC            ; Echo it
0912   086E C3 8B 08            JP      MORINP          ; Get more input
0913   0871             
0914   0871 05          DELCHR: DEC     B               ; Count bytes in buffer
0915   0872 2B                  DEC     HL              ; Back space buffer
0916   0873 CD 16 09            CALL    OUTC            ; Output character in A
0917   0876 C2 8B 08            JP      NZ,MORINP       ; Not end - Get more
0918   0879 CD 16 09    OTKLN:  CALL    OUTC            ; Output character in A
0919   087C CD 3D 0D    KILIN:  CALL    PRNTCRLF        ; Output CRLF
0920   087F C3 82 08            JP      TTYLIN          ; Get line again
0921   0882             
0922   0882             GETLIN:
0923   0882 21 81 21    TTYLIN: LD      HL,BUFFER       ; Get a line by character
0924   0885 06 01               LD      B,1             ; Set buffer as empty
0925   0887 AF                  XOR     A
0926   0888 32 64 21            LD      (NULFLG),A      ; Clear null flag
0927   088B CD 40 09    MORINP: CALL    CLOTST          ; Get character and test ^O
0928   088E 4F                  LD      C,A             ; Save character in C
0929   088F FE 7F               CP      DEL             ; Delete character?
0930   0891 CA 51 08            JP      Z,DODEL         ; Yes - Process it
0931   0894 3A 64 21            LD      A,(NULFLG)      ; Get null flag
0932   0897 B7                  OR      A               ; Test null flag status
0933   0898 CA A4 08            JP      Z,PROCES        ; Reset - Process character
0934   089B 3E 00               LD      A,0             ; Set a null
0935   089D CD 16 09            CALL    OUTC            ; Output null
0936   08A0 AF                  XOR     A               ; Clear A
0937   08A1 32 64 21            LD      (NULFLG),A      ; Reset null flag
0938   08A4 79          PROCES: LD      A,C             ; Get character
0939   08A5 FE 07               CP      CTRLG           ; Bell?
0940   08A7 CA E8 08            JP      Z,PUTCTL        ; Yes - Save it
0941   08AA FE 03               CP      CTRLC           ; Is it control "C"?
0942   08AC CC 3D 0D            CALL    Z,PRNTCRLF      ; Yes - Output CRLF
0943   08AF 37                  SCF                     ; Flag break
0944   08B0 C8                  RET     Z               ; Return if control "C"
0945   08B1 FE 0D               CP      CR              ; Is it enter?
0946   08B3 CA 38 0D            JP      Z,ENDINP        ; Yes - Terminate input
0947   08B6 FE 15               CP      CTRLU           ; Is it control "U"?
0948   08B8 CA 7C 08            JP      Z,KILIN         ; Yes - Get another line
0949   08BB FE 40               CP      '@'             ; Is it "kill line"?
0950   08BD CA 79 08            JP      Z,OTKLN         ; Yes - Kill line
0951   08C0 FE 5F               CP      '_'             ; Is it delete?
0952   08C2 CA 71 08            JP      Z,DELCHR        ; Yes - Delete character
0953   08C5 FE 08               CP      BKSP            ; Is it backspace?
0954   08C7 CA 71 08            JP      Z,DELCHR        ; Yes - Delete character
0955   08CA FE 12               CP      CTRLR           ; Is it control "R"?
0956   08CC C2 E3 08            JP      NZ,PUTBUF       ; No - Put in buffer
0957   08CF C5                  PUSH    BC              ; Save buffer length
0958   08D0 D5                  PUSH    DE              ; Save DE
0959   08D1 E5                  PUSH    HL              ; Save buffer address
0960   08D2 36 00               LD      (HL),0          ; Mark end of buffer
0961   08D4 CD ED 1E            CALL    OUTNCR          ; Output and do CRLF
0962   08D7 21 81 21            LD      HL,BUFFER       ; Point to buffer start
0963   08DA CD DB 13            CALL    PRS             ; Output buffer
0964   08DD E1                  POP     HL              ; Restore buffer address
0965   08DE D1                  POP     DE              ; Restore DE
0966   08DF C1                  POP     BC              ; Restore buffer length
0967   08E0 C3 8B 08            JP      MORINP          ; Get another character
0968   08E3             
0969   08E3 FE 20       PUTBUF: CP      ' '             ; Is it a control code?
0970   08E5 DA 8B 08            JP      C,MORINP        ; Yes - Ignore
0971   08E8 78          PUTCTL: LD      A,B             ; Get number of bytes in buffer
0972   08E9 FE 49               CP      72+1            ; Test for line overflow
0973   08EB 3E 07               LD      A,CTRLG         ; Set a bell
0974   08ED D2 FD 08            JP      NC,OUTNBS       ; Ring bell if buffer full
0975   08F0 79                  LD      A,C             ; Get character
0976   08F1 71                  LD      (HL),C          ; Save in buffer
0977   08F2 32 EC 21            LD      (LSTBIN),A      ; Save last input byte
0978   08F5 23                  INC     HL              ; Move up buffer
0979   08F6 04                  INC     B               ; Increment length
0980   08F7 CD 16 09    OUTIT:  CALL    OUTC            ; Output the character entered
0981   08FA C3 8B 08            JP      MORINP          ; Get another character
0982   08FD             
0983   08FD CD 16 09    OUTNBS: CALL    OUTC            ; Output bell and back over it
0984   0900 3E 08               LD      A,BKSP          ; Set back space
0985   0902 C3 F7 08            JP      OUTIT           ; Output it and get more
0986   0905             
0987   0905 7C          CPDEHL: LD      A,H             ; Get H
0988   0906 92                  SUB     D               ; Compare with D
0989   0907 C0                  RET     NZ              ; Different - Exit
0990   0908 7D                  LD      A,L             ; Get L
0991   0909 93                  SUB     E               ; Compare with E
0992   090A C9                  RET                     ; Return status
0993   090B             
0994   090B 7E          CHKSYN: LD      A,(HL)          ; Check syntax of character
0995   090C E3                  EX      (SP),HL         ; Address of test byte
0996   090D BE                  CP      (HL)            ; Same as in code string?
0997   090E 23                  INC     HL              ; Return address
0998   090F E3                  EX      (SP),HL         ; Put it back
0999   0910 CA 95 0A            JP      Z,GETCHR        ; Yes - Get next character
1000   0913 C3 3D 06            JP      SNERR           ; Different - ?SN Error
1001   0916             
1002   0916 F5          OUTC:   PUSH    AF              ; Save character
1003   0917 3A 65 21            LD      A,(CTLOFG)      ; Get control "O" flag
1004   091A B7                  OR      A               ; Is it set?
1005   091B C2 10 14            JP      NZ,POPAF        ; Yes - don't output
1006   091E F1                  POP     AF              ; Restore character
1007   091F C5                  PUSH    BC              ; Save buffer length
1008   0920 F5                  PUSH    AF              ; Save character
1009   0921 FE 20               CP      ' '             ; Is it a control code?
1010   0923 DA 3A 09            JP      C,DINPOS        ; Yes - Don't INC POS(X)
1011   0926 3A 62 21            LD      A,(LWIDTH)      ; Get line width
1012   0929 47                  LD      B,A             ; To B
1013   092A 3A CB 21            LD      A,(CURPOS)      ; Get cursor position
1014   092D 04                  INC     B               ; Width 255?
1015   092E CA 36 09            JP      Z,INCLEN        ; Yes - No width limit
1016   0931 05                  DEC     B               ; Restore width
1017   0932 B8                  CP      B               ; At end of line?
1018   0933 CC 3D 0D            CALL    Z,PRNTCRLF      ; Yes - output CRLF
1019   0936 3C          INCLEN: INC     A               ; Move on one character
1020   0937 32 CB 21            LD      (CURPOS),A      ; Save new position
1021   093A F1          DINPOS: POP     AF              ; Restore character
1022   093B C1                  POP     BC              ; Restore buffer length
1023   093C CD D6 1E            CALL    MONOUT          ; Send it
1024   093F C9                  RET
1025   0940             
1026   0940 CD 9A 1D    CLOTST: CALL    GETINP          ; Get input character
1027   0943 E6 7F               AND     01111111B       ; Strip bit 7
1028   0945 FE 0F               CP      CTRLO           ; Is it control "O"?
1029   0947 C0                  RET     NZ              ; No don't flip flag
1030   0948 3A 65 21            LD      A,(CTLOFG)      ; Get flag
1031   094B 2F                  CPL                     ; Flip it
1032   094C 32 65 21            LD      (CTLOFG),A      ; Put it back
1033   094F AF                  XOR     A               ; Null character
1034   0950 C9                  RET
1035   0951             
1036   0951 CD 61 0B    LIST:   CALL    ATOH            ; ASCII number to DE
1037   0954 C0                  RET     NZ              ; Return if anything extra
1038   0955 C1                  POP     BC              ; Rubbish - Not needed
1039   0956 CD 29 07            CALL    SRCHLN          ; Search for line number in DE
1040   0959 C5                  PUSH    BC              ; Save address of line
1041   095A CD A7 09            CALL    SETLIN          ; Set up lines counter
1042   095D E1          LISTLP: POP     HL              ; Restore address of line
1043   095E 4E                  LD      C,(HL)          ; Get LSB of next line
1044   095F 23                  INC     HL
1045   0960 46                  LD      B,(HL)          ; Get MSB of next line
1046   0961 23                  INC     HL
1047   0962 78                  LD      A,B             ; BC = 0 (End of program)?
1048   0963 B1                  OR      C
1049   0964 CA 88 06            JP      Z,PRNTOK        ; Yes - Go to command mode
1050   0967 CD B0 09            CALL    COUNT           ; Count lines
1051   096A CD C0 0A            CALL    TSTBRK          ; Test for break key
1052   096D C5                  PUSH    BC              ; Save address of next line
1053   096E CD 3D 0D            CALL    PRNTCRLF        ; Output CRLF
1054   0971 5E                  LD      E,(HL)          ; Get LSB of line number
1055   0972 23                  INC     HL
1056   0973 56                  LD      D,(HL)          ; Get MSB of line number
1057   0974 23                  INC     HL
1058   0975 E5                  PUSH    HL              ; Save address of line start
1059   0976 EB                  EX      DE,HL           ; Line number to HL
1060   0977 CD 7E 1A            CALL    PRNTHL          ; Output line number in decimal
1061   097A 3E 20               LD      A,' '           ; Space after line number
1062   097C E1                  POP     HL              ; Restore start of line address
1063   097D CD 16 09    LSTLP2: CALL    OUTC            ; Output character in A
1064   0980 7E          LSTLP3: LD      A,(HL)          ; Get next byte in line
1065   0981 B7                  OR      A               ; End of line?
1066   0982 23                  INC     HL              ; To next byte in line
1067   0983 CA 5D 09            JP      Z,LISTLP        ; Yes - get next line
1068   0986 F2 7D 09            JP      P,LSTLP2        ; No token - output it
1069   0989 D6 7F               SUB     ZEND-1          ; Find and output word
1070   098B 4F                  LD      C,A             ; Token offset+1 to C
1071   098C 11 C6 03            LD      DE,WORDS        ; Reserved word list
1072   098F 1A          FNDTOK: LD      A,(DE)          ; Get character in list
1073   0990 13                  INC     DE              ; Move on to next
1074   0991 B7                  OR      A               ; Is it start of word?
1075   0992 F2 8F 09            JP      P,FNDTOK        ; No - Keep looking for word
1076   0995 0D                  DEC     C               ; Count words
1077   0996 C2 8F 09            JP      NZ,FNDTOK       ; Not there - keep looking
1078   0999 E6 7F       OUTWRD: AND     01111111B       ; Strip bit 7
1079   099B CD 16 09            CALL    OUTC            ; Output first character
1080   099E 1A                  LD      A,(DE)          ; Get next character
1081   099F 13                  INC     DE              ; Move on to next
1082   09A0 B7                  OR      A               ; Is it end of word?
1083   09A1 F2 99 09            JP      P,OUTWRD        ; No - output the rest
1084   09A4 C3 80 09            JP      LSTLP3          ; Next byte in line
1085   09A7             
1086   09A7 E5          SETLIN: PUSH    HL              ; Set up LINES counter
1087   09A8 2A 68 21            LD      HL,(LINESN)     ; Get LINES number
1088   09AB 22 66 21            LD      (LINESC),HL     ; Save in LINES counter
1089   09AE E1                  POP     HL
1090   09AF C9                  RET
1091   09B0             
1092   09B0 E5          COUNT:  PUSH    HL              ; Save code string address
1093   09B1 D5                  PUSH    DE
1094   09B2 2A 66 21            LD      HL,(LINESC)     ; Get LINES counter
1095   09B5 11 FF FF            LD      DE,-1
1096   09B8 ED 5A               ADC     HL,DE           ; Decrement
1097   09BA 22 66 21            LD      (LINESC),HL     ; Put it back
1098   09BD D1                  POP     DE
1099   09BE E1                  POP     HL              ; Restore code string address
1100   09BF F0                  RET     P               ; Return if more lines to go
1101   09C0 E5                  PUSH    HL              ; Save code string address
1102   09C1 2A 68 21            LD      HL,(LINESN)     ; Get LINES number
1103   09C4 22 66 21            LD      (LINESC),HL     ; Reset LINES counter
1104   09C7 CD 9A 1D            CALL    GETINP          ; Get input character
1105   09CA FE 03               CP      CTRLC           ; Is it control "C"?
1106   09CC CA D3 09            JP      Z,RSLNBK        ; Yes - Reset LINES and break
1107   09CF E1                  POP     HL              ; Restore code string address
1108   09D0 C3 B0 09            JP      COUNT           ; Keep on counting
1109   09D3             
1110   09D3 2A 68 21    RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1111   09D6 22 66 21            LD      (LINESC),HL     ; Reset LINES counter
1112   09D9 C3 37 03            JP      BRKRET          ; Go and output "Break"
1113   09DC             
1114   09DC 3E 64       FOR:    LD      A,64H           ; Flag "FOR" assignment
1115   09DE 32 EB 21            LD      (FORFLG),A      ; Save "FOR" flag
1116   09E1 CD 43 0C            CALL    LET             ; Set up initial index
1117   09E4 C1                  POP     BC              ; Drop RETurn address
1118   09E5 E5                  PUSH    HL              ; Save code string address
1119   09E6 CD 2C 0C            CALL    DATA            ; Get next statement address
1120   09E9 22 E7 21            LD      (LOOPST),HL     ; Save it for start of loop
1121   09EC 21 02 00            LD      HL,2            ; Offset for "FOR" block
1122   09EF 39                  ADD     HL,SP           ; Point to it
1123   09F0 CD EA 05    FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1124   09F3 D1                  POP     DE              ; Get code string address
1125   09F4 C2 0C 0A            JP      NZ,FORFND       ; No nesting found
1126   09F7 09                  ADD     HL,BC           ; Move into "FOR" block
1127   09F8 D5                  PUSH    DE              ; Save code string address
1128   09F9 2B                  DEC     HL
1129   09FA 56                  LD      D,(HL)          ; Get MSB of loop statement
1130   09FB 2B                  DEC     HL
1131   09FC 5E                  LD      E,(HL)          ; Get LSB of loop statement
1132   09FD 23                  INC     HL
1133   09FE 23                  INC     HL
1134   09FF E5                  PUSH    HL              ; Save block address
1135   0A00 2A E7 21            LD      HL,(LOOPST)     ; Get address of loop statement
1136   0A03 CD 05 09            CALL    CPDEHL          ; Compare the FOR loops
1137   0A06 E1                  POP     HL              ; Restore block address
1138   0A07 C2 F0 09            JP      NZ,FORSLP       ; Different FORs - Find another
1139   0A0A D1                  POP     DE              ; Restore code string address
1140   0A0B F9                  LD      SP,HL           ; Remove all nested loops
1141   0A0C             
1142   0A0C EB          FORFND: EX      DE,HL           ; Code string address to HL
1143   0A0D 0E 08               LD      C,8
1144   0A0F CD 1A 06            CALL    CHKSTK          ; Check for 8 levels of stack
1145   0A12 E5                  PUSH    HL              ; Save code string address
1146   0A13 2A E7 21            LD      HL,(LOOPST)     ; Get first statement of loop
1147   0A16 E3                  EX      (SP),HL         ; Save and restore code string
1148   0A17 E5                  PUSH    HL              ; Re-save code string address
1149   0A18 2A 7C 21            LD      HL,(LINEAT)     ; Get current line number
1150   0A1B E3                  EX      (SP),HL         ; Save and restore code string
1151   0A1C CD 05 0F            CALL    TSTNUM          ; Make sure it's a number
1152   0A1F CD 0B 09            CALL    CHKSYN          ; Make sure "TO" is next
1153   0A22 A6                  .BYTE   ZTO          ; "TO" token
1154   0A23 CD 02 0F            CALL    GETNUM          ; Get "TO" expression value
1155   0A26 E5                  PUSH    HL              ; Save code string address
1156   0A27 CD 30 19            CALL    BCDEFP          ; Move "TO" value to BCDE
1157   0A2A E1                  POP     HL              ; Restore code string address
1158   0A2B C5                  PUSH    BC              ; Save "TO" value in block
1159   0A2C D5                  PUSH    DE
1160   0A2D 01 00 81            LD      BC,8100H        ; BCDE - 1 (default STEP)
1161   0A30 51                  LD      D,C             ; C=0
1162   0A31 5A                  LD      E,D             ; D=0
1163   0A32 7E                  LD      A,(HL)          ; Get next byte in code string
1164   0A33 FE AB               CP      ZSTEP           ; See if "STEP" is stated
1165   0A35 3E 01               LD      A,1             ; Sign of step = 1
1166   0A37 C2 48 0A            JP      NZ,SAVSTP       ; No STEP given - Default to 1
1167   0A3A CD 95 0A            CALL    GETCHR          ; Jump over "STEP" token
1168   0A3D CD 02 0F            CALL    GETNUM          ; Get step value
1169   0A40 E5                  PUSH    HL              ; Save code string address
1170   0A41 CD 30 19            CALL    BCDEFP          ; Move STEP to BCDE
1171   0A44 CD E4 18            CALL    TSTSGN          ; Test sign of FPREG
1172   0A47 E1                  POP     HL              ; Restore code string address
1173   0A48 C5          SAVSTP: PUSH    BC              ; Save the STEP value in block
1174   0A49 D5                  PUSH    DE
1175   0A4A F5                  PUSH    AF              ; Save sign of STEP
1176   0A4B 33                  INC     SP              ; Don't save flags
1177   0A4C E5                  PUSH    HL              ; Save code string address
1178   0A4D 2A EE 21            LD      HL,(BRKLIN)     ; Get address of index variable
1179   0A50 E3                  EX      (SP),HL         ; Save and restore code string
1180   0A51 06 81       PUTFID: LD      B,ZFOR          ; "FOR" block marker
1181   0A53 C5                  PUSH    BC              ; Save it
1182   0A54 33                  INC     SP              ; Don't save C
1183   0A55             
1184   0A55 CD C0 0A    RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1185   0A58 22 EE 21            LD      (BRKLIN),HL     ; Save code address for break
1186   0A5B 7E                  LD      A,(HL)          ; Get next byte in code string
1187   0A5C FE 3A               CP      ':'             ; Multi statement line?
1188   0A5E CA 75 0A            JP      Z,EXCUTE        ; Yes - Execute it
1189   0A61 B7                  OR      A               ; End of line?
1190   0A62 C2 3D 06            JP      NZ,SNERR        ; No - Syntax error
1191   0A65 23                  INC     HL              ; Point to address of next line
1192   0A66 7E                  LD      A,(HL)          ; Get LSB of line pointer
1193   0A67 23                  INC     HL
1194   0A68 B6                  OR      (HL)            ; Is it zero (End of prog)?
1195   0A69 CA E7 0A            JP      Z,ENDPRG        ; Yes - Terminate execution
1196   0A6C 23                  INC     HL              ; Point to line number
1197   0A6D 5E                  LD      E,(HL)          ; Get LSB of line number
1198   0A6E 23                  INC     HL
1199   0A6F 56                  LD      D,(HL)          ; Get MSB of line number
1200   0A70 EB                  EX      DE,HL           ; Line number to HL
1201   0A71 22 7C 21            LD      (LINEAT),HL     ; Save as current line number
1202   0A74 EB                  EX      DE,HL           ; Line number back to DE
1203   0A75 CD 95 0A    EXCUTE: CALL    GETCHR          ; Get key word
1204   0A78 11 55 0A            LD      DE,RUNCNT       ; Where to RETurn to
1205   0A7B D5                  PUSH    DE              ; Save for RETurn
1206   0A7C C8          IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1207   0A7D D6 80       ONJMP:  SUB     ZEND            ; Is it a token?
1208   0A7F DA 43 0C            JP      C,LET           ; No - try to assign it
1209   0A82 FE 25               CP      ZNEW+1-ZEND     ; END to NEW ?
1210   0A84 D2 3D 06            JP      NC,SNERR        ; Not a key word - ?SN Error
1211   0A87 07                  RLCA                    ; Double it
1212   0A88 4F                  LD      C,A             ; BC = Offset into table
1213   0A89 06 00               LD      B,0
1214   0A8B EB                  EX      DE,HL           ; Save code string address
1215   0A8C 21 E5 04            LD      HL,WORDTB       ; Keyword address table
1216   0A8F 09                  ADD     HL,BC           ; Point to routine address
1217   0A90 4E                  LD      C,(HL)          ; Get LSB of routine address
1218   0A91 23                  INC     HL
1219   0A92 46                  LD      B,(HL)          ; Get MSB of routine address
1220   0A93 C5                  PUSH    BC              ; Save routine address
1221   0A94 EB                  EX      DE,HL           ; Restore code string address
1222   0A95             
1223   0A95 23          GETCHR: INC     HL              ; Point to next character
1224   0A96 7E                  LD      A,(HL)          ; Get next code string byte
1225   0A97 FE 3A               CP      ':'             ; Z if ':'
1226   0A99 D0                  RET     NC              ; NC if > "9"
1227   0A9A FE 20               CP      ' '
1228   0A9C CA 95 0A            JP      Z,GETCHR        ; Skip over spaces
1229   0A9F FE 30               CP      '0'
1230   0AA1 3F                  CCF                     ; NC if < '0'
1231   0AA2 3C                  INC     A               ; Test for zero - Leave carry
1232   0AA3 3D                  DEC     A               ; Z if Null
1233   0AA4 C9                  RET
1234   0AA5             
1235   0AA5 EB          RESTOR: EX      DE,HL           ; Save code string address
1236   0AA6 2A 7E 21            LD      HL,(BASTXT)     ; Point to start of program
1237   0AA9 CA BA 0A            JP      Z,RESTNL        ; Just RESTORE - reset pointer
1238   0AAC EB                  EX      DE,HL           ; Restore code string address
1239   0AAD CD 61 0B            CALL    ATOH            ; Get line number to DE
1240   0AB0 E5                  PUSH    HL              ; Save code string address
1241   0AB1 CD 29 07            CALL    SRCHLN          ; Search for line number in DE
1242   0AB4 60                  LD      H,B             ; HL = Address of line
1243   0AB5 69                  LD      L,C
1244   0AB6 D1                  POP     DE              ; Restore code string address
1245   0AB7 D2 02 0C            JP      NC,ULERR        ; ?UL Error if not found
1246   0ABA 2B          RESTNL: DEC     HL              ; Byte before DATA statement
1247   0ABB 22 FC 21    UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1248   0ABE EB                  EX      DE,HL           ; Restore code string address
1249   0ABF C9                  RET
1250   0AC0             
1251   0AC0             
1252   0AC0 DF          TSTBRK: RST     18H             ; Check input status
1253   0AC1 C8                  RET     Z               ; No key, go back
1254   0AC2 D7                  RST     10H             ; Get the key into A
1255   0AC3 FE 1B               CP      ESC             ; Escape key?
1256   0AC5 28 11               JR      Z,BRK           ; Yes, break
1257   0AC7 FE 03               CP      CTRLC           ; <Ctrl-C>
1258   0AC9 28 0D               JR      Z,BRK           ; Yes, break
1259   0ACB FE 13               CP      CTRLS           ; Stop scrolling?
1260   0ACD C0                  RET     NZ              ; Other key, ignore
1261   0ACE             
1262   0ACE             
1263   0ACE D7          STALL:  RST     10H             ; Wait for key
1264   0ACF FE 11               CP      CTRLQ           ; Resume scrolling?
1265   0AD1 C8                  RET      Z              ; Release the chokehold
1266   0AD2 FE 03               CP      CTRLC           ; Second break?
1267   0AD4 28 07               JR      Z,STOP          ; Break during hold exits prog
1268   0AD6 18 F6               JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1269   0AD8             
1270   0AD8 3E FF       BRK     LD      A,$FF           ; Set BRKFLG
1271   0ADA 32 6D 21            LD      (BRKFLG),A      ; Store it
1272   0ADD             
1273   0ADD             
1274   0ADD C0          STOP:   RET     NZ              ; Exit if anything else
1275   0ADE F6                  .BYTE   0F6H            ; Flag "STOP"
1276   0ADF C0          PEND:   RET     NZ              ; Exit if anything else
1277   0AE0 22 EE 21            LD      (BRKLIN),HL     ; Save point of break
1278   0AE3 21                  .BYTE   21H             ; Skip "OR 11111111B"
1279   0AE4 F6 FF       INPBRK: OR      11111111B       ; Flag "Break" wanted
1280   0AE6 C1                  POP     BC              ; Return not needed and more
1281   0AE7 2A 7C 21    ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1282   0AEA F5                  PUSH    AF              ; Save STOP / END status
1283   0AEB 7D                  LD      A,L             ; Is it direct break?
1284   0AEC A4                  AND     H
1285   0AED 3C                  INC     A               ; Line is -1 if direct break
1286   0AEE CA FA 0A            JP      Z,NOLIN         ; Yes - No line number
1287   0AF1 22 F2 21            LD      (ERRLIN),HL     ; Save line of break
1288   0AF4 2A EE 21            LD      HL,(BRKLIN)     ; Get point of break
1289   0AF7 22 F4 21            LD      (CONTAD),HL     ; Save point to CONTinue
1290   0AFA AF          NOLIN:  XOR     A
1291   0AFB 32 65 21            LD      (CTLOFG),A      ; Enable output
1292   0AFE CD 30 0D            CALL    STTLIN          ; Start a new line
1293   0B01 F1                  POP     AF              ; Restore STOP / END status
1294   0B02 21 E0 05            LD      HL,BRKMSG       ; "Break" message
1295   0B05 C2 71 06            JP      NZ,ERRIN        ; "in line" wanted?
1296   0B08 C3 88 06            JP      PRNTOK          ; Go to command mode
1297   0B0B             
1298   0B0B 2A F4 21    CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1299   0B0E 7C                  LD      A,H             ; Is it zero?
1300   0B0F B5                  OR      L
1301   0B10 1E 20               LD      E,CN            ; ?CN Error
1302   0B12 CA 51 06            JP      Z,ERROR         ; Yes - output "?CN Error"
1303   0B15 EB                  EX      DE,HL           ; Save code string address
1304   0B16 2A F2 21            LD      HL,(ERRLIN)     ; Get line of last break
1305   0B19 22 7C 21            LD      (LINEAT),HL     ; Set up current line number
1306   0B1C EB                  EX      DE,HL           ; Restore code string address
1307   0B1D C9                  RET                     ; CONTinue where left off
1308   0B1E             
1309   0B1E CD 63 16    NULL:   CALL    GETINT          ; Get integer 0-255
1310   0B21 C0                  RET     NZ              ; Return if bad value
1311   0B22 32 61 21            LD      (NULLS),A       ; Set nulls number
1312   0B25 C9                  RET
1313   0B26             
1314   0B26             
1315   0B26 E5          ACCSUM: PUSH    HL              ; Save address in array
1316   0B27 2A 6A 21            LD      HL,(CHKSUM)     ; Get check sum
1317   0B2A 06 00               LD      B,0             ; BC - Value of byte
1318   0B2C 4F                  LD      C,A
1319   0B2D 09                  ADD     HL,BC           ; Add byte to check sum
1320   0B2E 22 6A 21            LD      (CHKSUM),HL     ; Re-save check sum
1321   0B31 E1                  POP     HL              ; Restore address in array
1322   0B32 C9                  RET
1323   0B33             
1324   0B33 7E          CHKLTR: LD      A,(HL)          ; Get byte
1325   0B34 FE 41               CP      'A'             ; < 'a' ?
1326   0B36 D8                  RET     C               ; Carry set if not letter
1327   0B37 FE 5B               CP      'Z'+1           ; > 'z' ?
1328   0B39 3F                  CCF
1329   0B3A C9                  RET                     ; Carry set if not letter
1330   0B3B             
1331   0B3B CD 95 0A    FPSINT: CALL    GETCHR          ; Get next character
1332   0B3E CD 02 0F    POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1333   0B41 CD E4 18    DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1334   0B44 FA 5C 0B            JP      M,FCERR         ; Negative - ?FC Error
1335   0B47 3A 07 22    DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1336   0B4A FE 90               CP      80H+16          ; Exponent in range (16 bits)?
1337   0B4C DA 8C 19            JP      C,FPINT         ; Yes - convert it
1338   0B4F 01 80 90            LD      BC,9080H        ; BCDE = -32768
1339   0B52 11 00 00            LD      DE,0000
1340   0B55 E5                  PUSH    HL              ; Save code string address
1341   0B56 CD 5F 19            CALL    CMPNUM          ; Compare FPREG with BCDE
1342   0B59 E1                  POP     HL              ; Restore code string address
1343   0B5A 51                  LD      D,C             ; MSB to D
1344   0B5B C8                  RET     Z               ; Return if in range
1345   0B5C 1E 08       FCERR:  LD      E,FC            ; ?FC Error
1346   0B5E C3 51 06            JP      ERROR           ; Output error-
1347   0B61             
1348   0B61 2B          ATOH:   DEC     HL              ; ASCII number to DE binary
1349   0B62 11 00 00    GETLN:  LD      DE,0            ; Get number to DE
1350   0B65 CD 95 0A    GTLNLP: CALL    GETCHR          ; Get next character
1351   0B68 D0                  RET     NC              ; Exit if not a digit
1352   0B69 E5                  PUSH    HL              ; Save code string address
1353   0B6A F5                  PUSH    AF              ; Save digit
1354   0B6B 21 98 19            LD      HL,65529/10     ; Largest number 65529
1355   0B6E CD 05 09            CALL    CPDEHL          ; Number in range?
1356   0B71 DA 3D 06            JP      C,SNERR         ; No - ?SN Error
1357   0B74 62                  LD      H,D             ; HL = Number
1358   0B75 6B                  LD      L,E
1359   0B76 19                  ADD     HL,DE           ; Times 2
1360   0B77 29                  ADD     HL,HL           ; Times 4
1361   0B78 19                  ADD     HL,DE           ; Times 5
1362   0B79 29                  ADD     HL,HL           ; Times 10
1363   0B7A F1                  POP     AF              ; Restore digit
1364   0B7B D6 30               SUB     '0'             ; Make it 0 to 9
1365   0B7D 5F                  LD      E,A             ; DE = Value of digit
1366   0B7E 16 00               LD      D,0
1367   0B80 19                  ADD     HL,DE           ; Add to number
1368   0B81 EB                  EX      DE,HL           ; Number to DE
1369   0B82 E1                  POP     HL              ; Restore code string address
1370   0B83 C3 65 0B            JP      GTLNLP          ; Go to next character
1371   0B86             
1372   0B86 CA 59 07    CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1373   0B89 CD 3E 0B            CALL    POSINT          ; Get integer 0 to 32767 to DE
1374   0B8C 2B                  DEC     HL              ; Cancel increment
1375   0B8D CD 95 0A            CALL    GETCHR          ; Get next character
1376   0B90 E5                  PUSH    HL              ; Save code string address
1377   0B91 2A CF 21            LD      HL,(LSTRAM)     ; Get end of RAM
1378   0B94 CA A9 0B            JP      Z,STORED        ; No value given - Use stored
1379   0B97 E1                  POP     HL              ; Restore code string address
1380   0B98 CD 0B 09            CALL    CHKSYN          ; Check for comma
1381   0B9B 2C                  .BYTE      ','
1382   0B9C D5                  PUSH    DE              ; Save number
1383   0B9D CD 3E 0B            CALL    POSINT          ; Get integer 0 to 32767
1384   0BA0 2B                  DEC     HL              ; Cancel increment
1385   0BA1 CD 95 0A            CALL    GETCHR          ; Get next character
1386   0BA4 C2 3D 06            JP      NZ,SNERR        ; ?SN Error if more on line
1387   0BA7 E3                  EX      (SP),HL         ; Save code string address
1388   0BA8 EB                  EX      DE,HL           ; Number to DE
1389   0BA9 7D          STORED: LD      A,L             ; Get LSB of new RAM top
1390   0BAA 93                  SUB     E               ; Subtract LSB of string space
1391   0BAB 5F                  LD      E,A             ; Save LSB
1392   0BAC 7C                  LD      A,H             ; Get MSB of new RAM top
1393   0BAD 9A                  SBC     A,D             ; Subtract MSB of string space
1394   0BAE 57                  LD      D,A             ; Save MSB
1395   0BAF DA 32 06            JP      C,OMERR         ; ?OM Error if not enough mem
1396   0BB2 E5                  PUSH    HL              ; Save RAM top
1397   0BB3 2A F6 21            LD      HL,(PROGND)     ; Get program end
1398   0BB6 01 28 00            LD      BC,40           ; 40 Bytes minimum working RAM
1399   0BB9 09                  ADD     HL,BC           ; Get lowest address
1400   0BBA CD 05 09            CALL    CPDEHL          ; Enough memory?
1401   0BBD D2 32 06            JP      NC,OMERR        ; No - ?OM Error
1402   0BC0 EB                  EX      DE,HL           ; RAM top to HL
1403   0BC1 22 7A 21            LD      (STRSPC),HL     ; Set new string space
1404   0BC4 E1                  POP     HL              ; End of memory to use
1405   0BC5 22 CF 21            LD      (LSTRAM),HL     ; Set new top of RAM
1406   0BC8 E1                  POP     HL              ; Restore code string address
1407   0BC9 C3 59 07            JP      INTVAR          ; Initialise variables
1408   0BCC             
1409   0BCC CA 55 07    RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1410   0BCF CD 59 07            CALL    INTVAR          ; Initialise variables
1411   0BD2 01 55 0A            LD      BC,RUNCNT       ; Execution driver loop
1412   0BD5 C3 E8 0B            JP      RUNLIN          ; RUN from line number
1413   0BD8             
1414   0BD8 0E 03       GOSUB:  LD      C,3             ; 3 Levels of stack needed
1415   0BDA CD 1A 06            CALL    CHKSTK          ; Check for 3 levels of stack
1416   0BDD C1                  POP     BC              ; Get return address
1417   0BDE E5                  PUSH    HL              ; Save code string for RETURN
1418   0BDF E5                  PUSH    HL              ; And for GOSUB routine
1419   0BE0 2A 7C 21            LD      HL,(LINEAT)     ; Get current line
1420   0BE3 E3                  EX      (SP),HL         ; Into stack - Code string out
1421   0BE4 3E 8C               LD      A,ZGOSUB        ; "GOSUB" token
1422   0BE6 F5                  PUSH    AF              ; Save token
1423   0BE7 33                  INC     SP              ; Don't save flags
1424   0BE8             
1425   0BE8 C5          RUNLIN: PUSH    BC              ; Save return address
1426   0BE9 CD 61 0B    GOTO:   CALL    ATOH            ; ASCII number to DE binary
1427   0BEC CD 2E 0C            CALL    REM             ; Get end of line
1428   0BEF E5                  PUSH    HL              ; Save end of line
1429   0BF0 2A 7C 21            LD      HL,(LINEAT)     ; Get current line
1430   0BF3 CD 05 09            CALL    CPDEHL          ; Line after current?
1431   0BF6 E1                  POP     HL              ; Restore end of line
1432   0BF7 23                  INC     HL              ; Start of next line
1433   0BF8 DC 2C 07            CALL    C,SRCHLP        ; Line is after current line
1434   0BFB D4 29 07            CALL    NC,SRCHLN       ; Line is before current line
1435   0BFE 60                  LD      H,B             ; Set up code string address
1436   0BFF 69                  LD      L,C
1437   0C00 2B                  DEC     HL              ; Incremented after
1438   0C01 D8                  RET     C               ; Line found
1439   0C02 1E 0E       ULERR:  LD      E,UL            ; ?UL Error
1440   0C04 C3 51 06            JP      ERROR           ; Output error message
1441   0C07             
1442   0C07 C0          RETURN: RET     NZ              ; Return if not just RETURN
1443   0C08 16 FF               LD      D,-1            ; Flag "GOSUB" search
1444   0C0A CD E6 05            CALL    BAKSTK          ; Look "GOSUB" block
1445   0C0D F9                  LD      SP,HL           ; Kill all FORs in subroutine
1446   0C0E FE 8C               CP      ZGOSUB          ; Test for "GOSUB" token
1447   0C10 1E 04               LD      E,RG            ; ?RG Error
1448   0C12 C2 51 06            JP      NZ,ERROR        ; Error if no "GOSUB" found
1449   0C15 E1                  POP     HL              ; Get RETURN line number
1450   0C16 22 7C 21            LD      (LINEAT),HL     ; Save as current
1451   0C19 23                  INC     HL              ; Was it from direct statement?
1452   0C1A 7C                  LD      A,H
1453   0C1B B5                  OR      L               ; Return to line
1454   0C1C C2 26 0C            JP      NZ,RETLIN       ; No - Return to line
1455   0C1F 3A EC 21            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1456   0C22 B7                  OR      A               ; If so buffer is corrupted
1457   0C23 C2 87 06            JP      NZ,POPNOK       ; Yes - Go to command mode
1458   0C26 21 55 0A    RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1459   0C29 E3                  EX      (SP),HL         ; Into stack - Code string out
1460   0C2A 3E                  .BYTE      3EH             ; Skip "POP HL"
1461   0C2B E1          NXTDTA: POP     HL              ; Restore code string address
1462   0C2C             
1463   0C2C 01 3A       DATA:   .BYTE      01H,3AH         ; ':' End of statement
1464   0C2E 0E 00       REM:    LD      C,0             ; 00  End of statement
1465   0C30 06 00               LD      B,0
1466   0C32 79          NXTSTL: LD      A,C             ; Statement and byte
1467   0C33 48                  LD      C,B
1468   0C34 47                  LD      B,A             ; Statement end byte
1469   0C35 7E          NXTSTT: LD      A,(HL)          ; Get byte
1470   0C36 B7                  OR      A               ; End of line?
1471   0C37 C8                  RET     Z               ; Yes - Exit
1472   0C38 B8                  CP      B               ; End of statement?
1473   0C39 C8                  RET     Z               ; Yes - Exit
1474   0C3A 23                  INC     HL              ; Next byte
1475   0C3B FE 22               CP      '"'             ; Literal string?
1476   0C3D CA 32 0C            JP      Z,NXTSTL        ; Yes - Look for another '"'
1477   0C40 C3 35 0C            JP      NXTSTT          ; Keep looking
1478   0C43             
1479   0C43 CD F8 10    LET:    CALL    GETVAR          ; Get variable name
1480   0C46 CD 0B 09            CALL    CHKSYN          ; Make sure "=" follows
1481   0C49 B4                  .BYTE      ZEQUAL          ; "=" token
1482   0C4A D5                  PUSH    DE              ; Save address of variable
1483   0C4B 3A CD 21            LD      A,(TYPE)        ; Get data type
1484   0C4E F5                  PUSH    AF              ; Save type
1485   0C4F CD 14 0F            CALL    EVAL            ; Evaluate expression
1486   0C52 F1                  POP     AF              ; Restore type
1487   0C53 E3                  EX      (SP),HL         ; Save code - Get var addr
1488   0C54 22 EE 21            LD      (BRKLIN),HL     ; Save address of variable
1489   0C57 1F                  RRA                     ; Adjust type
1490   0C58 CD 07 0F            CALL    CHKTYP          ; Check types are the same
1491   0C5B CA 96 0C            JP      Z,LETNUM        ; Numeric - Move value
1492   0C5E E5          LETSTR: PUSH    HL              ; Save address of string var
1493   0C5F 2A 04 22            LD      HL,(FPREG)      ; Pointer to string entry
1494   0C62 E5                  PUSH    HL              ; Save it on stack
1495   0C63 23                  INC     HL              ; Skip over length
1496   0C64 23                  INC     HL
1497   0C65 5E                  LD      E,(HL)          ; LSB of string address
1498   0C66 23                  INC     HL
1499   0C67 56                  LD      D,(HL)          ; MSB of string address
1500   0C68 2A 7E 21            LD      HL,(BASTXT)     ; Point to start of program
1501   0C6B CD 05 09            CALL    CPDEHL          ; Is string before program?
1502   0C6E D2 85 0C            JP      NC,CRESTR       ; Yes - Create string entry
1503   0C71 2A 7A 21            LD      HL,(STRSPC)     ; Point to string space
1504   0C74 CD 05 09            CALL    CPDEHL          ; Is string literal in program?
1505   0C77 D1                  POP     DE              ; Restore address of string
1506   0C78 D2 8D 0C            JP      NC,MVSTPT       ; Yes - Set up pointer
1507   0C7B 21 DF 21            LD      HL,TMPSTR       ; Temporary string pool
1508   0C7E CD 05 09            CALL    CPDEHL          ; Is string in temporary pool?
1509   0C81 D2 8D 0C            JP      NC,MVSTPT       ; No - Set up pointer
1510   0C84 3E                  .BYTE   3EH             ; Skip "POP DE"
1511   0C85 D1          CRESTR: POP     DE              ; Restore address of string
1512   0C86 CD 3C 15            CALL    BAKTMP          ; Back to last tmp-str entry
1513   0C89 EB                  EX      DE,HL           ; Address of string entry
1514   0C8A CD 75 13            CALL    SAVSTR          ; Save string in string area
1515   0C8D CD 3C 15    MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1516   0C90 E1                  POP     HL              ; Get string pointer
1517   0C91 CD 3F 19            CALL    DETHL4          ; Move string pointer to var
1518   0C94 E1                  POP     HL              ; Restore code string address
1519   0C95 C9                  RET
1520   0C96             
1521   0C96 E5          LETNUM: PUSH    HL              ; Save address of variable
1522   0C97 CD 3C 19            CALL    FPTHL           ; Move value to variable
1523   0C9A D1                  POP     DE              ; Restore address of variable
1524   0C9B E1                  POP     HL              ; Restore code string address
1525   0C9C C9                  RET
1526   0C9D             
1527   0C9D CD 63 16    ON:     CALL    GETINT          ; Get integer 0-255
1528   0CA0 7E                  LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1529   0CA1 47                  LD      B,A             ; Save in B
1530   0CA2 FE 8C               CP      ZGOSUB          ; "GOSUB" token?
1531   0CA4 CA AC 0C            JP      Z,ONGO          ; Yes - Find line number
1532   0CA7 CD 0B 09            CALL    CHKSYN          ; Make sure it's "GOTO"
1533   0CAA 88                  .BYTE   ZGOTO           ; "GOTO" token
1534   0CAB 2B                  DEC     HL              ; Cancel increment
1535   0CAC 4B          ONGO:   LD      C,E             ; Integer of branch value
1536   0CAD 0D          ONGOLP: DEC     C               ; Count branches
1537   0CAE 78                  LD      A,B             ; Get "GOTO" or "GOSUB" token
1538   0CAF CA 7D 0A            JP      Z,ONJMP         ; Go to that line if right one
1539   0CB2 CD 62 0B            CALL    GETLN           ; Get line number to DE
1540   0CB5 FE 2C               CP      ','             ; Another line number?
1541   0CB7 C0                  RET     NZ              ; No - Drop through
1542   0CB8 C3 AD 0C            JP      ONGOLP          ; Yes - loop
1543   0CBB             
1544   0CBB CD 14 0F    IF:     CALL    EVAL            ; Evaluate expression
1545   0CBE 7E                  LD      A,(HL)          ; Get token
1546   0CBF FE 88               CP      ZGOTO           ; "GOTO" token?
1547   0CC1 CA C9 0C            JP      Z,IFGO          ; Yes - Get line
1548   0CC4 CD 0B 09            CALL    CHKSYN          ; Make sure it's "THEN"
1549   0CC7 A9                  .BYTE      ZTHEN           ; "THEN" token
1550   0CC8 2B                  DEC     HL              ; Cancel increment
1551   0CC9 CD 05 0F    IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1552   0CCC CD E4 18            CALL    TSTSGN          ; Test state of expression
1553   0CCF CA 2E 0C            JP      Z,REM           ; False - Drop through
1554   0CD2 CD 95 0A            CALL    GETCHR          ; Get next character
1555   0CD5 DA E9 0B            JP      C,GOTO          ; Number - GOTO that line
1556   0CD8 C3 7C 0A            JP      IFJMP           ; Otherwise do statement
1557   0CDB             
1558   0CDB 2B          MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1559   0CDC CD 95 0A            CALL    GETCHR          ; Get next character
1560   0CDF CA 3D 0D    PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1561   0CE2 C8          PRNTLP: RET     Z               ; End of list - Exit
1562   0CE3 FE A5               CP      ZTAB            ; "TAB(" token?
1563   0CE5 CA 70 0D            JP      Z,DOTAB         ; Yes - Do TAB routine
1564   0CE8 FE A8               CP      ZSPC            ; "SPC(" token?
1565   0CEA CA 70 0D            JP      Z,DOTAB         ; Yes - Do SPC routine
1566   0CED E5                  PUSH    HL              ; Save code string address
1567   0CEE FE 2C               CP      ','             ; Comma?
1568   0CF0 CA 59 0D            JP      Z,DOCOM         ; Yes - Move to next zone
1569   0CF3 FE 3B               CP      59 ;";"         ; Semi-colon?
1570   0CF5 CA 93 0D            JP      Z,NEXITM        ; Do semi-colon routine
1571   0CF8 C1                  POP     BC              ; Code string address to BC
1572   0CF9 CD 14 0F            CALL    EVAL            ; Evaluate expression
1573   0CFC E5                  PUSH    HL              ; Save code string address
1574   0CFD 3A CD 21            LD      A,(TYPE)        ; Get variable type
1575   0D00 B7                  OR      A               ; Is it a string variable?
1576   0D01 C2 29 0D            JP      NZ,PRNTST       ; Yes - Output string contents
1577   0D04 CD 89 1A            CALL    NUMASC          ; Convert number to text
1578   0D07 CD 99 13            CALL    CRTST           ; Create temporary string
1579   0D0A 36 20               LD      (HL),' '        ; Followed by a space
1580   0D0C 2A 04 22            LD      HL,(FPREG)      ; Get length of output
1581   0D0F 34                  INC     (HL)            ; Plus 1 for the space
1582   0D10 2A 04 22            LD      HL,(FPREG)      ; < Not needed >
1583   0D13 3A 62 21            LD      A,(LWIDTH)      ; Get width of line
1584   0D16 47                  LD      B,A             ; To B
1585   0D17 04                  INC     B               ; Width 255 (No limit)?
1586   0D18 CA 25 0D            JP      Z,PRNTNB        ; Yes - Output number string
1587   0D1B 04                  INC     B               ; Adjust it
1588   0D1C 3A CB 21            LD      A,(CURPOS)      ; Get cursor position
1589   0D1F 86                  ADD     A,(HL)          ; Add length of string
1590   0D20 3D                  DEC     A               ; Adjust it
1591   0D21 B8                  CP      B               ; Will output fit on this line?
1592   0D22 D4 3D 0D            CALL    NC,PRNTCRLF     ; No - CRLF first
1593   0D25 CD DE 13    PRNTNB: CALL    PRS1            ; Output string at (HL)
1594   0D28 AF                  XOR     A               ; Skip CALL by setting 'z' flag
1595   0D29 C4 DE 13    PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1596   0D2C E1                  POP     HL              ; Restore code string address
1597   0D2D C3 DB 0C            JP      MRPRNT          ; See if more to PRINT
1598   0D30             
1599   0D30 3A CB 21    STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1600   0D33 B7                  OR      A               ; Already at start?
1601   0D34 C8                  RET     Z               ; Yes - Do nothing
1602   0D35 C3 3D 0D            JP      PRNTCRLF        ; Start a new line
1603   0D38             
1604   0D38 36 00       ENDINP: LD      (HL),0          ; Mark end of buffer
1605   0D3A 21 80 21            LD      HL,BUFFER-1     ; Point to buffer
1606   0D3D 3E 0D       PRNTCRLF: LD    A,CR            ; Load a CR
1607   0D3F CD 16 09            CALL    OUTC            ; Output character
1608   0D42 3E 0A               LD      A,LF            ; Load a LF
1609   0D44 CD 16 09            CALL    OUTC            ; Output character
1610   0D47 AF          DONULL: XOR     A               ; Set to position 0
1611   0D48 32 CB 21            LD      (CURPOS),A      ; Store it
1612   0D4B 3A 61 21            LD      A,(NULLS)       ; Get number of nulls
1613   0D4E 3D          NULLP:  DEC     A               ; Count them
1614   0D4F C8                  RET     Z               ; Return if done
1615   0D50 F5                  PUSH    AF              ; Save count
1616   0D51 AF                  XOR     A               ; Load a null
1617   0D52 CD 16 09            CALL    OUTC            ; Output it
1618   0D55 F1                  POP     AF              ; Restore count
1619   0D56 C3 4E 0D            JP      NULLP           ; Keep counting
1620   0D59             
1621   0D59 3A 63 21    DOCOM:  LD      A,(COMMAN)      ; Get comma width
1622   0D5C 47                  LD      B,A             ; Save in B
1623   0D5D 3A CB 21            LD      A,(CURPOS)      ; Get current position
1624   0D60 B8                  CP      B               ; Within the limit?
1625   0D61 D4 3D 0D            CALL    NC,PRNTCRLF     ; No - output CRLF
1626   0D64 D2 93 0D            JP      NC,NEXITM       ; Get next item
1627   0D67 D6 0E       ZONELP: SUB     14              ; Next zone of 14 characters
1628   0D69 D2 67 0D            JP      NC,ZONELP       ; Repeat if more zones
1629   0D6C 2F                  CPL                     ; Number of spaces to output
1630   0D6D C3 88 0D            JP      ASPCS           ; Output them
1631   0D70             
1632   0D70 F5          DOTAB:  PUSH    AF              ; Save token
1633   0D71 CD 60 16            CALL    FNDNUM          ; Evaluate expression
1634   0D74 CD 0B 09            CALL    CHKSYN          ; Make sure ")" follows
1635   0D77 29                  .BYTE   ")"
1636   0D78 2B                  DEC     HL              ; Back space on to ")"
1637   0D79 F1                  POP     AF              ; Restore token
1638   0D7A D6 A8               SUB     ZSPC            ; Was it "SPC(" ?
1639   0D7C E5                  PUSH    HL              ; Save code string address
1640   0D7D CA 83 0D            JP      Z,DOSPC         ; Yes - Do 'E' spaces
1641   0D80 3A CB 21            LD      A,(CURPOS)      ; Get current position
1642   0D83 2F          DOSPC:  CPL                     ; Number of spaces to print to
1643   0D84 83                  ADD     A,E             ; Total number to print
1644   0D85 D2 93 0D            JP      NC,NEXITM       ; TAB < Current POS(X)
1645   0D88 3C          ASPCS:  INC     A               ; Output A spaces
1646   0D89 47                  LD      B,A             ; Save number to print
1647   0D8A 3E 20               LD      A,' '           ; Space
1648   0D8C CD 16 09    SPCLP:  CALL    OUTC            ; Output character in A
1649   0D8F 05                  DEC     B               ; Count them
1650   0D90 C2 8C 0D            JP      NZ,SPCLP        ; Repeat if more
1651   0D93 E1          NEXITM: POP     HL              ; Restore code string address
1652   0D94 CD 95 0A            CALL    GETCHR          ; Get next character
1653   0D97 C3 E2 0C            JP      PRNTLP          ; More to print
1654   0D9A             
1655   0D9A 3F5265646F20REDO:   .BYTE   "?Redo from start",CR,LF,0
1655   0DA0 66726F6D2073746172740D0A00
1656   0DAD             
1657   0DAD 3A ED 21    BADINP: LD      A,(READFG)      ; READ or INPUT?
1658   0DB0 B7                  OR      A
1659   0DB1 C2 37 06            JP      NZ,DATSNR       ; READ - ?SN Error
1660   0DB4 C1                  POP     BC              ; Throw away code string addr
1661   0DB5 21 9A 0D            LD      HL,REDO         ; "Redo from start" message
1662   0DB8 CD DB 13            CALL    PRS             ; Output string
1663   0DBB C3 88 07            JP      DOAGN           ; Do last INPUT again
1664   0DBE             
1665   0DBE CD 46 13    INPUT:  CALL    IDTEST          ; Test for illegal direct
1666   0DC1 7E                  LD      A,(HL)          ; Get character after "INPUT"
1667   0DC2 FE 22               CP      '"'             ; Is there a prompt string?
1668   0DC4 3E 00               LD      A,0             ; Clear A and leave flags
1669   0DC6 32 65 21            LD      (CTLOFG),A      ; Enable output
1670   0DC9 C2 D8 0D            JP      NZ,NOPMPT       ; No prompt - get input
1671   0DCC CD 9A 13            CALL    QTSTR           ; Get string terminated by '"'
1672   0DCF CD 0B 09            CALL    CHKSYN          ; Check for ';' after prompt
1673   0DD2 3B                  .BYTE   ';'
1674   0DD3 E5                  PUSH    HL              ; Save code string address
1675   0DD4 CD DE 13            CALL    PRS1            ; Output prompt string
1676   0DD7 3E                  .BYTE   3EH             ; Skip "PUSH HL"
1677   0DD8 E5          NOPMPT: PUSH    HL              ; Save code string address
1678   0DD9 CD 8C 07            CALL    PROMPT          ; Get input with "? " prompt
1679   0DDC C1                  POP     BC              ; Restore code string address
1680   0DDD DA E4 0A            JP      C,INPBRK        ; Break pressed - Exit
1681   0DE0 23                  INC     HL              ; Next byte
1682   0DE1 7E                  LD      A,(HL)          ; Get it
1683   0DE2 B7                  OR      A               ; End of line?
1684   0DE3 2B                  DEC     HL              ; Back again
1685   0DE4 C5                  PUSH    BC              ; Re-save code string address
1686   0DE5 CA 2B 0C            JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1687   0DE8 36 2C               LD      (HL),','        ; Store comma as separator
1688   0DEA C3 F2 0D            JP      NXTITM          ; Get next item
1689   0DED             
1690   0DED E5          READ:   PUSH    HL              ; Save code string address
1691   0DEE 2A FC 21            LD      HL,(NXTDAT)     ; Next DATA statement
1692   0DF1 F6                  .BYTE   0F6H            ; Flag "READ"
1693   0DF2 AF          NXTITM: XOR     A               ; Flag "INPUT"
1694   0DF3 32 ED 21            LD      (READFG),A      ; Save "READ"/"INPUT" flag
1695   0DF6 E3                  EX      (SP),HL         ; Get code str' , Save pointer
1696   0DF7 C3 FE 0D            JP      GTVLUS          ; Get values
1697   0DFA             
1698   0DFA CD 0B 09    NEDMOR: CALL    CHKSYN          ; Check for comma between items
1699   0DFD 2C                  .BYTE      ','
1700   0DFE CD F8 10    GTVLUS: CALL    GETVAR          ; Get variable name
1701   0E01 E3                  EX      (SP),HL         ; Save code str" , Get pointer
1702   0E02 D5                  PUSH    DE              ; Save variable address
1703   0E03 7E                  LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1704   0E04 FE 2C               CP      ','             ; Comma?
1705   0E06 CA 26 0E            JP      Z,ANTVLU        ; Yes - Get another value
1706   0E09 3A ED 21            LD      A,(READFG)      ; Is it READ?
1707   0E0C B7                  OR      A
1708   0E0D C2 93 0E            JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1709   0E10 3E 3F               LD      A,'?'           ; More INPUT needed
1710   0E12 CD 16 09            CALL    OUTC            ; Output character
1711   0E15 CD 8C 07            CALL    PROMPT          ; Get INPUT with prompt
1712   0E18 D1                  POP     DE              ; Variable address
1713   0E19 C1                  POP     BC              ; Code string address
1714   0E1A DA E4 0A            JP      C,INPBRK        ; Break pressed
1715   0E1D 23                  INC     HL              ; Point to next DATA byte
1716   0E1E 7E                  LD      A,(HL)          ; Get byte
1717   0E1F B7                  OR      A               ; Is it zero (No input) ?
1718   0E20 2B                  DEC     HL              ; Back space INPUT pointer
1719   0E21 C5                  PUSH    BC              ; Save code string address
1720   0E22 CA 2B 0C            JP      Z,NXTDTA        ; Find end of buffer
1721   0E25 D5                  PUSH    DE              ; Save variable address
1722   0E26 3A CD 21    ANTVLU: LD      A,(TYPE)        ; Check data type
1723   0E29 B7                  OR      A               ; Is it numeric?
1724   0E2A CA 50 0E            JP      Z,INPBIN        ; Yes - Convert to binary
1725   0E2D CD 95 0A            CALL    GETCHR          ; Get next character
1726   0E30 57                  LD      D,A             ; Save input character
1727   0E31 47                  LD      B,A             ; Again
1728   0E32 FE 22               CP      '"'             ; Start of literal sting?
1729   0E34 CA 44 0E            JP      Z,STRENT        ; Yes - Create string entry
1730   0E37 3A ED 21            LD      A,(READFG)      ; "READ" or "INPUT" ?
1731   0E3A B7                  OR      A
1732   0E3B 57                  LD      D,A             ; Save 00 if "INPUT"
1733   0E3C CA 41 0E            JP      Z,ITMSEP        ; "INPUT" - End with 00
1734   0E3F 16 3A               LD      D,':'           ; "DATA" - End with 00 or ':'
1735   0E41 06 2C       ITMSEP: LD      B,','           ; Item separator
1736   0E43 2B                  DEC     HL              ; Back space for DTSTR
1737   0E44 CD 9D 13    STRENT: CALL    DTSTR           ; Get string terminated by D
1738   0E47 EB                  EX      DE,HL           ; String address to DE
1739   0E48 21 5B 0E            LD      HL,LTSTND       ; Where to go after LETSTR
1740   0E4B E3                  EX      (SP),HL         ; Save HL , get input pointer
1741   0E4C D5                  PUSH    DE              ; Save address of string
1742   0E4D C3 5E 0C            JP      LETSTR          ; Assign string to variable
1743   0E50             
1744   0E50 CD 95 0A    INPBIN: CALL    GETCHR          ; Get next character
1745   0E53 CD EB 19            CALL    ASCTFP          ; Convert ASCII to FP number
1746   0E56 E3                  EX      (SP),HL         ; Save input ptr, Get var addr
1747   0E57 CD 3C 19            CALL    FPTHL           ; Move FPREG to variable
1748   0E5A E1                  POP     HL              ; Restore input pointer
1749   0E5B 2B          LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1750   0E5C CD 95 0A            CALL    GETCHR          ; Get next character
1751   0E5F CA 67 0E            JP      Z,MORDT         ; End of line - More needed?
1752   0E62 FE 2C               CP      ','             ; Another value?
1753   0E64 C2 AD 0D            JP      NZ,BADINP       ; No - Bad input
1754   0E67 E3          MORDT:  EX      (SP),HL         ; Get code string address
1755   0E68 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
1756   0E69 CD 95 0A            CALL    GETCHR          ; Get next character
1757   0E6C C2 FA 0D            JP      NZ,NEDMOR       ; More needed - Get it
1758   0E6F D1                  POP     DE              ; Restore DATA pointer
1759   0E70 3A ED 21            LD      A,(READFG)      ; "READ" or "INPUT" ?
1760   0E73 B7                  OR      A
1761   0E74 EB                  EX      DE,HL           ; DATA pointer to HL
1762   0E75 C2 BB 0A            JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1763   0E78 D5                  PUSH    DE              ; Save code string address
1764   0E79 B6                  OR      (HL)            ; More input given?
1765   0E7A 21 82 0E            LD      HL,EXTIG        ; "?Extra ignored" message
1766   0E7D C4 DB 13            CALL    NZ,PRS          ; Output string if extra given
1767   0E80 E1                  POP     HL              ; Restore code string address
1768   0E81 C9                  RET
1769   0E82             
1770   0E82 3F4578747261EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
1770   0E88 2069676E6F7265640D0A00
1771   0E93             
1772   0E93 CD 2C 0C    FDTLP:  CALL    DATA            ; Get next statement
1773   0E96 B7                  OR      A               ; End of line?
1774   0E97 C2 AC 0E            JP      NZ,FANDT        ; No - See if DATA statement
1775   0E9A 23                  INC     HL
1776   0E9B 7E                  LD      A,(HL)          ; End of program?
1777   0E9C 23                  INC     HL
1778   0E9D B6                  OR      (HL)            ; 00 00 Ends program
1779   0E9E 1E 06               LD      E,OD            ; ?OD Error
1780   0EA0 CA 51 06            JP      Z,ERROR         ; Yes - Out of DATA
1781   0EA3 23                  INC     HL
1782   0EA4 5E                  LD      E,(HL)          ; LSB of line number
1783   0EA5 23                  INC     HL
1784   0EA6 56                  LD      D,(HL)          ; MSB of line number
1785   0EA7 EB                  EX      DE,HL
1786   0EA8 22 E9 21            LD      (DATLIN),HL     ; Set line of current DATA item
1787   0EAB EB                  EX      DE,HL
1788   0EAC CD 95 0A    FANDT:  CALL    GETCHR          ; Get next character
1789   0EAF FE 83               CP      ZDATA           ; "DATA" token
1790   0EB1 C2 93 0E            JP      NZ,FDTLP        ; No "DATA" - Keep looking
1791   0EB4 C3 26 0E            JP      ANTVLU          ; Found - Convert input
1792   0EB7             
1793   0EB7 11 00 00    NEXT:   LD      DE,0            ; In case no index given
1794   0EBA C4 F8 10    NEXT1:  CALL    NZ,GETVAR       ; Get index address
1795   0EBD 22 EE 21            LD      (BRKLIN),HL     ; Save code string address
1796   0EC0 CD E6 05            CALL    BAKSTK          ; Look for "FOR" block
1797   0EC3 C2 43 06            JP      NZ,NFERR        ; No "FOR" - ?NF Error
1798   0EC6 F9                  LD      SP,HL           ; Clear nested loops
1799   0EC7 D5                  PUSH    DE              ; Save index address
1800   0EC8 7E                  LD      A,(HL)          ; Get sign of STEP
1801   0EC9 23                  INC     HL
1802   0ECA F5                  PUSH    AF              ; Save sign of STEP
1803   0ECB D5                  PUSH    DE              ; Save index address
1804   0ECC CD 22 19            CALL    PHLTFP          ; Move index value to FPREG
1805   0ECF E3                  EX      (SP),HL         ; Save address of TO value
1806   0ED0 E5                  PUSH    HL              ; Save address of index
1807   0ED1 CD 8F 16            CALL    ADDPHL          ; Add STEP to index value
1808   0ED4 E1                  POP     HL              ; Restore address of index
1809   0ED5 CD 3C 19            CALL    FPTHL           ; Move value to index variable
1810   0ED8 E1                  POP     HL              ; Restore address of TO value
1811   0ED9 CD 33 19            CALL    LOADFP          ; Move TO value to BCDE
1812   0EDC E5                  PUSH    HL              ; Save address of line of FOR
1813   0EDD CD 5F 19            CALL    CMPNUM          ; Compare index with TO value
1814   0EE0 E1                  POP     HL              ; Restore address of line num
1815   0EE1 C1                  POP     BC              ; Address of sign of STEP
1816   0EE2 90                  SUB     B               ; Compare with expected sign
1817   0EE3 CD 33 19            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1818   0EE6 CA F2 0E            JP      Z,KILFOR        ; Loop finished - Terminate it
1819   0EE9 EB                  EX      DE,HL           ; Loop statement line number
1820   0EEA 22 7C 21            LD      (LINEAT),HL     ; Set loop line number
1821   0EED 69                  LD      L,C             ; Set code string to loop
1822   0EEE 60                  LD      H,B
1823   0EEF C3 51 0A            JP      PUTFID          ; Put back "FOR" and continue
1824   0EF2             
1825   0EF2 F9          KILFOR: LD      SP,HL           ; Remove "FOR" block
1826   0EF3 2A EE 21            LD      HL,(BRKLIN)     ; Code string after "NEXT"
1827   0EF6 7E                  LD      A,(HL)          ; Get next byte in code string
1828   0EF7 FE 2C               CP      ','             ; More NEXTs ?
1829   0EF9 C2 55 0A            JP      NZ,RUNCNT       ; No - Do next statement
1830   0EFC CD 95 0A            CALL    GETCHR          ; Position to index name
1831   0EFF CD BA 0E            CALL    NEXT1           ; Re-enter NEXT routine
1832   0F02             ; < will not RETurn to here , Exit to RUNCNT or Loop >
1833   0F02             
1834   0F02 CD 14 0F    GETNUM: CALL    EVAL            ; Get a numeric expression
1835   0F05 F6          TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
1836   0F06 37          TSTSTR: SCF                     ; Set carry (string)
1837   0F07 3A CD 21    CHKTYP: LD      A,(TYPE)        ; Check types match
1838   0F0A 8F                  ADC     A,A             ; Expected + actual
1839   0F0B B7                  OR      A               ; Clear carry , set parity
1840   0F0C E8                  RET     PE              ; Even parity - Types match
1841   0F0D C3 4F 06            JP      TMERR           ; Different types - Error
1842   0F10             
1843   0F10 CD 0B 09    OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1844   0F13 28                  .BYTE   "("
1845   0F14 2B          EVAL:   DEC     HL              ; Evaluate expression & save
1846   0F15 16 00               LD      D,0             ; Precedence value
1847   0F17 D5          EVAL1:  PUSH    DE              ; Save precedence
1848   0F18 0E 01               LD      C,1
1849   0F1A CD 1A 06            CALL    CHKSTK          ; Check for 1 level of stack
1850   0F1D CD 8B 0F            CALL    OPRND           ; Get next expression value
1851   0F20 22 F0 21    EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1852   0F23 2A F0 21    EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1853   0F26 C1                  POP     BC              ; Precedence value and operator
1854   0F27 78                  LD      A,B             ; Get precedence value
1855   0F28 FE 78               CP      78H             ; "AND" or "OR" ?
1856   0F2A D4 05 0F            CALL    NC,TSTNUM       ; No - Make sure it's a number
1857   0F2D 7E                  LD      A,(HL)          ; Get next operator / function
1858   0F2E 16 00               LD      D,0             ; Clear Last relation
1859   0F30 D6 B3       RLTLP:  SUB     ZGTR            ; ">" Token
1860   0F32 DA 4C 0F            JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1861   0F35 FE 03               CP      ZLTH+1-ZGTR     ; < = >
1862   0F37 D2 4C 0F            JP      NC,FOPRND       ; Function - Call it
1863   0F3A FE 01               CP      ZEQUAL-ZGTR     ; "="
1864   0F3C 17                  RLA                     ; <- Test for legal
1865   0F3D AA                  XOR     D               ; <- combinations of < = >
1866   0F3E BA                  CP      D               ; <- by combining last token
1867   0F3F 57                  LD      D,A             ; <- with current one
1868   0F40 DA 3D 06            JP      C,SNERR         ; Error if "<<' '==" or ">>"
1869   0F43 22 E5 21            LD      (CUROPR),HL     ; Save address of current token
1870   0F46 CD 95 0A            CALL    GETCHR          ; Get next character
1871   0F49 C3 30 0F            JP      RLTLP           ; Treat the two as one
1872   0F4C             
1873   0F4C 7A          FOPRND: LD      A,D             ; < = > found ?
1874   0F4D B7                  OR      A
1875   0F4E C2 73 10            JP      NZ,TSTRED       ; Yes - Test for reduction
1876   0F51 7E                  LD      A,(HL)          ; Get operator token
1877   0F52 22 E5 21            LD      (CUROPR),HL     ; Save operator address
1878   0F55 D6 AC               SUB     ZPLUS           ; Operator or function?
1879   0F57 D8                  RET     C               ; Neither - Exit
1880   0F58 FE 07               CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1881   0F5A D0                  RET     NC              ; No - Exit
1882   0F5B 5F                  LD      E,A             ; Coded operator
1883   0F5C 3A CD 21            LD      A,(TYPE)        ; Get data type
1884   0F5F 3D                  DEC     A               ; FF = numeric , 00 = string
1885   0F60 B3                  OR      E               ; Combine with coded operator
1886   0F61 7B                  LD      A,E             ; Get coded operator
1887   0F62 CA D1 14            JP      Z,CONCAT        ; String concatenation
1888   0F65 07                  RLCA                    ; Times 2
1889   0F66 83                  ADD     A,E             ; Times 3
1890   0F67 5F                  LD      E,A             ; To DE (D is 0)
1891   0F68 21 2F 05            LD      HL,PRITAB       ; Precedence table
1892   0F6B 19                  ADD     HL,DE           ; To the operator concerned
1893   0F6C 78                  LD      A,B             ; Last operator precedence
1894   0F6D 56                  LD      D,(HL)          ; Get evaluation precedence
1895   0F6E BA                  CP      D               ; Compare with eval precedence
1896   0F6F D0                  RET     NC              ; Exit if higher precedence
1897   0F70 23                  INC     HL              ; Point to routine address
1898   0F71 CD 05 0F            CALL    TSTNUM          ; Make sure it's a number
1899   0F74             
1900   0F74 C5          STKTHS: PUSH    BC              ; Save last precedence & token
1901   0F75 01 23 0F            LD      BC,EVAL3        ; Where to go on prec' break
1902   0F78 C5                  PUSH    BC              ; Save on stack for return
1903   0F79 43                  LD      B,E             ; Save operator
1904   0F7A 4A                  LD      C,D             ; Save precedence
1905   0F7B CD 15 19            CALL    STAKFP          ; Move value to stack
1906   0F7E 58                  LD      E,B             ; Restore operator
1907   0F7F 51                  LD      D,C             ; Restore precedence
1908   0F80 4E                  LD      C,(HL)          ; Get LSB of routine address
1909   0F81 23                  INC     HL
1910   0F82 46                  LD      B,(HL)          ; Get MSB of routine address
1911   0F83 23                  INC     HL
1912   0F84 C5                  PUSH    BC              ; Save routine address
1913   0F85 2A E5 21            LD      HL,(CUROPR)     ; Address of current operator
1914   0F88 C3 17 0F            JP      EVAL1           ; Loop until prec' break
1915   0F8B             
1916   0F8B AF          OPRND:  XOR     A               ; Get operand routine
1917   0F8C 32 CD 21            LD      (TYPE),A        ; Set numeric expected
1918   0F8F CD 95 0A            CALL    GETCHR          ; Get next character
1919   0F92 1E 24               LD      E,MO            ; ?MO Error
1920   0F94 CA 51 06            JP      Z,ERROR         ; No operand - Error
1921   0F97 DA EB 19            JP      C,ASCTFP        ; Number - Get value
1922   0F9A CD 33 0B            CALL    CHKLTR          ; See if a letter
1923   0F9D D2 F2 0F            JP      NC,CONVAR       ; Letter - Find variable
1924   0FA0 FE 26               CP	'&'		; &H = HEX, &B = BINARY
1925   0FA2 20 12               JR	NZ, NOTAMP
1926   0FA4 CD 95 0A            CALL    GETCHR          ; Get next character
1927   0FA7 FE 48               CP      'H'             ; Hex number indicated? [function added]
1928   0FA9 CA 2F 1E            JP      Z,HEXTFP        ; Convert Hex to FPREG
1929   0FAC FE 42               CP      'B'             ; Binary number indicated? [function added]
1930   0FAE CA 9F 1E            JP      Z,BINTFP        ; Convert Bin to FPREG
1931   0FB1 1E 02               LD      E,SN            ; If neither then a ?SN Error
1932   0FB3 CA 51 06            JP      Z,ERROR         ; 
1933   0FB6 FE AC       NOTAMP: CP      ZPLUS           ; '+' Token ?
1934   0FB8 CA 8B 0F            JP      Z,OPRND         ; Yes - Look for operand
1935   0FBB FE 2E               CP      '.'             ; '.' ?
1936   0FBD CA EB 19            JP      Z,ASCTFP        ; Yes - Create FP number
1937   0FC0 FE AD               CP      ZMINUS          ; '-' Token ?
1938   0FC2 CA E1 0F            JP      Z,MINUS         ; Yes - Do minus
1939   0FC5 FE 22               CP      '"'             ; Literal string ?
1940   0FC7 CA 9A 13            JP      Z,QTSTR         ; Get string terminated by '"'
1941   0FCA FE AA               CP      ZNOT            ; "NOT" Token ?
1942   0FCC CA D3 10            JP      Z,EVNOT         ; Yes - Eval NOT expression
1943   0FCF FE A7               CP      ZFN             ; "FN" Token ?
1944   0FD1 CA FE 12            JP      Z,DOFN          ; Yes - Do FN routine
1945   0FD4 D6 B6               SUB     ZSGN            ; Is it a function?
1946   0FD6 D2 03 10            JP      NC,FNOFST       ; Yes - Evaluate function
1947   0FD9 CD 10 0F    EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1948   0FDC CD 0B 09            CALL    CHKSYN          ; Make sure ")" follows
1949   0FDF 29                  .BYTE   ")"
1950   0FE0 C9                  RET
1951   0FE1             
1952   0FE1 16 7D       MINUS:  LD      D,7DH           ; '-' precedence
1953   0FE3 CD 17 0F            CALL    EVAL1           ; Evaluate until prec' break
1954   0FE6 2A F0 21            LD      HL,(NXTOPR)     ; Get next operator address
1955   0FE9 E5                  PUSH    HL              ; Save next operator address
1956   0FEA CD 0D 19            CALL    INVSGN          ; Negate value
1957   0FED CD 05 0F    RETNUM: CALL    TSTNUM          ; Make sure it's a number
1958   0FF0 E1                  POP     HL              ; Restore next operator address
1959   0FF1 C9                  RET
1960   0FF2             
1961   0FF2 CD F8 10    CONVAR: CALL    GETVAR          ; Get variable address to DE
1962   0FF5 E5          FRMEVL: PUSH    HL              ; Save code string address
1963   0FF6 EB                  EX      DE,HL           ; Variable address to HL
1964   0FF7 22 04 22            LD      (FPREG),HL      ; Save address of variable
1965   0FFA 3A CD 21            LD      A,(TYPE)        ; Get type
1966   0FFD B7                  OR      A               ; Numeric?
1967   0FFE CC 22 19            CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1968   1001 E1                  POP     HL              ; Restore code string address
1969   1002 C9                  RET
1970   1003             
1971   1003 06 00       FNOFST: LD      B,0             ; Get address of function
1972   1005 07                  RLCA                    ; Double function offset
1973   1006 4F                  LD      C,A             ; BC = Offset in function table
1974   1007 C5                  PUSH    BC              ; Save adjusted token value
1975   1008 CD 95 0A            CALL    GETCHR          ; Get next character
1976   100B 79                  LD      A,C             ; Get adjusted token value
1977   100C FE 31               CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1978   100E DA 2A 10            JP      C,FNVAL         ; No - Do function
1979   1011 CD 10 0F            CALL    OPNPAR          ; Evaluate expression  (X,...
1980   1014 CD 0B 09            CALL    CHKSYN          ; Make sure ',' follows
1981   1017 2C                  .BYTE      ','
1982   1018 CD 06 0F            CALL    TSTSTR          ; Make sure it's a string
1983   101B EB                  EX      DE,HL           ; Save code string address
1984   101C 2A 04 22            LD      HL,(FPREG)      ; Get address of string
1985   101F E3                  EX      (SP),HL         ; Save address of string
1986   1020 E5                  PUSH    HL              ; Save adjusted token value
1987   1021 EB                  EX      DE,HL           ; Restore code string address
1988   1022 CD 63 16            CALL    GETINT          ; Get integer 0-255
1989   1025 EB                  EX      DE,HL           ; Save code string address
1990   1026 E3                  EX      (SP),HL         ; Save integer,HL = adj' token
1991   1027 C3 32 10            JP      GOFUNC          ; Jump to string function
1992   102A             
1993   102A CD D9 0F    FNVAL:  CALL    EVLPAR          ; Evaluate expression
1994   102D E3                  EX      (SP),HL         ; HL = Adjusted token value
1995   102E 11 ED 0F            LD      DE,RETNUM       ; Return number from function
1996   1031 D5                  PUSH    DE              ; Save on stack
1997   1032 01 8E 03    GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
1998   1035 09                  ADD     HL,BC           ; Point to right address
1999   1036 4E                  LD      C,(HL)          ; Get LSB of address
2000   1037 23                  INC     HL              ;
2001   1038 66                  LD      H,(HL)          ; Get MSB of address
2002   1039 69                  LD      L,C             ; Address to HL
2003   103A E9                  JP      (HL)            ; Jump to function
2004   103B             
2005   103B 15          SGNEXP: DEC     D               ; Dee to flag negative exponent
2006   103C FE AD               CP      ZMINUS          ; '-' token ?
2007   103E C8                  RET     Z               ; Yes - Return
2008   103F FE 2D               CP      '-'             ; '-' ASCII ?
2009   1041 C8                  RET     Z               ; Yes - Return
2010   1042 14                  INC     D               ; Inc to flag positive exponent
2011   1043 FE 2B               CP      '+'             ; '+' ASCII ?
2012   1045 C8                  RET     Z               ; Yes - Return
2013   1046 FE AC               CP      ZPLUS           ; '+' token ?
2014   1048 C8                  RET     Z               ; Yes - Return
2015   1049 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2016   104A C9                  RET                     ; Return "NZ"
2017   104B             
2018   104B F6          POR:    .BYTE      0F6H            ; Flag "OR"
2019   104C AF          PAND:   XOR     A               ; Flag "AND"
2020   104D F5                  PUSH    AF              ; Save "AND" / "OR" flag
2021   104E CD 05 0F            CALL    TSTNUM          ; Make sure it's a number
2022   1051 CD 47 0B            CALL    DEINT           ; Get integer -32768 to 32767
2023   1054 F1                  POP     AF              ; Restore "AND" / "OR" flag
2024   1055 EB                  EX      DE,HL           ; <- Get last
2025   1056 C1                  POP     BC              ; <-  value
2026   1057 E3                  EX      (SP),HL         ; <-  from
2027   1058 EB                  EX      DE,HL           ; <-  stack
2028   1059 CD 25 19            CALL    FPBCDE          ; Move last value to FPREG
2029   105C F5                  PUSH    AF              ; Save "AND" / "OR" flag
2030   105D CD 47 0B            CALL    DEINT           ; Get integer -32768 to 32767
2031   1060 F1                  POP     AF              ; Restore "AND" / "OR" flag
2032   1061 C1                  POP     BC              ; Get value
2033   1062 79                  LD      A,C             ; Get LSB
2034   1063 21 BC 12            LD      HL,ACPASS       ; Address of save AC as current
2035   1066 C2 6E 10            JP      NZ,POR1         ; Jump if OR
2036   1069 A3                  AND     E               ; "AND" LSBs
2037   106A 4F                  LD      C,A             ; Save LSB
2038   106B 78                  LD      A,B             ; Get MBS
2039   106C A2                  AND     D               ; "AND" MSBs
2040   106D E9                  JP      (HL)            ; Save AC as current (ACPASS)
2041   106E             
2042   106E B3          POR1:   OR      E               ; "OR" LSBs
2043   106F 4F                  LD      C,A             ; Save LSB
2044   1070 78                  LD      A,B             ; Get MSB
2045   1071 B2                  OR      D               ; "OR" MSBs
2046   1072 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2047   1073             
2048   1073 21 85 10    TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2049   1076 3A CD 21            LD      A,(TYPE)        ; Get data type
2050   1079 1F                  RRA                     ; Carry set = string
2051   107A 7A                  LD      A,D             ; Get last precedence value
2052   107B 17                  RLA                     ; Times 2 plus carry
2053   107C 5F                  LD      E,A             ; To E
2054   107D 16 64               LD      D,64H           ; Relational precedence
2055   107F 78                  LD      A,B             ; Get current precedence
2056   1080 BA                  CP      D               ; Compare with last
2057   1081 D0                  RET     NC              ; Eval if last was rel' or log'
2058   1082 C3 74 0F            JP      STKTHS          ; Stack this one and get next
2059   1085             
2060   1085 87 10       CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2061   1087 79          CMPLG1: LD      A,C             ; Get data type
2062   1088 B7                  OR      A
2063   1089 1F                  RRA
2064   108A C1                  POP     BC              ; Get last expression to BCDE
2065   108B D1                  POP     DE
2066   108C F5                  PUSH    AF              ; Save status
2067   108D CD 07 0F            CALL    CHKTYP          ; Check that types match
2068   1090 21 C9 10            LD      HL,CMPRES       ; Result to comparison
2069   1093 E5                  PUSH    HL              ; Save for RETurn
2070   1094 CA 5F 19            JP      Z,CMPNUM        ; Compare values if numeric
2071   1097 AF                  XOR     A               ; Compare two strings
2072   1098 32 CD 21            LD      (TYPE),A        ; Set type to numeric
2073   109B D5                  PUSH    DE              ; Save string name
2074   109C CD 1E 15            CALL    GSTRCU          ; Get current string
2075   109F 7E                  LD      A,(HL)          ; Get length of string
2076   10A0 23                  INC     HL
2077   10A1 23                  INC     HL
2078   10A2 4E                  LD      C,(HL)          ; Get LSB of address
2079   10A3 23                  INC     HL
2080   10A4 46                  LD      B,(HL)          ; Get MSB of address
2081   10A5 D1                  POP     DE              ; Restore string name
2082   10A6 C5                  PUSH    BC              ; Save address of string
2083   10A7 F5                  PUSH    AF              ; Save length of string
2084   10A8 CD 22 15            CALL    GSTRDE          ; Get second string
2085   10AB CD 33 19            CALL    LOADFP          ; Get address of second string
2086   10AE F1                  POP     AF              ; Restore length of string 1
2087   10AF 57                  LD      D,A             ; Length to D
2088   10B0 E1                  POP     HL              ; Restore address of string 1
2089   10B1 7B          CMPSTR: LD      A,E             ; Bytes of string 2 to do
2090   10B2 B2                  OR      D               ; Bytes of string 1 to do
2091   10B3 C8                  RET     Z               ; Exit if all bytes compared
2092   10B4 7A                  LD      A,D             ; Get bytes of string 1 to do
2093   10B5 D6 01               SUB     1
2094   10B7 D8                  RET     C               ; Exit if end of string 1
2095   10B8 AF                  XOR     A
2096   10B9 BB                  CP      E               ; Bytes of string 2 to do
2097   10BA 3C                  INC     A
2098   10BB D0                  RET     NC              ; Exit if end of string 2
2099   10BC 15                  DEC     D               ; Count bytes in string 1
2100   10BD 1D                  DEC     E               ; Count bytes in string 2
2101   10BE 0A                  LD      A,(BC)          ; Byte in string 2
2102   10BF BE                  CP      (HL)            ; Compare to byte in string 1
2103   10C0 23                  INC     HL              ; Move up string 1
2104   10C1 03                  INC     BC              ; Move up string 2
2105   10C2 CA B1 10            JP      Z,CMPSTR        ; Same - Try next bytes
2106   10C5 3F                  CCF                     ; Flag difference (">" or "<")
2107   10C6 C3 EF 18            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2108   10C9             
2109   10C9 3C          CMPRES: INC     A               ; Increment current value
2110   10CA 8F                  ADC     A,A             ; Double plus carry
2111   10CB C1                  POP     BC              ; Get other value
2112   10CC A0                  AND     B               ; Combine them
2113   10CD C6 FF               ADD     A,-1            ; Carry set if different
2114   10CF 9F                  SBC     A,A             ; 00 - Equal , FF - Different
2115   10D0 C3 F6 18            JP      FLGREL          ; Set current value & continue
2116   10D3             
2117   10D3 16 5A       EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2118   10D5 CD 17 0F            CALL    EVAL1           ; Eval until precedence break
2119   10D8 CD 05 0F            CALL    TSTNUM          ; Make sure it's a number
2120   10DB CD 47 0B            CALL    DEINT           ; Get integer -32768 - 32767
2121   10DE 7B                  LD      A,E             ; Get LSB
2122   10DF 2F                  CPL                     ; Invert LSB
2123   10E0 4F                  LD      C,A             ; Save "NOT" of LSB
2124   10E1 7A                  LD      A,D             ; Get MSB
2125   10E2 2F                  CPL                     ; Invert MSB
2126   10E3 CD BC 12            CALL    ACPASS          ; Save AC as current
2127   10E6 C1                  POP     BC              ; Clean up stack
2128   10E7 C3 23 0F            JP      EVAL3           ; Continue evaluation
2129   10EA             
2130   10EA 2B          DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2131   10EB CD 95 0A            CALL    GETCHR          ; Get next character
2132   10EE C8                  RET     Z               ; End of DIM statement
2133   10EF CD 0B 09            CALL    CHKSYN          ; Make sure ',' follows
2134   10F2 2C                  .BYTE      ','
2135   10F3 01 EA 10    DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2136   10F6 C5                  PUSH    BC              ; Save on stack
2137   10F7 F6                  .BYTE      0F6H            ; Flag "Create" variable
2138   10F8 AF          GETVAR: XOR     A               ; Find variable address,to DE
2139   10F9 32 CC 21            LD      (LCRFLG),A      ; Set locate / create flag
2140   10FC 46                  LD      B,(HL)          ; Get First byte of name
2141   10FD CD 33 0B    GTFNAM: CALL    CHKLTR          ; See if a letter
2142   1100 DA 3D 06            JP      C,SNERR         ; ?SN Error if not a letter
2143   1103 AF                  XOR     A
2144   1104 4F                  LD      C,A             ; Clear second byte of name
2145   1105 32 CD 21            LD      (TYPE),A        ; Set type to numeric
2146   1108 CD 95 0A            CALL    GETCHR          ; Get next character
2147   110B DA 14 11            JP      C,SVNAM2        ; Numeric - Save in name
2148   110E CD 33 0B            CALL    CHKLTR          ; See if a letter
2149   1111 DA 21 11            JP      C,CHARTY        ; Not a letter - Check type
2150   1114 4F          SVNAM2: LD      C,A             ; Save second byte of name
2151   1115 CD 95 0A    ENDNAM: CALL    GETCHR          ; Get next character
2152   1118 DA 15 11            JP      C,ENDNAM        ; Numeric - Get another
2153   111B CD 33 0B            CALL    CHKLTR          ; See if a letter
2154   111E D2 15 11            JP      NC,ENDNAM       ; Letter - Get another
2155   1121 D6 24       CHARTY: SUB     '$'             ; String variable?
2156   1123 C2 30 11            JP      NZ,NOTSTR       ; No - Numeric variable
2157   1126 3C                  INC     A               ; A = 1 (string type)
2158   1127 32 CD 21            LD      (TYPE),A        ; Set type to string
2159   112A 0F                  RRCA                    ; A = 80H , Flag for string
2160   112B 81                  ADD     A,C             ; 2nd byte of name has bit 7 on
2161   112C 4F                  LD      C,A             ; Resave second byte on name
2162   112D CD 95 0A            CALL    GETCHR          ; Get next character
2163   1130 3A EB 21    NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2164   1133 3D                  DEC     A
2165   1134 CA DD 11            JP      Z,ARLDSV        ; Yes - Get array name
2166   1137 F2 40 11            JP      P,NSCFOR        ; No array with "FOR" or "FN"
2167   113A 7E                  LD      A,(HL)          ; Get byte again
2168   113B D6 28               SUB     '('             ; Subscripted variable?
2169   113D CA B5 11            JP      Z,SBSCPT        ; Yes - Sort out subscript
2170   1140             
2171   1140 AF          NSCFOR: XOR     A               ; Simple variable
2172   1141 32 EB 21            LD      (FORFLG),A      ; Clear "FOR" flag
2173   1144 E5                  PUSH    HL              ; Save code string address
2174   1145 50                  LD      D,B             ; DE = Variable name to find
2175   1146 59                  LD      E,C
2176   1147 2A FE 21            LD      HL,(FNRGNM)     ; FN argument name
2177   114A CD 05 09            CALL    CPDEHL          ; Is it the FN argument?
2178   114D 11 00 22            LD      DE,FNARG        ; Point to argument value
2179   1150 CA 25 18            JP      Z,POPHRT        ; Yes - Return FN argument value
2180   1153 2A F8 21            LD      HL,(VAREND)     ; End of variables
2181   1156 EB                  EX      DE,HL           ; Address of end of search
2182   1157 2A F6 21            LD      HL,(PROGND)     ; Start of variables address
2183   115A CD 05 09    FNDVAR: CALL    CPDEHL          ; End of variable list table?
2184   115D CA 73 11            JP      Z,CFEVAL        ; Yes - Called from EVAL?
2185   1160 79                  LD      A,C             ; Get second byte of name
2186   1161 96                  SUB     (HL)            ; Compare with name in list
2187   1162 23                  INC     HL              ; Move on to first byte
2188   1163 C2 68 11            JP      NZ,FNTHR        ; Different - Find another
2189   1166 78                  LD      A,B             ; Get first byte of name
2190   1167 96                  SUB     (HL)            ; Compare with name in list
2191   1168 23          FNTHR:  INC     HL              ; Move on to LSB of value
2192   1169 CA A7 11            JP      Z,RETADR        ; Found - Return address
2193   116C 23                  INC     HL              ; <- Skip
2194   116D 23                  INC     HL              ; <- over
2195   116E 23                  INC     HL              ; <- F.P.
2196   116F 23                  INC     HL              ; <- value
2197   1170 C3 5A 11            JP      FNDVAR          ; Keep looking
2198   1173             
2199   1173 E1          CFEVAL: POP     HL              ; Restore code string address
2200   1174 E3                  EX      (SP),HL         ; Get return address
2201   1175 D5                  PUSH    DE              ; Save address of variable
2202   1176 11 F5 0F            LD      DE,FRMEVL       ; Return address in EVAL
2203   1179 CD 05 09            CALL    CPDEHL          ; Called from EVAL ?
2204   117C D1                  POP     DE              ; Restore address of variable
2205   117D CA AA 11            JP      Z,RETNUL        ; Yes - Return null variable
2206   1180 E3                  EX      (SP),HL         ; Put back return
2207   1181 E5                  PUSH    HL              ; Save code string address
2208   1182 C5                  PUSH    BC              ; Save variable name
2209   1183 01 06 00            LD      BC,6            ; 2 byte name plus 4 byte data
2210   1186 2A FA 21            LD      HL,(ARREND)     ; End of arrays
2211   1189 E5                  PUSH    HL              ; Save end of arrays
2212   118A 09                  ADD     HL,BC           ; Move up 6 bytes
2213   118B C1                  POP     BC              ; Source address in BC
2214   118C E5                  PUSH    HL              ; Save new end address
2215   118D CD 09 06            CALL    MOVUP           ; Move arrays up
2216   1190 E1                  POP     HL              ; Restore new end address
2217   1191 22 FA 21            LD      (ARREND),HL     ; Set new end address
2218   1194 60                  LD      H,B             ; End of variables to HL
2219   1195 69                  LD      L,C
2220   1196 22 F8 21            LD      (VAREND),HL     ; Set new end address
2221   1199             
2222   1199 2B          ZEROLP: DEC     HL              ; Back through to zero variable
2223   119A 36 00               LD      (HL),0          ; Zero byte in variable
2224   119C CD 05 09            CALL    CPDEHL          ; Done them all?
2225   119F C2 99 11            JP      NZ,ZEROLP       ; No - Keep on going
2226   11A2 D1                  POP     DE              ; Get variable name
2227   11A3 73                  LD      (HL),E          ; Store second character
2228   11A4 23                  INC     HL
2229   11A5 72                  LD      (HL),D          ; Store first character
2230   11A6 23                  INC     HL
2231   11A7 EB          RETADR: EX      DE,HL           ; Address of variable in DE
2232   11A8 E1                  POP     HL              ; Restore code string address
2233   11A9 C9                  RET
2234   11AA             
2235   11AA 32 07 22    RETNUL: LD      (FPEXP),A       ; Set result to zero
2236   11AD 21 D9 05            LD      HL,ZERBYT       ; Also set a null string
2237   11B0 22 04 22            LD      (FPREG),HL      ; Save for EVAL
2238   11B3 E1                  POP     HL              ; Restore code string address
2239   11B4 C9                  RET
2240   11B5             
2241   11B5 E5          SBSCPT: PUSH    HL              ; Save code string address
2242   11B6 2A CC 21            LD      HL,(LCRFLG)     ; Locate/Create and Type
2243   11B9 E3                  EX      (SP),HL         ; Save and get code string
2244   11BA 57                  LD      D,A             ; Zero number of dimensions
2245   11BB D5          SCPTLP: PUSH    DE              ; Save number of dimensions
2246   11BC C5                  PUSH    BC              ; Save array name
2247   11BD CD 3B 0B            CALL    FPSINT          ; Get subscript (0-32767)
2248   11C0 C1                  POP     BC              ; Restore array name
2249   11C1 F1                  POP     AF              ; Get number of dimensions
2250   11C2 EB                  EX      DE,HL
2251   11C3 E3                  EX      (SP),HL         ; Save subscript value
2252   11C4 E5                  PUSH    HL              ; Save LCRFLG and TYPE
2253   11C5 EB                  EX      DE,HL
2254   11C6 3C                  INC     A               ; Count dimensions
2255   11C7 57                  LD      D,A             ; Save in D
2256   11C8 7E                  LD      A,(HL)          ; Get next byte in code string
2257   11C9 FE 2C               CP      ','             ; Comma (more to come)?
2258   11CB CA BB 11            JP      Z,SCPTLP        ; Yes - More subscripts
2259   11CE CD 0B 09            CALL    CHKSYN          ; Make sure ")" follows
2260   11D1 29                  .BYTE      ")"
2261   11D2 22 F0 21            LD      (NXTOPR),HL     ; Save code string address
2262   11D5 E1                  POP     HL              ; Get LCRFLG and TYPE
2263   11D6 22 CC 21            LD      (LCRFLG),HL     ; Restore Locate/create & type
2264   11D9 1E 00               LD      E,0             ; Flag not CSAVE* or CLOAD*
2265   11DB D5                  PUSH    DE              ; Save number of dimensions (D)
2266   11DC 11                  .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2267   11DD             
2268   11DD E5          ARLDSV: PUSH    HL              ; Save code string address
2269   11DE F5                  PUSH    AF              ; A = 00 , Flags set = Z,N
2270   11DF 2A F8 21            LD      HL,(VAREND)     ; Start of arrays
2271   11E2 3E                  .BYTE      3EH             ; Skip "ADD HL,DE"
2272   11E3 19          FNDARY: ADD     HL,DE           ; Move to next array start
2273   11E4 EB                  EX      DE,HL
2274   11E5 2A FA 21            LD      HL,(ARREND)     ; End of arrays
2275   11E8 EB                  EX      DE,HL           ; Current array pointer
2276   11E9 CD 05 09            CALL    CPDEHL          ; End of arrays found?
2277   11EC CA 15 12            JP      Z,CREARY        ; Yes - Create array
2278   11EF 7E                  LD      A,(HL)          ; Get second byte of name
2279   11F0 B9                  CP      C               ; Compare with name given
2280   11F1 23                  INC     HL              ; Move on
2281   11F2 C2 F7 11            JP      NZ,NXTARY       ; Different - Find next array
2282   11F5 7E                  LD      A,(HL)          ; Get first byte of name
2283   11F6 B8                  CP      B               ; Compare with name given
2284   11F7 23          NXTARY: INC     HL              ; Move on
2285   11F8 5E                  LD      E,(HL)          ; Get LSB of next array address
2286   11F9 23                  INC     HL
2287   11FA 56                  LD      D,(HL)          ; Get MSB of next array address
2288   11FB 23                  INC     HL
2289   11FC C2 E3 11            JP      NZ,FNDARY       ; Not found - Keep looking
2290   11FF 3A CC 21            LD      A,(LCRFLG)      ; Found Locate or Create it?
2291   1202 B7                  OR      A
2292   1203 C2 46 06            JP      NZ,DDERR        ; Create - ?DD Error
2293   1206 F1                  POP     AF              ; Locate - Get number of dim'ns
2294   1207 44                  LD      B,H             ; BC Points to array dim'ns
2295   1208 4D                  LD      C,L
2296   1209 CA 25 18            JP      Z,POPHRT        ; Jump if array load/save
2297   120C 96                  SUB     (HL)            ; Same number of dimensions?
2298   120D CA 73 12            JP      Z,FINDEL        ; Yes - Find element
2299   1210 1E 10       BSERR:  LD      E,BS            ; ?BS Error
2300   1212 C3 51 06            JP      ERROR           ; Output error
2301   1215             
2302   1215 11 04 00    CREARY: LD      DE,4            ; 4 Bytes per entry
2303   1218 F1                  POP     AF              ; Array to save or 0 dim'ns?
2304   1219 CA 5C 0B            JP      Z,FCERR         ; Yes - ?FC Error
2305   121C 71                  LD      (HL),C          ; Save second byte of name
2306   121D 23                  INC     HL
2307   121E 70                  LD      (HL),B          ; Save first byte of name
2308   121F 23                  INC     HL
2309   1220 4F                  LD      C,A             ; Number of dimensions to C
2310   1221 CD 1A 06            CALL    CHKSTK          ; Check if enough memory
2311   1224 23                  INC     HL              ; Point to number of dimensions
2312   1225 23                  INC     HL
2313   1226 22 E5 21            LD      (CUROPR),HL     ; Save address of pointer
2314   1229 71                  LD      (HL),C          ; Set number of dimensions
2315   122A 23                  INC     HL
2316   122B 3A CC 21            LD      A,(LCRFLG)      ; Locate of Create?
2317   122E 17                  RLA                     ; Carry set = Create
2318   122F 79                  LD      A,C             ; Get number of dimensions
2319   1230 01 0B 00    CRARLP: LD      BC,10+1         ; Default dimension size 10
2320   1233 D2 38 12            JP      NC,DEFSIZ       ; Locate - Set default size
2321   1236 C1                  POP     BC              ; Get specified dimension size
2322   1237 03                  INC     BC              ; Include zero element
2323   1238 71          DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2324   1239 23                  INC     HL
2325   123A 70                  LD      (HL),B          ; Save MSB of dimension size
2326   123B 23                  INC     HL
2327   123C F5                  PUSH    AF              ; Save num' of dim'ns an status
2328   123D E5                  PUSH    HL              ; Save address of dim'n size
2329   123E CD D0 19            CALL    MLDEBC          ; Multiply DE by BC to find
2330   1241 EB                  EX      DE,HL           ; amount of mem needed (to DE)
2331   1242 E1                  POP     HL              ; Restore address of dimension
2332   1243 F1                  POP     AF              ; Restore number of dimensions
2333   1244 3D                  DEC     A               ; Count them
2334   1245 C2 30 12            JP      NZ,CRARLP       ; Do next dimension if more
2335   1248 F5                  PUSH    AF              ; Save locate/create flag
2336   1249 42                  LD      B,D             ; MSB of memory needed
2337   124A 4B                  LD      C,E             ; LSB of memory needed
2338   124B EB                  EX      DE,HL
2339   124C 19                  ADD     HL,DE           ; Add bytes to array start
2340   124D DA 32 06            JP      C,OMERR         ; Too big - Error
2341   1250 CD 23 06            CALL    ENFMEM          ; See if enough memory
2342   1253 22 FA 21            LD      (ARREND),HL     ; Save new end of array
2343   1256             
2344   1256 2B          ZERARY: DEC     HL              ; Back through array data
2345   1257 36 00               LD      (HL),0          ; Set array element to zero
2346   1259 CD 05 09            CALL    CPDEHL          ; All elements zeroed?
2347   125C C2 56 12            JP      NZ,ZERARY       ; No - Keep on going
2348   125F 03                  INC     BC              ; Number of bytes + 1
2349   1260 57                  LD      D,A             ; A=0
2350   1261 2A E5 21            LD      HL,(CUROPR)     ; Get address of array
2351   1264 5E                  LD      E,(HL)          ; Number of dimensions
2352   1265 EB                  EX      DE,HL           ; To HL
2353   1266 29                  ADD     HL,HL           ; Two bytes per dimension size
2354   1267 09                  ADD     HL,BC           ; Add number of bytes
2355   1268 EB                  EX      DE,HL           ; Bytes needed to DE
2356   1269 2B                  DEC     HL
2357   126A 2B                  DEC     HL
2358   126B 73                  LD      (HL),E          ; Save LSB of bytes needed
2359   126C 23                  INC     HL
2360   126D 72                  LD      (HL),D          ; Save MSB of bytes needed
2361   126E 23                  INC     HL
2362   126F F1                  POP     AF              ; Locate / Create?
2363   1270 DA 97 12            JP      C,ENDDIM        ; A is 0 , End if create
2364   1273 47          FINDEL: LD      B,A             ; Find array element
2365   1274 4F                  LD      C,A
2366   1275 7E                  LD      A,(HL)          ; Number of dimensions
2367   1276 23                  INC     HL
2368   1277 16                  .BYTE      16H             ; Skip "POP HL"
2369   1278 E1          FNDELP: POP     HL              ; Address of next dim' size
2370   1279 5E                  LD      E,(HL)          ; Get LSB of dim'n size
2371   127A 23                  INC     HL
2372   127B 56                  LD      D,(HL)          ; Get MSB of dim'n size
2373   127C 23                  INC     HL
2374   127D E3                  EX      (SP),HL         ; Save address - Get index
2375   127E F5                  PUSH    AF              ; Save number of dim'ns
2376   127F CD 05 09            CALL    CPDEHL          ; Dimension too large?
2377   1282 D2 10 12            JP      NC,BSERR        ; Yes - ?BS Error
2378   1285 E5                  PUSH    HL              ; Save index
2379   1286 CD D0 19            CALL    MLDEBC          ; Multiply previous by size
2380   1289 D1                  POP     DE              ; Index supplied to DE
2381   128A 19                  ADD     HL,DE           ; Add index to pointer
2382   128B F1                  POP     AF              ; Number of dimensions
2383   128C 3D                  DEC     A               ; Count them
2384   128D 44                  LD      B,H             ; MSB of pointer
2385   128E 4D                  LD      C,L             ; LSB of pointer
2386   128F C2 78 12            JP      NZ,FNDELP       ; More - Keep going
2387   1292 29                  ADD     HL,HL           ; 4 Bytes per element
2388   1293 29                  ADD     HL,HL
2389   1294 C1                  POP     BC              ; Start of array
2390   1295 09                  ADD     HL,BC           ; Point to element
2391   1296 EB                  EX      DE,HL           ; Address of element to DE
2392   1297 2A F0 21    ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2393   129A C9                  RET
2394   129B             
2395   129B 2A FA 21    FRE:    LD      HL,(ARREND)     ; Start of free memory
2396   129E EB                  EX      DE,HL           ; To DE
2397   129F 21 00 00            LD      HL,0            ; End of free memory
2398   12A2 39                  ADD     HL,SP           ; Current stack value
2399   12A3 3A CD 21            LD      A,(TYPE)        ; Dummy argument type
2400   12A6 B7                  OR      A
2401   12A7 CA B7 12            JP      Z,FRENUM        ; Numeric - Free variable space
2402   12AA CD 1E 15            CALL    GSTRCU          ; Current string to pool
2403   12AD CD 1E 14            CALL    GARBGE          ; Garbage collection
2404   12B0 2A 7A 21            LD      HL,(STRSPC)     ; Bottom of string space in use
2405   12B3 EB                  EX      DE,HL           ; To DE
2406   12B4 2A E3 21            LD      HL,(STRBOT)     ; Bottom of string space
2407   12B7 7D          FRENUM: LD      A,L             ; Get LSB of end
2408   12B8 93                  SUB     E               ; Subtract LSB of beginning
2409   12B9 4F                  LD      C,A             ; Save difference if C
2410   12BA 7C                  LD      A,H             ; Get MSB of end
2411   12BB 9A                  SBC     A,D             ; Subtract MSB of beginning
2412   12BC 41          ACPASS: LD      B,C             ; Return integer AC
2413   12BD 50          ABPASS: LD      D,B             ; Return integer AB
2414   12BE 1E 00               LD      E,0
2415   12C0 21 CD 21            LD      HL,TYPE         ; Point to type
2416   12C3 73                  LD      (HL),E          ; Set type to numeric
2417   12C4 06 90               LD      B,80H+16        ; 16 bit integer
2418   12C6 C3 FB 18            JP      RETINT          ; Return the integr
2419   12C9             
2420   12C9 3A CB 21    POS:    LD      A,(CURPOS)      ; Get cursor position
2421   12CC 47          PASSA:  LD      B,A             ; Put A into AB
2422   12CD AF                  XOR     A               ; Zero A
2423   12CE C3 BD 12            JP      ABPASS          ; Return integer AB
2424   12D1             
2425   12D1 CD 54 13    DEF:    CALL    CHEKFN          ; Get "FN" and name
2426   12D4 CD 46 13            CALL    IDTEST          ; Test for illegal direct
2427   12D7 01 2C 0C            LD      BC,DATA         ; To get next statement
2428   12DA C5                  PUSH    BC              ; Save address for RETurn
2429   12DB D5                  PUSH    DE              ; Save address of function ptr
2430   12DC CD 0B 09            CALL    CHKSYN          ; Make sure "(" follows
2431   12DF 28                  .BYTE      "("
2432   12E0 CD F8 10            CALL    GETVAR          ; Get argument variable name
2433   12E3 E5                  PUSH    HL              ; Save code string address
2434   12E4 EB                  EX      DE,HL           ; Argument address to HL
2435   12E5 2B                  DEC     HL
2436   12E6 56                  LD      D,(HL)          ; Get first byte of arg name
2437   12E7 2B                  DEC     HL
2438   12E8 5E                  LD      E,(HL)          ; Get second byte of arg name
2439   12E9 E1                  POP     HL              ; Restore code string address
2440   12EA CD 05 0F            CALL    TSTNUM          ; Make sure numeric argument
2441   12ED CD 0B 09            CALL    CHKSYN          ; Make sure ")" follows
2442   12F0 29                  .BYTE      ")"
2443   12F1 CD 0B 09            CALL    CHKSYN          ; Make sure "=" follows
2444   12F4 B4                  .BYTE      ZEQUAL          ; "=" token
2445   12F5 44                  LD      B,H             ; Code string address to BC
2446   12F6 4D                  LD      C,L
2447   12F7 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2448   12F8 71                  LD      (HL),C          ; Save LSB of FN code string
2449   12F9 23                  INC     HL
2450   12FA 70                  LD      (HL),B          ; Save MSB of FN code string
2451   12FB C3 93 13            JP      SVSTAD          ; Save address and do function
2452   12FE             
2453   12FE CD 54 13    DOFN:   CALL    CHEKFN          ; Make sure FN follows
2454   1301 D5                  PUSH    DE              ; Save function pointer address
2455   1302 CD D9 0F            CALL    EVLPAR          ; Evaluate expression in "()"
2456   1305 CD 05 0F            CALL    TSTNUM          ; Make sure numeric result
2457   1308 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2458   1309 5E                  LD      E,(HL)          ; Get LSB of FN code string
2459   130A 23                  INC     HL
2460   130B 56                  LD      D,(HL)          ; Get MSB of FN code string
2461   130C 23                  INC     HL
2462   130D 7A                  LD      A,D             ; And function DEFined?
2463   130E B3                  OR      E
2464   130F CA 49 06            JP      Z,UFERR         ; No - ?UF Error
2465   1312 7E                  LD      A,(HL)          ; Get LSB of argument address
2466   1313 23                  INC     HL
2467   1314 66                  LD      H,(HL)          ; Get MSB of argument address
2468   1315 6F                  LD      L,A             ; HL = Arg variable address
2469   1316 E5                  PUSH    HL              ; Save it
2470   1317 2A FE 21            LD      HL,(FNRGNM)     ; Get old argument name
2471   131A E3                  EX      (SP),HL ;       ; Save old , Get new
2472   131B 22 FE 21            LD      (FNRGNM),HL     ; Set new argument name
2473   131E 2A 02 22            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2474   1321 E5                  PUSH    HL              ; Save it
2475   1322 2A 00 22            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2476   1325 E5                  PUSH    HL              ; Save it
2477   1326 21 00 22            LD      HL,FNARG        ; HL = Value of argument
2478   1329 D5                  PUSH    DE              ; Save FN code string address
2479   132A CD 3C 19            CALL    FPTHL           ; Move FPREG to argument
2480   132D E1                  POP     HL              ; Get FN code string address
2481   132E CD 02 0F            CALL    GETNUM          ; Get value from function
2482   1331 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2483   1332 CD 95 0A            CALL    GETCHR          ; Get next character
2484   1335 C2 3D 06            JP      NZ,SNERR        ; Bad character in FN - Error
2485   1338 E1                  POP     HL              ; Get MSB,EXP of old arg
2486   1339 22 00 22            LD      (FNARG),HL      ; Restore it
2487   133C E1                  POP     HL              ; Get LSB,NLSB of old arg
2488   133D 22 02 22            LD      (FNARG+2),HL    ; Restore it
2489   1340 E1                  POP     HL              ; Get name of old arg
2490   1341 22 FE 21            LD      (FNRGNM),HL     ; Restore it
2491   1344 E1                  POP     HL              ; Restore code string address
2492   1345 C9                  RET
2493   1346             
2494   1346 E5          IDTEST: PUSH    HL              ; Save code string address
2495   1347 2A 7C 21            LD      HL,(LINEAT)     ; Get current line number
2496   134A 23                  INC     HL              ; -1 means direct statement
2497   134B 7C                  LD      A,H
2498   134C B5                  OR      L
2499   134D E1                  POP     HL              ; Restore code string address
2500   134E C0                  RET     NZ              ; Return if in program
2501   134F 1E 16               LD      E,ID            ; ?ID Error
2502   1351 C3 51 06            JP      ERROR
2503   1354             
2504   1354 CD 0B 09    CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2505   1357 A7                  .BYTE      ZFN             ; "FN" token
2506   1358 3E 80               LD      A,80H
2507   135A 32 EB 21            LD      (FORFLG),A      ; Flag FN name to find
2508   135D B6                  OR      (HL)            ; FN name has bit 7 set
2509   135E 47                  LD      B,A             ; in first byte of name
2510   135F CD FD 10            CALL    GTFNAM          ; Get FN name
2511   1362 C3 05 0F            JP      TSTNUM          ; Make sure numeric function
2512   1365             
2513   1365 CD 05 0F    STR:    CALL    TSTNUM          ; Make sure it's a number
2514   1368 CD 89 1A            CALL    NUMASC          ; Turn number into text
2515   136B CD 99 13    STR1:   CALL    CRTST           ; Create string entry for it
2516   136E CD 1E 15            CALL    GSTRCU          ; Current string to pool
2517   1371 01 79 15            LD      BC,TOPOOL       ; Save in string pool
2518   1374 C5                  PUSH    BC              ; Save address on stack
2519   1375             
2520   1375 7E          SAVSTR: LD      A,(HL)          ; Get string length
2521   1376 23                  INC     HL
2522   1377 23                  INC     HL
2523   1378 E5                  PUSH    HL              ; Save pointer to string
2524   1379 CD F4 13            CALL    TESTR           ; See if enough string space
2525   137C E1                  POP     HL              ; Restore pointer to string
2526   137D 4E                  LD      C,(HL)          ; Get LSB of address
2527   137E 23                  INC     HL
2528   137F 46                  LD      B,(HL)          ; Get MSB of address
2529   1380 CD 8D 13            CALL    CRTMST          ; Create string entry
2530   1383 E5                  PUSH    HL              ; Save pointer to MSB of addr
2531   1384 6F                  LD      L,A             ; Length of string
2532   1385 CD 11 15            CALL    TOSTRA          ; Move to string area
2533   1388 D1                  POP     DE              ; Restore pointer to MSB
2534   1389 C9                  RET
2535   138A             
2536   138A CD F4 13    MKTMST: CALL    TESTR           ; See if enough string space
2537   138D 21 DF 21    CRTMST: LD      HL,TMPSTR       ; Temporary string
2538   1390 E5                  PUSH    HL              ; Save it
2539   1391 77                  LD      (HL),A          ; Save length of string
2540   1392 23                  INC     HL
2541   1393 23          SVSTAD: INC     HL
2542   1394 73                  LD      (HL),E          ; Save LSB of address
2543   1395 23                  INC     HL
2544   1396 72                  LD      (HL),D          ; Save MSB of address
2545   1397 E1                  POP     HL              ; Restore pointer
2546   1398 C9                  RET
2547   1399             
2548   1399 2B          CRTST:  DEC     HL              ; DEC - INCed after
2549   139A 06 22       QTSTR:  LD      B,'"'           ; Terminating quote
2550   139C 50                  LD      D,B             ; Quote to D
2551   139D E5          DTSTR:  PUSH    HL              ; Save start
2552   139E 0E FF               LD      C,-1            ; Set counter to -1
2553   13A0 23          QTSTLP: INC     HL              ; Move on
2554   13A1 7E                  LD      A,(HL)          ; Get byte
2555   13A2 0C                  INC     C               ; Count bytes
2556   13A3 B7                  OR      A               ; End of line?
2557   13A4 CA AF 13            JP      Z,CRTSTE        ; Yes - Create string entry
2558   13A7 BA                  CP      D               ; Terminator D found?
2559   13A8 CA AF 13            JP      Z,CRTSTE        ; Yes - Create string entry
2560   13AB B8                  CP      B               ; Terminator B found?
2561   13AC C2 A0 13            JP      NZ,QTSTLP       ; No - Keep looking
2562   13AF FE 22       CRTSTE: CP      '"'             ; End with '"'?
2563   13B1 CC 95 0A            CALL    Z,GETCHR        ; Yes - Get next character
2564   13B4 E3                  EX      (SP),HL         ; Starting quote
2565   13B5 23                  INC     HL              ; First byte of string
2566   13B6 EB                  EX      DE,HL           ; To DE
2567   13B7 79                  LD      A,C             ; Get length
2568   13B8 CD 8D 13            CALL    CRTMST          ; Create string entry
2569   13BB 11 DF 21    TSTOPL: LD      DE,TMPSTR       ; Temporary string
2570   13BE 2A D1 21            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2571   13C1 22 04 22            LD      (FPREG),HL      ; Save address of string ptr
2572   13C4 3E 01               LD      A,1
2573   13C6 32 CD 21            LD      (TYPE),A        ; Set type to string
2574   13C9 CD 3F 19            CALL    DETHL4          ; Move string to pool
2575   13CC CD 05 09            CALL    CPDEHL          ; Out of string pool?
2576   13CF 22 D1 21            LD      (TMSTPT),HL     ; Save new pointer
2577   13D2 E1                  POP     HL              ; Restore code string address
2578   13D3 7E                  LD      A,(HL)          ; Get next code byte
2579   13D4 C0                  RET     NZ              ; Return if pool OK
2580   13D5 1E 1E               LD      E,ST            ; ?ST Error
2581   13D7 C3 51 06            JP      ERROR           ; String pool overflow
2582   13DA             
2583   13DA 23          PRNUMS: INC     HL              ; Skip leading space
2584   13DB CD 99 13    PRS:    CALL    CRTST           ; Create string entry for it
2585   13DE CD 1E 15    PRS1:   CALL    GSTRCU          ; Current string to pool
2586   13E1 CD 33 19            CALL    LOADFP          ; Move string block to BCDE
2587   13E4 1C                  INC     E               ; Length + 1
2588   13E5 1D          PRSLP:  DEC     E               ; Count characters
2589   13E6 C8                  RET     Z               ; End of string
2590   13E7 0A                  LD      A,(BC)          ; Get byte to output
2591   13E8 CD 16 09            CALL    OUTC            ; Output character in A
2592   13EB FE 0D               CP      CR              ; Return?
2593   13ED CC 47 0D            CALL    Z,DONULL        ; Yes - Do nulls
2594   13F0 03                  INC     BC              ; Next byte in string
2595   13F1 C3 E5 13            JP      PRSLP           ; More characters to output
2596   13F4             
2597   13F4 B7          TESTR:  OR      A               ; Test if enough room
2598   13F5 0E                  .BYTE      0EH             ; No garbage collection done
2599   13F6 F1          GRBDON: POP     AF              ; Garbage collection done
2600   13F7 F5                  PUSH    AF              ; Save status
2601   13F8 2A 7A 21            LD      HL,(STRSPC)     ; Bottom of string space in use
2602   13FB EB                  EX      DE,HL           ; To DE
2603   13FC 2A E3 21            LD      HL,(STRBOT)     ; Bottom of string area
2604   13FF 2F                  CPL                     ; Negate length (Top down)
2605   1400 4F                  LD      C,A             ; -Length to BC
2606   1401 06 FF               LD      B,-1            ; BC = -ve length of string
2607   1403 09                  ADD     HL,BC           ; Add to bottom of space in use
2608   1404 23                  INC     HL              ; Plus one for 2's complement
2609   1405 CD 05 09            CALL    CPDEHL          ; Below string RAM area?
2610   1408 DA 12 14            JP      C,TESTOS        ; Tidy up if not done else err
2611   140B 22 E3 21            LD      (STRBOT),HL     ; Save new bottom of area
2612   140E 23                  INC     HL              ; Point to first byte of string
2613   140F EB                  EX      DE,HL           ; Address to DE
2614   1410 F1          POPAF:  POP     AF              ; Throw away status push
2615   1411 C9                  RET
2616   1412             
2617   1412 F1          TESTOS: POP     AF              ; Garbage collect been done?
2618   1413 1E 1A               LD      E,OS            ; ?OS Error
2619   1415 CA 51 06            JP      Z,ERROR         ; Yes - Not enough string apace
2620   1418 BF                  CP      A               ; Flag garbage collect done
2621   1419 F5                  PUSH    AF              ; Save status
2622   141A 01 F6 13            LD      BC,GRBDON       ; Garbage collection done
2623   141D C5                  PUSH    BC              ; Save for RETurn
2624   141E 2A CF 21    GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2625   1421 22 E3 21    GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2626   1424 21 00 00            LD      HL,0
2627   1427 E5                  PUSH    HL              ; Flag no string found
2628   1428 2A 7A 21            LD      HL,(STRSPC)     ; Get bottom of string space
2629   142B E5                  PUSH    HL              ; Save bottom of string space
2630   142C 21 D3 21            LD      HL,TMSTPL       ; Temporary string pool
2631   142F EB          GRBLP:  EX      DE,HL
2632   1430 2A D1 21            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2633   1433 EB                  EX      DE,HL
2634   1434 CD 05 09            CALL    CPDEHL          ; Temporary string pool done?
2635   1437 01 2F 14            LD      BC,GRBLP        ; Loop until string pool done
2636   143A C2 83 14            JP      NZ,STPOOL       ; No - See if in string area
2637   143D 2A F6 21            LD      HL,(PROGND)     ; Start of simple variables
2638   1440 EB          SMPVAR: EX      DE,HL
2639   1441 2A F8 21            LD      HL,(VAREND)     ; End of simple variables
2640   1444 EB                  EX      DE,HL
2641   1445 CD 05 09            CALL    CPDEHL          ; All simple strings done?
2642   1448 CA 56 14            JP      Z,ARRLP         ; Yes - Do string arrays
2643   144B 7E                  LD      A,(HL)          ; Get type of variable
2644   144C 23                  INC     HL
2645   144D 23                  INC     HL
2646   144E B7                  OR      A               ; "S" flag set if string
2647   144F CD 86 14            CALL    STRADD          ; See if string in string area
2648   1452 C3 40 14            JP      SMPVAR          ; Loop until simple ones done
2649   1455             
2650   1455 C1          GNXARY: POP     BC              ; Scrap address of this array
2651   1456 EB          ARRLP:  EX      DE,HL
2652   1457 2A FA 21            LD      HL,(ARREND)     ; End of string arrays
2653   145A EB                  EX      DE,HL
2654   145B CD 05 09            CALL    CPDEHL          ; All string arrays done?
2655   145E CA AC 14            JP      Z,SCNEND        ; Yes - Move string if found
2656   1461 CD 33 19            CALL    LOADFP          ; Get array name to BCDE
2657   1464 7B                  LD      A,E             ; Get type of array     
2658   1465 E5                  PUSH    HL              ; Save address of num of dim'ns
2659   1466 09                  ADD     HL,BC           ; Start of next array
2660   1467 B7                  OR      A               ; Test type of array
2661   1468 F2 55 14            JP      P,GNXARY        ; Numeric array - Ignore it
2662   146B 22 E5 21            LD      (CUROPR),HL     ; Save address of next array
2663   146E E1                  POP     HL              ; Get address of num of dim'ns
2664   146F 4E                  LD      C,(HL)          ; BC = Number of dimensions
2665   1470 06 00               LD      B,0
2666   1472 09                  ADD     HL,BC           ; Two bytes per dimension size
2667   1473 09                  ADD     HL,BC
2668   1474 23                  INC     HL              ; Plus one for number of dim'ns
2669   1475 EB          GRBARY: EX      DE,HL
2670   1476 2A E5 21            LD      HL,(CUROPR)     ; Get address of next array
2671   1479 EB                  EX      DE,HL
2672   147A CD 05 09            CALL    CPDEHL          ; Is this array finished?
2673   147D CA 56 14            JP      Z,ARRLP         ; Yes - Get next one
2674   1480 01 75 14            LD      BC,GRBARY       ; Loop until array all done
2675   1483 C5          STPOOL: PUSH    BC              ; Save return address
2676   1484 F6 80               OR      80H             ; Flag string type
2677   1486 7E          STRADD: LD      A,(HL)          ; Get string length
2678   1487 23                  INC     HL
2679   1488 23                  INC     HL
2680   1489 5E                  LD      E,(HL)          ; Get LSB of string address
2681   148A 23                  INC     HL
2682   148B 56                  LD      D,(HL)          ; Get MSB of string address
2683   148C 23                  INC     HL
2684   148D F0                  RET     P               ; Not a string - Return
2685   148E B7                  OR      A               ; Set flags on string length
2686   148F C8                  RET     Z               ; Null string - Return
2687   1490 44                  LD      B,H             ; Save variable pointer
2688   1491 4D                  LD      C,L
2689   1492 2A E3 21            LD      HL,(STRBOT)     ; Bottom of new area
2690   1495 CD 05 09            CALL    CPDEHL          ; String been done?
2691   1498 60                  LD      H,B             ; Restore variable pointer
2692   1499 69                  LD      L,C
2693   149A D8                  RET     C               ; String done - Ignore
2694   149B E1                  POP     HL              ; Return address
2695   149C E3                  EX      (SP),HL         ; Lowest available string area
2696   149D CD 05 09            CALL    CPDEHL          ; String within string area?
2697   14A0 E3                  EX      (SP),HL         ; Lowest available string area
2698   14A1 E5                  PUSH    HL              ; Re-save return address
2699   14A2 60                  LD      H,B             ; Restore variable pointer
2700   14A3 69                  LD      L,C
2701   14A4 D0                  RET     NC              ; Outside string area - Ignore
2702   14A5 C1                  POP     BC              ; Get return , Throw 2 away
2703   14A6 F1                  POP     AF              ; 
2704   14A7 F1                  POP     AF              ; 
2705   14A8 E5                  PUSH    HL              ; Save variable pointer
2706   14A9 D5                  PUSH    DE              ; Save address of current
2707   14AA C5                  PUSH    BC              ; Put back return address
2708   14AB C9                  RET                     ; Go to it
2709   14AC             
2710   14AC D1          SCNEND: POP     DE              ; Addresses of strings
2711   14AD E1                  POP     HL              ; 
2712   14AE 7D                  LD      A,L             ; HL = 0 if no more to do
2713   14AF B4                  OR      H
2714   14B0 C8                  RET     Z               ; No more to do - Return
2715   14B1 2B                  DEC     HL
2716   14B2 46                  LD      B,(HL)          ; MSB of address of string
2717   14B3 2B                  DEC     HL
2718   14B4 4E                  LD      C,(HL)          ; LSB of address of string
2719   14B5 E5                  PUSH    HL              ; Save variable address
2720   14B6 2B                  DEC     HL
2721   14B7 2B                  DEC     HL
2722   14B8 6E                  LD      L,(HL)          ; HL = Length of string
2723   14B9 26 00               LD      H,0
2724   14BB 09                  ADD     HL,BC           ; Address of end of string+1
2725   14BC 50                  LD      D,B             ; String address to DE
2726   14BD 59                  LD      E,C
2727   14BE 2B                  DEC     HL              ; Last byte in string
2728   14BF 44                  LD      B,H             ; Address to BC
2729   14C0 4D                  LD      C,L
2730   14C1 2A E3 21            LD      HL,(STRBOT)     ; Current bottom of string area
2731   14C4 CD 0C 06            CALL    MOVSTR          ; Move string to new address
2732   14C7 E1                  POP     HL              ; Restore variable address
2733   14C8 71                  LD      (HL),C          ; Save new LSB of address
2734   14C9 23                  INC     HL
2735   14CA 70                  LD      (HL),B          ; Save new MSB of address
2736   14CB 69                  LD      L,C             ; Next string area+1 to HL
2737   14CC 60                  LD      H,B
2738   14CD 2B                  DEC     HL              ; Next string area address
2739   14CE C3 21 14            JP      GARBLP          ; Look for more strings
2740   14D1             
2741   14D1 C5          CONCAT: PUSH    BC              ; Save prec' opr & code string
2742   14D2 E5                  PUSH    HL              ; 
2743   14D3 2A 04 22            LD      HL,(FPREG)      ; Get first string
2744   14D6 E3                  EX      (SP),HL         ; Save first string
2745   14D7 CD 8B 0F            CALL    OPRND           ; Get second string
2746   14DA E3                  EX      (SP),HL         ; Restore first string
2747   14DB CD 06 0F            CALL    TSTSTR          ; Make sure it's a string
2748   14DE 7E                  LD      A,(HL)          ; Get length of second string
2749   14DF E5                  PUSH    HL              ; Save first string
2750   14E0 2A 04 22            LD      HL,(FPREG)      ; Get second string
2751   14E3 E5                  PUSH    HL              ; Save second string
2752   14E4 86                  ADD     A,(HL)          ; Add length of second string
2753   14E5 1E 1C               LD      E,LS            ; ?LS Error
2754   14E7 DA 51 06            JP      C,ERROR         ; String too long - Error
2755   14EA CD 8A 13            CALL    MKTMST          ; Make temporary string
2756   14ED D1                  POP     DE              ; Get second string to DE
2757   14EE CD 22 15            CALL    GSTRDE          ; Move to string pool if needed
2758   14F1 E3                  EX      (SP),HL         ; Get first string
2759   14F2 CD 21 15            CALL    GSTRHL          ; Move to string pool if needed
2760   14F5 E5                  PUSH    HL              ; Save first string
2761   14F6 2A E1 21            LD      HL,(TMPSTR+2)   ; Temporary string address
2762   14F9 EB                  EX      DE,HL           ; To DE
2763   14FA CD 08 15            CALL    SSTSA           ; First string to string area
2764   14FD CD 08 15            CALL    SSTSA           ; Second string to string area
2765   1500 21 20 0F            LD      HL,EVAL2        ; Return to evaluation loop
2766   1503 E3                  EX      (SP),HL         ; Save return,get code string
2767   1504 E5                  PUSH    HL              ; Save code string address
2768   1505 C3 BB 13            JP      TSTOPL          ; To temporary string to pool
2769   1508             
2770   1508 E1          SSTSA:  POP     HL              ; Return address
2771   1509 E3                  EX      (SP),HL         ; Get string block,save return
2772   150A 7E                  LD      A,(HL)          ; Get length of string
2773   150B 23                  INC     HL
2774   150C 23                  INC     HL
2775   150D 4E                  LD      C,(HL)          ; Get LSB of string address
2776   150E 23                  INC     HL
2777   150F 46                  LD      B,(HL)          ; Get MSB of string address
2778   1510 6F                  LD      L,A             ; Length to L
2779   1511 2C          TOSTRA: INC     L               ; INC - DECed after
2780   1512 2D          TSALP:  DEC     L               ; Count bytes moved
2781   1513 C8                  RET     Z               ; End of string - Return
2782   1514 0A                  LD      A,(BC)          ; Get source
2783   1515 12                  LD      (DE),A          ; Save destination
2784   1516 03                  INC     BC              ; Next source
2785   1517 13                  INC     DE              ; Next destination
2786   1518 C3 12 15            JP      TSALP           ; Loop until string moved
2787   151B             
2788   151B CD 06 0F    GETSTR: CALL    TSTSTR          ; Make sure it's a string
2789   151E 2A 04 22    GSTRCU: LD      HL,(FPREG)      ; Get current string
2790   1521 EB          GSTRHL: EX      DE,HL           ; Save DE
2791   1522 CD 3C 15    GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2792   1525 EB                  EX      DE,HL           ; Restore DE
2793   1526 C0                  RET     NZ              ; No - Return
2794   1527 D5                  PUSH    DE              ; Save string
2795   1528 50                  LD      D,B             ; String block address to DE
2796   1529 59                  LD      E,C
2797   152A 1B                  DEC     DE              ; Point to length
2798   152B 4E                  LD      C,(HL)          ; Get string length
2799   152C 2A E3 21            LD      HL,(STRBOT)     ; Current bottom of string area
2800   152F CD 05 09            CALL    CPDEHL          ; Last one in string area?
2801   1532 C2 3A 15            JP      NZ,POPHL        ; No - Return
2802   1535 47                  LD      B,A             ; Clear B (A=0)
2803   1536 09                  ADD     HL,BC           ; Remove string from str' area
2804   1537 22 E3 21            LD      (STRBOT),HL     ; Save new bottom of str' area
2805   153A E1          POPHL:  POP     HL              ; Restore string
2806   153B C9                  RET
2807   153C             
2808   153C 2A D1 21    BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2809   153F 2B                  DEC     HL              ; Back
2810   1540 46                  LD      B,(HL)          ; Get MSB of address
2811   1541 2B                  DEC     HL              ; Back
2812   1542 4E                  LD      C,(HL)          ; Get LSB of address
2813   1543 2B                  DEC     HL              ; Back
2814   1544 2B                  DEC     HL              ; Back
2815   1545 CD 05 09            CALL    CPDEHL          ; String last in string pool?
2816   1548 C0                  RET     NZ              ; Yes - Leave it
2817   1549 22 D1 21            LD      (TMSTPT),HL     ; Save new string pool top
2818   154C C9                  RET
2819   154D             
2820   154D 01 CC 12    LEN:    LD      BC,PASSA        ; To return integer A
2821   1550 C5                  PUSH    BC              ; Save address
2822   1551 CD 1B 15    GETLEN: CALL    GETSTR          ; Get string and its length
2823   1554 AF                  XOR     A
2824   1555 57                  LD      D,A             ; Clear D
2825   1556 32 CD 21            LD      (TYPE),A        ; Set type to numeric
2826   1559 7E                  LD      A,(HL)          ; Get length of string
2827   155A B7                  OR      A               ; Set status flags
2828   155B C9                  RET
2829   155C             
2830   155C 01 CC 12    ASC:    LD      BC,PASSA        ; To return integer A
2831   155F C5                  PUSH    BC              ; Save address
2832   1560 CD 51 15    GTFLNM: CALL    GETLEN          ; Get length of string
2833   1563 CA 5C 0B            JP      Z,FCERR         ; Null string - Error
2834   1566 23                  INC     HL
2835   1567 23                  INC     HL
2836   1568 5E                  LD      E,(HL)          ; Get LSB of address
2837   1569 23                  INC     HL
2838   156A 56                  LD      D,(HL)          ; Get MSB of address
2839   156B 1A                  LD      A,(DE)          ; Get first byte of string
2840   156C C9                  RET
2841   156D             
2842   156D 3E 01       CHR:    LD      A,1             ; One character string
2843   156F CD 8A 13            CALL    MKTMST          ; Make a temporary string
2844   1572 CD 66 16            CALL    MAKINT          ; Make it integer A
2845   1575 2A E1 21            LD      HL,(TMPSTR+2)   ; Get address of string
2846   1578 73                  LD      (HL),E          ; Save character
2847   1579 C1          TOPOOL: POP     BC              ; Clean up stack
2848   157A C3 BB 13            JP      TSTOPL          ; Temporary string to pool
2849   157D             
2850   157D CD 16 16    LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2851   1580 AF                  XOR     A               ; Start at first byte in string
2852   1581 E3          RIGHT1: EX      (SP),HL         ; Save code string,Get string
2853   1582 4F                  LD      C,A             ; Starting position in string
2854   1583 E5          MID1:   PUSH    HL              ; Save string block address
2855   1584 7E                  LD      A,(HL)          ; Get length of string
2856   1585 B8                  CP      B               ; Compare with number given
2857   1586 DA 8B 15            JP      C,ALLFOL        ; All following bytes required
2858   1589 78                  LD      A,B             ; Get new length
2859   158A 11                  .BYTE      11H             ; Skip "LD C,0"
2860   158B 0E 00       ALLFOL: LD      C,0             ; First byte of string
2861   158D C5                  PUSH    BC              ; Save position in string
2862   158E CD F4 13            CALL    TESTR           ; See if enough string space
2863   1591 C1                  POP     BC              ; Get position in string
2864   1592 E1                  POP     HL              ; Restore string block address
2865   1593 E5                  PUSH    HL              ; And re-save it
2866   1594 23                  INC     HL
2867   1595 23                  INC     HL
2868   1596 46                  LD      B,(HL)          ; Get LSB of address
2869   1597 23                  INC     HL
2870   1598 66                  LD      H,(HL)          ; Get MSB of address
2871   1599 68                  LD      L,B             ; HL = address of string
2872   159A 06 00               LD      B,0             ; BC = starting address
2873   159C 09                  ADD     HL,BC           ; Point to that byte
2874   159D 44                  LD      B,H             ; BC = source string
2875   159E 4D                  LD      C,L
2876   159F CD 8D 13            CALL    CRTMST          ; Create a string entry
2877   15A2 6F                  LD      L,A             ; Length of new string
2878   15A3 CD 11 15            CALL    TOSTRA          ; Move string to string area
2879   15A6 D1                  POP     DE              ; Clear stack
2880   15A7 CD 22 15            CALL    GSTRDE          ; Move to string pool if needed
2881   15AA C3 BB 13            JP      TSTOPL          ; Temporary string to pool
2882   15AD             
2883   15AD CD 16 16    RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2884   15B0 D1                  POP     DE              ; Get string length
2885   15B1 D5                  PUSH    DE              ; And re-save
2886   15B2 1A                  LD      A,(DE)          ; Get length
2887   15B3 90                  SUB     B               ; Move back N bytes
2888   15B4 C3 81 15            JP      RIGHT1          ; Go and get sub-string
2889   15B7             
2890   15B7 EB          MID:    EX      DE,HL           ; Get code string address
2891   15B8 7E                  LD      A,(HL)          ; Get next byte ',' or ")"
2892   15B9 CD 1B 16            CALL    MIDNUM          ; Get number supplied
2893   15BC 04                  INC     B               ; Is it character zero?
2894   15BD 05                  DEC     B
2895   15BE CA 5C 0B            JP      Z,FCERR         ; Yes - Error
2896   15C1 C5                  PUSH    BC              ; Save starting position
2897   15C2 1E FF               LD      E,255           ; All of string
2898   15C4 FE 29               CP      ')'             ; Any length given?
2899   15C6 CA D0 15            JP      Z,RSTSTR        ; No - Rest of string
2900   15C9 CD 0B 09            CALL    CHKSYN          ; Make sure ',' follows
2901   15CC 2C                  .BYTE      ','
2902   15CD CD 63 16            CALL    GETINT          ; Get integer 0-255
2903   15D0 CD 0B 09    RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2904   15D3 29                  .BYTE      ")"
2905   15D4 F1                  POP     AF              ; Restore starting position
2906   15D5 E3                  EX      (SP),HL         ; Get string,8ave code string
2907   15D6 01 83 15            LD      BC,MID1         ; Continuation of MID$ routine
2908   15D9 C5                  PUSH    BC              ; Save for return
2909   15DA 3D                  DEC     A               ; Starting position-1
2910   15DB BE                  CP      (HL)            ; Compare with length
2911   15DC 06 00               LD      B,0             ; Zero bytes length
2912   15DE D0                  RET     NC              ; Null string if start past end
2913   15DF 4F                  LD      C,A             ; Save starting position-1
2914   15E0 7E                  LD      A,(HL)          ; Get length of string
2915   15E1 91                  SUB     C               ; Subtract start
2916   15E2 BB                  CP      E               ; Enough string for it?
2917   15E3 47                  LD      B,A             ; Save maximum length available
2918   15E4 D8                  RET     C               ; Truncate string if needed
2919   15E5 43                  LD      B,E             ; Set specified length
2920   15E6 C9                  RET                     ; Go and create string
2921   15E7             
2922   15E7 CD 51 15    VAL:    CALL    GETLEN          ; Get length of string
2923   15EA CA 04 17            JP      Z,RESZER        ; Result zero
2924   15ED 5F                  LD      E,A             ; Save length
2925   15EE 23                  INC     HL
2926   15EF 23                  INC     HL
2927   15F0 7E                  LD      A,(HL)          ; Get LSB of address
2928   15F1 23                  INC     HL
2929   15F2 66                  LD      H,(HL)          ; Get MSB of address
2930   15F3 6F                  LD      L,A             ; HL = String address
2931   15F4 E5                  PUSH    HL              ; Save string address
2932   15F5 19                  ADD     HL,DE
2933   15F6 46                  LD      B,(HL)          ; Get end of string+1 byte
2934   15F7 72                  LD      (HL),D          ; Zero it to terminate
2935   15F8 E3                  EX      (SP),HL         ; Save string end,get start
2936   15F9 C5                  PUSH    BC              ; Save end+1 byte
2937   15FA 7E                  LD      A,(HL)          ; Get starting byte
2938   15FB FE 24           CP	'$'		; Hex number indicated? [function added]
2939   15FD C2 05 16        JP	NZ,VAL1
2940   1600 CD 2F 1E        CALL	HEXTFP		; Convert Hex to FPREG
2941   1603 18 0D           JR	VAL3
2942   1605 FE 25       VAL1:	CP	'%'		; Binary number indicated? [function added]
2943   1607 C2 0F 16        JP	NZ,VAL2
2944   160A CD 9F 1E        CALL	BINTFP		; Convert Bin to FPREG
2945   160D 18 03           JR	VAL3
2946   160F CD EB 19    VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2947   1612 C1          VAL3:   POP     BC              ; Restore end+1 byte
2948   1613 E1                  POP     HL              ; Restore end+1 address
2949   1614 70                  LD      (HL),B          ; Put back original byte
2950   1615 C9                  RET
2951   1616             
2952   1616 EB          LFRGNM: EX      DE,HL           ; Code string address to HL
2953   1617 CD 0B 09            CALL    CHKSYN          ; Make sure ")" follows
2954   161A 29                  .BYTE      ")"
2955   161B C1          MIDNUM: POP     BC              ; Get return address
2956   161C D1                  POP     DE              ; Get number supplied
2957   161D C5                  PUSH    BC              ; Re-save return address
2958   161E 43                  LD      B,E             ; Number to B
2959   161F C9                  RET
2960   1620             
2961   1620 CD 66 16    INP:    CALL    MAKINT          ; Make it integer A
2962   1623 32 5F 21            LD      (INPORT),A      ; Set input port
2963   1626 CD 5E 21            CALL    INPSUB          ; Get input from port
2964   1629 C3 CC 12            JP      PASSA           ; Return integer A
2965   162C             
2966   162C CD 50 16    POUT:   CALL    SETIO           ; Set up port number
2967   162F C3 26 21            JP      OUTSUB          ; Output data and return
2968   1632             
2969   1632 CD 50 16    WAIT:   CALL    SETIO           ; Set up port number
2970   1635 F5                  PUSH    AF              ; Save AND mask
2971   1636 1E 00               LD      E,0             ; Assume zero if none given
2972   1638 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2973   1639 CD 95 0A            CALL    GETCHR          ; Get next character
2974   163C CA 46 16            JP      Z,NOXOR         ; No XOR byte given
2975   163F CD 0B 09            CALL    CHKSYN          ; Make sure ',' follows
2976   1642 2C                  .BYTE      ','
2977   1643 CD 63 16            CALL    GETINT          ; Get integer 0-255 to XOR with
2978   1646 C1          NOXOR:  POP     BC              ; Restore AND mask
2979   1647 CD 5E 21    WAITLP: CALL    INPSUB          ; Get input
2980   164A AB                  XOR     E               ; Flip selected bits
2981   164B A0                  AND     B               ; Result non-zero?
2982   164C CA 47 16            JP      Z,WAITLP        ; No = keep waiting
2983   164F C9                  RET
2984   1650             
2985   1650 CD 63 16    SETIO:  CALL    GETINT          ; Get integer 0-255
2986   1653 32 5F 21            LD      (INPORT),A      ; Set input port
2987   1656 32 27 21            LD      (OTPORT),A      ; Set output port
2988   1659 CD 0B 09            CALL    CHKSYN          ; Make sure ',' follows
2989   165C 2C                  .BYTE      ','
2990   165D C3 63 16            JP      GETINT          ; Get integer 0-255 and return
2991   1660             
2992   1660 CD 95 0A    FNDNUM: CALL    GETCHR          ; Get next character
2993   1663 CD 02 0F    GETINT: CALL    GETNUM          ; Get a number from 0 to 255
2994   1666 CD 41 0B    MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
2995   1669 7A                  LD      A,D             ; Get MSB of number
2996   166A B7                  OR      A               ; Zero?
2997   166B C2 5C 0B            JP      NZ,FCERR        ; No - Error
2998   166E 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2999   166F CD 95 0A            CALL    GETCHR          ; Get next character
3000   1672 7B                  LD      A,E             ; Get number to A
3001   1673 C9                  RET
3002   1674             
3003   1674 CD 47 0B    PEEK:   CALL    DEINT           ; Get memory address
3004   1677 1A                  LD      A,(DE)          ; Get byte in memory
3005   1678 C3 CC 12            JP      PASSA           ; Return integer A
3006   167B             
3007   167B CD 02 0F    POKE:   CALL    GETNUM          ; Get memory address
3008   167E CD 47 0B            CALL    DEINT           ; Get integer -32768 to 3276
3009   1681 D5                  PUSH    DE              ; Save memory address
3010   1682 CD 0B 09            CALL    CHKSYN          ; Make sure ',' follows
3011   1685 2C                  .BYTE      ','
3012   1686 CD 63 16            CALL    GETINT          ; Get integer 0-255
3013   1689 D1                  POP     DE              ; Restore memory address
3014   168A 12                  LD      (DE),A          ; Load it into memory
3015   168B C9                  RET
3016   168C             
3017   168C 21 62 1B    ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3018   168F CD 33 19    ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3019   1692 C3 9E 16            JP      FPADD           ; Add BCDE to FPREG
3020   1695             
3021   1695 CD 33 19    SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3022   1698 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3023   1699 C1          PSUB:   POP     BC              ; Get FP number from stack
3024   169A D1                  POP     DE
3025   169B CD 0D 19    SUBCDE: CALL    INVSGN          ; Negate FPREG
3026   169E 78          FPADD:  LD      A,B             ; Get FP exponent
3027   169F B7                  OR      A               ; Is number zero?
3028   16A0 C8                  RET     Z               ; Yes - Nothing to add
3029   16A1 3A 07 22            LD      A,(FPEXP)       ; Get FPREG exponent
3030   16A4 B7                  OR      A               ; Is this number zero?
3031   16A5 CA 25 19            JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3032   16A8 90                  SUB     B               ; BCDE number larger?
3033   16A9 D2 B8 16            JP      NC,NOSWAP       ; No - Don't swap them
3034   16AC 2F                  CPL                     ; Two's complement
3035   16AD 3C                  INC     A               ;  FP exponent
3036   16AE EB                  EX      DE,HL
3037   16AF CD 15 19            CALL    STAKFP          ; Put FPREG on stack
3038   16B2 EB                  EX      DE,HL
3039   16B3 CD 25 19            CALL    FPBCDE          ; Move BCDE to FPREG
3040   16B6 C1                  POP     BC              ; Restore number from stack
3041   16B7 D1                  POP     DE
3042   16B8 FE 19       NOSWAP: CP      24+1            ; Second number insignificant?
3043   16BA D0                  RET     NC              ; Yes - First number is result
3044   16BB F5                  PUSH    AF              ; Save number of bits to scale
3045   16BC CD 4A 19            CALL    SIGNS           ; Set MSBs & sign of result
3046   16BF 67                  LD      H,A             ; Save sign of result
3047   16C0 F1                  POP     AF              ; Restore scaling factor
3048   16C1 CD 63 17            CALL    SCALE           ; Scale BCDE to same exponent
3049   16C4 B4                  OR      H               ; Result to be positive?
3050   16C5 21 04 22            LD      HL,FPREG        ; Point to FPREG
3051   16C8 F2 DE 16            JP      P,MINCDE        ; No - Subtract FPREG from CDE
3052   16CB CD 43 17            CALL    PLUCDE          ; Add FPREG to CDE
3053   16CE D2 24 17            JP      NC,RONDUP       ; No overflow - Round it up
3054   16D1 23                  INC     HL              ; Point to exponent
3055   16D2 34                  INC     (HL)            ; Increment it
3056   16D3 CA 4C 06            JP      Z,OVERR         ; Number overflowed - Error
3057   16D6 2E 01               LD      L,1             ; 1 bit to shift right
3058   16D8 CD 79 17            CALL    SHRT1           ; Shift result right
3059   16DB C3 24 17            JP      RONDUP          ; Round it up
3060   16DE             
3061   16DE AF          MINCDE: XOR     A               ; Clear A and carry
3062   16DF 90                  SUB     B               ; Negate exponent
3063   16E0 47                  LD      B,A             ; Re-save exponent
3064   16E1 7E                  LD      A,(HL)          ; Get LSB of FPREG
3065   16E2 9B                  SBC     A, E            ; Subtract LSB of BCDE
3066   16E3 5F                  LD      E,A             ; Save LSB of BCDE
3067   16E4 23                  INC     HL
3068   16E5 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3069   16E6 9A                  SBC     A,D             ; Subtract NMSB of BCDE
3070   16E7 57                  LD      D,A             ; Save NMSB of BCDE
3071   16E8 23                  INC     HL
3072   16E9 7E                  LD      A,(HL)          ; Get MSB of FPREG
3073   16EA 99                  SBC     A,C             ; Subtract MSB of BCDE
3074   16EB 4F                  LD      C,A             ; Save MSB of BCDE
3075   16EC DC 4F 17    CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3076   16EF             
3077   16EF 68          BNORM:  LD      L,B             ; L = Exponent
3078   16F0 63                  LD      H,E             ; H = LSB
3079   16F1 AF                  XOR     A
3080   16F2 47          BNRMLP: LD      B,A             ; Save bit count
3081   16F3 79                  LD      A,C             ; Get MSB
3082   16F4 B7                  OR      A               ; Is it zero?
3083   16F5 C2 11 17            JP      NZ,PNORM        ; No - Do it bit at a time
3084   16F8 4A                  LD      C,D             ; MSB = NMSB
3085   16F9 54                  LD      D,H             ; NMSB= LSB
3086   16FA 65                  LD      H,L             ; LSB = VLSB
3087   16FB 6F                  LD      L,A             ; VLSB= 0
3088   16FC 78                  LD      A,B             ; Get exponent
3089   16FD D6 08               SUB     8               ; Count 8 bits
3090   16FF FE E0               CP      -24-8           ; Was number zero?
3091   1701 C2 F2 16            JP      NZ,BNRMLP       ; No - Keep normalising
3092   1704 AF          RESZER: XOR     A               ; Result is zero
3093   1705 32 07 22    SAVEXP: LD      (FPEXP),A       ; Save result as zero
3094   1708 C9                  RET
3095   1709             
3096   1709 05          NORMAL: DEC     B               ; Count bits
3097   170A 29                  ADD     HL,HL           ; Shift HL left
3098   170B 7A                  LD      A,D             ; Get NMSB
3099   170C 17                  RLA                     ; Shift left with last bit
3100   170D 57                  LD      D,A             ; Save NMSB
3101   170E 79                  LD      A,C             ; Get MSB
3102   170F 8F                  ADC     A,A             ; Shift left with last bit
3103   1710 4F                  LD      C,A             ; Save MSB
3104   1711 F2 09 17    PNORM:  JP      P,NORMAL        ; Not done - Keep going
3105   1714 78                  LD      A,B             ; Number of bits shifted
3106   1715 5C                  LD      E,H             ; Save HL in EB
3107   1716 45                  LD      B,L
3108   1717 B7                  OR      A               ; Any shifting done?
3109   1718 CA 24 17            JP      Z,RONDUP        ; No - Round it up
3110   171B 21 07 22            LD      HL,FPEXP        ; Point to exponent
3111   171E 86                  ADD     A,(HL)          ; Add shifted bits
3112   171F 77                  LD      (HL),A          ; Re-save exponent
3113   1720 D2 04 17            JP      NC,RESZER       ; Underflow - Result is zero
3114   1723 C8                  RET     Z               ; Result is zero
3115   1724 78          RONDUP: LD      A,B             ; Get VLSB of number
3116   1725 21 07 22    RONDB:  LD      HL,FPEXP        ; Point to exponent
3117   1728 B7                  OR      A               ; Any rounding?
3118   1729 FC 36 17            CALL    M,FPROND        ; Yes - Round number up
3119   172C 46                  LD      B,(HL)          ; B = Exponent
3120   172D 23                  INC     HL
3121   172E 7E                  LD      A,(HL)          ; Get sign of result
3122   172F E6 80               AND     10000000B       ; Only bit 7 needed
3123   1731 A9                  XOR     C               ; Set correct sign
3124   1732 4F                  LD      C,A             ; Save correct sign in number
3125   1733 C3 25 19            JP      FPBCDE          ; Move BCDE to FPREG
3126   1736             
3127   1736 1C          FPROND: INC     E               ; Round LSB
3128   1737 C0                  RET     NZ              ; Return if ok
3129   1738 14                  INC     D               ; Round NMSB
3130   1739 C0                  RET     NZ              ; Return if ok
3131   173A 0C                  INC     C               ; Round MSB
3132   173B C0                  RET     NZ              ; Return if ok
3133   173C 0E 80               LD      C,80H           ; Set normal value
3134   173E 34                  INC     (HL)            ; Increment exponent
3135   173F C0                  RET     NZ              ; Return if ok
3136   1740 C3 4C 06            JP      OVERR           ; Overflow error
3137   1743             
3138   1743 7E          PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3139   1744 83                  ADD     A,E             ; Add LSB of BCDE
3140   1745 5F                  LD      E,A             ; Save LSB of BCDE
3141   1746 23                  INC     HL
3142   1747 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3143   1748 8A                  ADC     A,D             ; Add NMSB of BCDE
3144   1749 57                  LD      D,A             ; Save NMSB of BCDE
3145   174A 23                  INC     HL
3146   174B 7E                  LD      A,(HL)          ; Get MSB of FPREG
3147   174C 89                  ADC     A,C             ; Add MSB of BCDE
3148   174D 4F                  LD      C,A             ; Save MSB of BCDE
3149   174E C9                  RET
3150   174F             
3151   174F 21 08 22    COMPL:  LD      HL,SGNRES       ; Sign of result
3152   1752 7E                  LD      A,(HL)          ; Get sign of result
3153   1753 2F                  CPL                     ; Negate it
3154   1754 77                  LD      (HL),A          ; Put it back
3155   1755 AF                  XOR     A
3156   1756 6F                  LD      L,A             ; Set L to zero
3157   1757 90                  SUB     B               ; Negate exponent,set carry
3158   1758 47                  LD      B,A             ; Re-save exponent
3159   1759 7D                  LD      A,L             ; Load zero
3160   175A 9B                  SBC     A,E             ; Negate LSB
3161   175B 5F                  LD      E,A             ; Re-save LSB
3162   175C 7D                  LD      A,L             ; Load zero
3163   175D 9A                  SBC     A,D             ; Negate NMSB
3164   175E 57                  LD      D,A             ; Re-save NMSB
3165   175F 7D                  LD      A,L             ; Load zero
3166   1760 99                  SBC     A,C             ; Negate MSB
3167   1761 4F                  LD      C,A             ; Re-save MSB
3168   1762 C9                  RET
3169   1763             
3170   1763 06 00       SCALE:  LD      B,0             ; Clear underflow
3171   1765 D6 08       SCALLP: SUB     8               ; 8 bits (a whole byte)?
3172   1767 DA 72 17            JP      C,SHRITE        ; No - Shift right A bits
3173   176A 43                  LD      B,E             ; <- Shift
3174   176B 5A                  LD      E,D             ; <- right
3175   176C 51                  LD      D,C             ; <- eight
3176   176D 0E 00               LD      C,0             ; <- bits
3177   176F C3 65 17            JP      SCALLP          ; More bits to shift
3178   1772             
3179   1772 C6 09       SHRITE: ADD     A,8+1           ; Adjust count
3180   1774 6F                  LD      L,A             ; Save bits to shift
3181   1775 AF          SHRLP:  XOR     A               ; Flag for all done
3182   1776 2D                  DEC     L               ; All shifting done?
3183   1777 C8                  RET     Z               ; Yes - Return
3184   1778 79                  LD      A,C             ; Get MSB
3185   1779 1F          SHRT1:  RRA                     ; Shift it right
3186   177A 4F                  LD      C,A             ; Re-save
3187   177B 7A                  LD      A,D             ; Get NMSB
3188   177C 1F                  RRA                     ; Shift right with last bit
3189   177D 57                  LD      D,A             ; Re-save it
3190   177E 7B                  LD      A,E             ; Get LSB
3191   177F 1F                  RRA                     ; Shift right with last bit
3192   1780 5F                  LD      E,A             ; Re-save it
3193   1781 78                  LD      A,B             ; Get underflow
3194   1782 1F                  RRA                     ; Shift right with last bit
3195   1783 47                  LD      B,A             ; Re-save underflow
3196   1784 C3 75 17            JP      SHRLP           ; More bits to do
3197   1787             
3198   1787 00 00 00 81 UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3199   178B             
3200   178B 03          LOGTAB: .BYTE      3                       ; Table used by LOG
3201   178C AA 56 19 80         .BYTE      0AAH,056H,019H,080H     ; 0.59898
3202   1790 F1 22 76 80         .BYTE      0F1H,022H,076H,080H     ; 0.96147
3203   1794 45 AA 38 82         .BYTE      045H,0AAH,038H,082H     ; 2.88539
3204   1798             
3205   1798 CD E4 18    LOG:    CALL    TSTSGN          ; Test sign of value
3206   179B B7                  OR      A
3207   179C EA 5C 0B            JP      PE,FCERR        ; ?FC Error if <= zero
3208   179F 21 07 22            LD      HL,FPEXP        ; Point to exponent
3209   17A2 7E                  LD      A,(HL)          ; Get exponent
3210   17A3 01 35 80            LD      BC,8035H        ; BCDE = SQR(1/2)
3211   17A6 11 F3 04            LD      DE,04F3H
3212   17A9 90                  SUB     B               ; Scale value to be < 1
3213   17AA F5                  PUSH    AF              ; Save scale factor
3214   17AB 70                  LD      (HL),B          ; Save new exponent
3215   17AC D5                  PUSH    DE              ; Save SQR(1/2)
3216   17AD C5                  PUSH    BC
3217   17AE CD 9E 16            CALL    FPADD           ; Add SQR(1/2) to value
3218   17B1 C1                  POP     BC              ; Restore SQR(1/2)
3219   17B2 D1                  POP     DE
3220   17B3 04                  INC     B               ; Make it SQR(2)
3221   17B4 CD 3A 18            CALL    DVBCDE          ; Divide by SQR(2)
3222   17B7 21 87 17            LD      HL,UNITY        ; Point to 1.
3223   17BA CD 95 16            CALL    SUBPHL          ; Subtract FPREG from 1
3224   17BD 21 8B 17            LD      HL,LOGTAB       ; Coefficient table
3225   17C0 CD 2C 1C            CALL    SUMSER          ; Evaluate sum of series
3226   17C3 01 80 80            LD      BC,8080H        ; BCDE = -0.5
3227   17C6 11 00 00            LD      DE,0000H
3228   17C9 CD 9E 16            CALL    FPADD           ; Subtract 0.5 from FPREG
3229   17CC F1                  POP     AF              ; Restore scale factor
3230   17CD CD 5F 1A            CALL    RSCALE          ; Re-scale number
3231   17D0 01 31 80    MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3232   17D3 11 18 72            LD      DE,7218H
3233   17D6 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3234   17D7             
3235   17D7 C1          MULT:   POP     BC              ; Get number from stack
3236   17D8 D1                  POP     DE
3237   17D9 CD E4 18    FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3238   17DC C8                  RET     Z               ; Return zero if zero
3239   17DD 2E 00               LD      L,0             ; Flag add exponents
3240   17DF CD A2 18            CALL    ADDEXP          ; Add exponents
3241   17E2 79                  LD      A,C             ; Get MSB of multiplier
3242   17E3 32 16 22            LD      (MULVAL),A      ; Save MSB of multiplier
3243   17E6 EB                  EX      DE,HL
3244   17E7 22 17 22            LD      (MULVAL+1),HL   ; Save rest of multiplier
3245   17EA 01 00 00            LD      BC,0            ; Partial product (BCDE) = zero
3246   17ED 50                  LD      D,B
3247   17EE 58                  LD      E,B
3248   17EF 21 EF 16            LD      HL,BNORM        ; Address of normalise
3249   17F2 E5                  PUSH    HL              ; Save for return
3250   17F3 21 FB 17            LD      HL,MULT8        ; Address of 8 bit multiply
3251   17F6 E5                  PUSH    HL              ; Save for NMSB,MSB
3252   17F7 E5                  PUSH    HL              ; 
3253   17F8 21 04 22            LD      HL,FPREG        ; Point to number
3254   17FB 7E          MULT8:  LD      A,(HL)          ; Get LSB of number
3255   17FC 23                  INC     HL              ; Point to NMSB
3256   17FD B7                  OR      A               ; Test LSB
3257   17FE CA 27 18            JP      Z,BYTSFT        ; Zero - shift to next byte
3258   1801 E5                  PUSH    HL              ; Save address of number
3259   1802 2E 08               LD      L,8             ; 8 bits to multiply by
3260   1804 1F          MUL8LP: RRA                     ; Shift LSB right
3261   1805 67                  LD      H,A             ; Save LSB
3262   1806 79                  LD      A,C             ; Get MSB
3263   1807 D2 15 18            JP      NC,NOMADD       ; Bit was zero - Don't add
3264   180A E5                  PUSH    HL              ; Save LSB and count
3265   180B 2A 17 22            LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3266   180E 19                  ADD     HL,DE           ; Add NMSB and LSB
3267   180F EB                  EX      DE,HL           ; Leave sum in DE
3268   1810 E1                  POP     HL              ; Restore MSB and count
3269   1811 3A 16 22            LD      A,(MULVAL)      ; Get MSB of multiplier
3270   1814 89                  ADC     A,C             ; Add MSB
3271   1815 1F          NOMADD: RRA                     ; Shift MSB right
3272   1816 4F                  LD      C,A             ; Re-save MSB
3273   1817 7A                  LD      A,D             ; Get NMSB
3274   1818 1F                  RRA                     ; Shift NMSB right
3275   1819 57                  LD      D,A             ; Re-save NMSB
3276   181A 7B                  LD      A,E             ; Get LSB
3277   181B 1F                  RRA                     ; Shift LSB right
3278   181C 5F                  LD      E,A             ; Re-save LSB
3279   181D 78                  LD      A,B             ; Get VLSB
3280   181E 1F                  RRA                     ; Shift VLSB right
3281   181F 47                  LD      B,A             ; Re-save VLSB
3282   1820 2D                  DEC     L               ; Count bits multiplied
3283   1821 7C                  LD      A,H             ; Get LSB of multiplier
3284   1822 C2 04 18            JP      NZ,MUL8LP       ; More - Do it
3285   1825 E1          POPHRT: POP     HL              ; Restore address of number
3286   1826 C9                  RET
3287   1827             
3288   1827 43          BYTSFT: LD      B,E             ; Shift partial product left
3289   1828 5A                  LD      E,D
3290   1829 51                  LD      D,C
3291   182A 4F                  LD      C,A
3292   182B C9                  RET
3293   182C             
3294   182C CD 15 19    DIV10:  CALL    STAKFP          ; Save FPREG on stack
3295   182F 01 20 84            LD      BC,8420H        ; BCDE = 10.
3296   1832 11 00 00            LD      DE,0000H
3297   1835 CD 25 19            CALL    FPBCDE          ; Move 10 to FPREG
3298   1838             
3299   1838 C1          DIV:    POP     BC              ; Get number from stack
3300   1839 D1                  POP     DE
3301   183A CD E4 18    DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3302   183D CA 40 06            JP      Z,DZERR         ; Error if division by zero
3303   1840 2E FF               LD      L,-1            ; Flag subtract exponents
3304   1842 CD A2 18            CALL    ADDEXP          ; Subtract exponents
3305   1845 34                  INC     (HL)            ; Add 2 to exponent to adjust
3306   1846 34                  INC     (HL)
3307   1847 2B                  DEC     HL              ; Point to MSB
3308   1848 7E                  LD      A,(HL)          ; Get MSB of dividend
3309   1849 32 32 21            LD      (DIV3),A        ; Save for subtraction
3310   184C 2B                  DEC     HL
3311   184D 7E                  LD      A,(HL)          ; Get NMSB of dividend
3312   184E 32 2E 21            LD      (DIV2),A        ; Save for subtraction
3313   1851 2B                  DEC     HL
3314   1852 7E                  LD      A,(HL)          ; Get MSB of dividend
3315   1853 32 2A 21            LD      (DIV1),A        ; Save for subtraction
3316   1856 41                  LD      B,C             ; Get MSB
3317   1857 EB                  EX      DE,HL           ; NMSB,LSB to HL
3318   1858 AF                  XOR     A
3319   1859 4F                  LD      C,A             ; Clear MSB of quotient
3320   185A 57                  LD      D,A             ; Clear NMSB of quotient
3321   185B 5F                  LD      E,A             ; Clear LSB of quotient
3322   185C 32 35 21            LD      (DIV4),A        ; Clear overflow count
3323   185F E5          DIVLP:  PUSH    HL              ; Save divisor
3324   1860 C5                  PUSH    BC
3325   1861 7D                  LD      A,L             ; Get LSB of number
3326   1862 CD 29 21            CALL    DIVSUP          ; Subt' divisor from dividend
3327   1865 DE 00               SBC     A,0             ; Count for overflows
3328   1867 3F                  CCF
3329   1868 D2 72 18            JP      NC,RESDIV       ; Restore divisor if borrow
3330   186B 32 35 21            LD      (DIV4),A        ; Re-save overflow count
3331   186E F1                  POP     AF              ; Scrap divisor
3332   186F F1                  POP     AF
3333   1870 37                  SCF                     ; Set carry to
3334   1871 D2                  .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3335   1872             
3336   1872 C1          RESDIV: POP     BC              ; Restore divisor
3337   1873 E1                  POP     HL
3338   1874 79                  LD      A,C             ; Get MSB of quotient
3339   1875 3C                  INC     A
3340   1876 3D                  DEC     A
3341   1877 1F                  RRA                     ; Bit 0 to bit 7
3342   1878 FA 25 17            JP      M,RONDB         ; Done - Normalise result
3343   187B 17                  RLA                     ; Restore carry
3344   187C 7B                  LD      A,E             ; Get LSB of quotient
3345   187D 17                  RLA                     ; Double it
3346   187E 5F                  LD      E,A             ; Put it back
3347   187F 7A                  LD      A,D             ; Get NMSB of quotient
3348   1880 17                  RLA                     ; Double it
3349   1881 57                  LD      D,A             ; Put it back
3350   1882 79                  LD      A,C             ; Get MSB of quotient
3351   1883 17                  RLA                     ; Double it
3352   1884 4F                  LD      C,A             ; Put it back
3353   1885 29                  ADD     HL,HL           ; Double NMSB,LSB of divisor
3354   1886 78                  LD      A,B             ; Get MSB of divisor
3355   1887 17                  RLA                     ; Double it
3356   1888 47                  LD      B,A             ; Put it back
3357   1889 3A 35 21            LD      A,(DIV4)        ; Get VLSB of quotient
3358   188C 17                  RLA                     ; Double it
3359   188D 32 35 21            LD      (DIV4),A        ; Put it back
3360   1890 79                  LD      A,C             ; Get MSB of quotient
3361   1891 B2                  OR      D               ; Merge NMSB
3362   1892 B3                  OR      E               ; Merge LSB
3363   1893 C2 5F 18            JP      NZ,DIVLP        ; Not done - Keep dividing
3364   1896 E5                  PUSH    HL              ; Save divisor
3365   1897 21 07 22            LD      HL,FPEXP        ; Point to exponent
3366   189A 35                  DEC     (HL)            ; Divide by 2
3367   189B E1                  POP     HL              ; Restore divisor
3368   189C C2 5F 18            JP      NZ,DIVLP        ; Ok - Keep going
3369   189F C3 4C 06            JP      OVERR           ; Overflow error
3370   18A2             
3371   18A2 78          ADDEXP: LD      A,B             ; Get exponent of dividend
3372   18A3 B7                  OR      A               ; Test it
3373   18A4 CA C6 18            JP      Z,OVTST3        ; Zero - Result zero
3374   18A7 7D                  LD      A,L             ; Get add/subtract flag
3375   18A8 21 07 22            LD      HL,FPEXP        ; Point to exponent
3376   18AB AE                  XOR     (HL)            ; Add or subtract it
3377   18AC 80                  ADD     A,B             ; Add the other exponent
3378   18AD 47                  LD      B,A             ; Save new exponent
3379   18AE 1F                  RRA                     ; Test exponent for overflow
3380   18AF A8                  XOR     B
3381   18B0 78                  LD      A,B             ; Get exponent
3382   18B1 F2 C5 18            JP      P,OVTST2        ; Positive - Test for overflow
3383   18B4 C6 80               ADD     A,80H           ; Add excess 128
3384   18B6 77                  LD      (HL),A          ; Save new exponent
3385   18B7 CA 25 18            JP      Z,POPHRT        ; Zero - Result zero
3386   18BA CD 4A 19            CALL    SIGNS           ; Set MSBs and sign of result
3387   18BD 77                  LD      (HL),A          ; Save new exponent
3388   18BE 2B                  DEC     HL              ; Point to MSB
3389   18BF C9                  RET
3390   18C0             
3391   18C0 CD E4 18    OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3392   18C3 2F                  CPL                     ; Invert sign
3393   18C4 E1                  POP     HL              ; Clean up stack
3394   18C5 B7          OVTST2: OR      A               ; Test if new exponent zero
3395   18C6 E1          OVTST3: POP     HL              ; Clear off return address
3396   18C7 F2 04 17            JP      P,RESZER        ; Result zero
3397   18CA C3 4C 06            JP      OVERR           ; Overflow error
3398   18CD             
3399   18CD CD 30 19    MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3400   18D0 78                  LD      A,B             ; Get exponent
3401   18D1 B7                  OR      A               ; Is it zero?
3402   18D2 C8                  RET     Z               ; Yes - Result is zero
3403   18D3 C6 02               ADD     A,2             ; Multiply by 4
3404   18D5 DA 4C 06            JP      C,OVERR         ; Overflow - ?OV Error
3405   18D8 47                  LD      B,A             ; Re-save exponent
3406   18D9 CD 9E 16            CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3407   18DC 21 07 22            LD      HL,FPEXP        ; Point to exponent
3408   18DF 34                  INC     (HL)            ; Double number (Times 10)
3409   18E0 C0                  RET     NZ              ; Ok - Return
3410   18E1 C3 4C 06            JP      OVERR           ; Overflow error
3411   18E4             
3412   18E4 3A 07 22    TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3413   18E7 B7                  OR      A
3414   18E8 C8                  RET     Z               ; RETurn if number is zero
3415   18E9 3A 06 22            LD      A,(FPREG+2)     ; Get MSB of FPREG
3416   18EC FE                  .BYTE      0FEH            ; Test sign
3417   18ED 2F          RETREL: CPL                     ; Invert sign
3418   18EE 17                  RLA                     ; Sign bit to carry
3419   18EF 9F          FLGDIF: SBC     A,A             ; Carry to all bits of A
3420   18F0 C0                  RET     NZ              ; Return -1 if negative
3421   18F1 3C                  INC     A               ; Bump to +1
3422   18F2 C9                  RET                     ; Positive - Return +1
3423   18F3             
3424   18F3 CD E4 18    SGN:    CALL    TSTSGN          ; Test sign of FPREG
3425   18F6 06 88       FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3426   18F8 11 00 00            LD      DE,0            ; Zero NMSB and LSB
3427   18FB 21 07 22    RETINT: LD      HL,FPEXP        ; Point to exponent
3428   18FE 4F                  LD      C,A             ; CDE = MSB,NMSB and LSB
3429   18FF 70                  LD      (HL),B          ; Save exponent
3430   1900 06 00               LD      B,0             ; CDE = integer to normalise
3431   1902 23                  INC     HL              ; Point to sign of result
3432   1903 36 80               LD      (HL),80H        ; Set sign of result
3433   1905 17                  RLA                     ; Carry = sign of integer
3434   1906 C3 EC 16            JP      CONPOS          ; Set sign of result
3435   1909             
3436   1909 CD E4 18    ABS:    CALL    TSTSGN          ; Test sign of FPREG
3437   190C F0                  RET     P               ; Return if positive
3438   190D 21 06 22    INVSGN: LD      HL,FPREG+2      ; Point to MSB
3439   1910 7E                  LD      A,(HL)          ; Get sign of mantissa
3440   1911 EE 80               XOR     80H             ; Invert sign of mantissa
3441   1913 77                  LD      (HL),A          ; Re-save sign of mantissa
3442   1914 C9                  RET
3443   1915             
3444   1915 EB          STAKFP: EX      DE,HL           ; Save code string address
3445   1916 2A 04 22            LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3446   1919 E3                  EX      (SP),HL         ; Stack them,get return
3447   191A E5                  PUSH    HL              ; Re-save return
3448   191B 2A 06 22            LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3449   191E E3                  EX      (SP),HL         ; Stack them,get return
3450   191F E5                  PUSH    HL              ; Re-save return
3451   1920 EB                  EX      DE,HL           ; Restore code string address
3452   1921 C9                  RET
3453   1922             
3454   1922 CD 33 19    PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3455   1925 EB          FPBCDE: EX      DE,HL           ; Save code string address
3456   1926 22 04 22            LD      (FPREG),HL      ; Save LSB,NLSB of number
3457   1929 60                  LD      H,B             ; Exponent of number
3458   192A 69                  LD      L,C             ; MSB of number
3459   192B 22 06 22            LD      (FPREG+2),HL    ; Save MSB and exponent
3460   192E EB                  EX      DE,HL           ; Restore code string address
3461   192F C9                  RET
3462   1930             
3463   1930 21 04 22    BCDEFP: LD      HL,FPREG        ; Point to FPREG
3464   1933 5E          LOADFP: LD      E,(HL)          ; Get LSB of number
3465   1934 23                  INC     HL
3466   1935 56                  LD      D,(HL)          ; Get NMSB of number
3467   1936 23                  INC     HL
3468   1937 4E                  LD      C,(HL)          ; Get MSB of number
3469   1938 23                  INC     HL
3470   1939 46                  LD      B,(HL)          ; Get exponent of number
3471   193A 23          INCHL:  INC     HL              ; Used for conditional "INC HL"
3472   193B C9                  RET
3473   193C             
3474   193C 11 04 22    FPTHL:  LD      DE,FPREG        ; Point to FPREG
3475   193F 06 04       DETHL4: LD      B,4             ; 4 bytes to move
3476   1941 1A          DETHLB: LD      A,(DE)          ; Get source
3477   1942 77                  LD      (HL),A          ; Save destination
3478   1943 13                  INC     DE              ; Next source
3479   1944 23                  INC     HL              ; Next destination
3480   1945 05                  DEC     B               ; Count bytes
3481   1946 C2 41 19            JP      NZ,DETHLB       ; Loop if more
3482   1949 C9                  RET
3483   194A             
3484   194A 21 06 22    SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3485   194D 7E                  LD      A,(HL)          ; Get MSB
3486   194E 07                  RLCA                    ; Old sign to carry
3487   194F 37                  SCF                     ; Set MSBit
3488   1950 1F                  RRA                     ; Set MSBit of MSB
3489   1951 77                  LD      (HL),A          ; Save new MSB
3490   1952 3F                  CCF                     ; Complement sign
3491   1953 1F                  RRA                     ; Old sign to carry
3492   1954 23                  INC     HL
3493   1955 23                  INC     HL
3494   1956 77                  LD      (HL),A          ; Set sign of result
3495   1957 79                  LD      A,C             ; Get MSB
3496   1958 07                  RLCA                    ; Old sign to carry
3497   1959 37                  SCF                     ; Set MSBit
3498   195A 1F                  RRA                     ; Set MSBit of MSB
3499   195B 4F                  LD      C,A             ; Save MSB
3500   195C 1F                  RRA
3501   195D AE                  XOR     (HL)            ; New sign of result
3502   195E C9                  RET
3503   195F             
3504   195F 78          CMPNUM: LD      A,B             ; Get exponent of number
3505   1960 B7                  OR      A
3506   1961 CA E4 18            JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3507   1964 21 ED 18            LD      HL,RETREL       ; Return relation routine
3508   1967 E5                  PUSH    HL              ; Save for return
3509   1968 CD E4 18            CALL    TSTSGN          ; Test sign of FPREG
3510   196B 79                  LD      A,C             ; Get MSB of number
3511   196C C8                  RET     Z               ; FPREG zero - Number's MSB
3512   196D 21 06 22            LD      HL,FPREG+2      ; MSB of FPREG
3513   1970 AE                  XOR     (HL)            ; Combine signs
3514   1971 79                  LD      A,C             ; Get MSB of number
3515   1972 F8                  RET     M               ; Exit if signs different
3516   1973 CD 79 19            CALL    CMPFP           ; Compare FP numbers
3517   1976 1F                  RRA                     ; Get carry to sign
3518   1977 A9                  XOR     C               ; Combine with MSB of number
3519   1978 C9                  RET
3520   1979             
3521   1979 23          CMPFP:  INC     HL              ; Point to exponent
3522   197A 78                  LD      A,B             ; Get exponent
3523   197B BE                  CP      (HL)            ; Compare exponents
3524   197C C0                  RET     NZ              ; Different
3525   197D 2B                  DEC     HL              ; Point to MBS
3526   197E 79                  LD      A,C             ; Get MSB
3527   197F BE                  CP      (HL)            ; Compare MSBs
3528   1980 C0                  RET     NZ              ; Different
3529   1981 2B                  DEC     HL              ; Point to NMSB
3530   1982 7A                  LD      A,D             ; Get NMSB
3531   1983 BE                  CP      (HL)            ; Compare NMSBs
3532   1984 C0                  RET     NZ              ; Different
3533   1985 2B                  DEC     HL              ; Point to LSB
3534   1986 7B                  LD      A,E             ; Get LSB
3535   1987 96                  SUB     (HL)            ; Compare LSBs
3536   1988 C0                  RET     NZ              ; Different
3537   1989 E1                  POP     HL              ; Drop RETurn
3538   198A E1                  POP     HL              ; Drop another RETurn
3539   198B C9                  RET
3540   198C             
3541   198C 47          FPINT:  LD      B,A             ; <- Move
3542   198D 4F                  LD      C,A             ; <- exponent
3543   198E 57                  LD      D,A             ; <- to all
3544   198F 5F                  LD      E,A             ; <- bits
3545   1990 B7                  OR      A               ; Test exponent
3546   1991 C8                  RET     Z               ; Zero - Return zero
3547   1992 E5                  PUSH    HL              ; Save pointer to number
3548   1993 CD 30 19            CALL    BCDEFP          ; Move FPREG to BCDE
3549   1996 CD 4A 19            CALL    SIGNS           ; Set MSBs & sign of result
3550   1999 AE                  XOR     (HL)            ; Combine with sign of FPREG
3551   199A 67                  LD      H,A             ; Save combined signs
3552   199B FC B0 19            CALL    M,DCBCDE        ; Negative - Decrement BCDE
3553   199E 3E 98               LD      A,80H+24        ; 24 bits
3554   19A0 90                  SUB     B               ; Bits to shift
3555   19A1 CD 63 17            CALL    SCALE           ; Shift BCDE
3556   19A4 7C                  LD      A,H             ; Get combined sign
3557   19A5 17                  RLA                     ; Sign to carry
3558   19A6 DC 36 17            CALL    C,FPROND        ; Negative - Round number up
3559   19A9 06 00               LD      B,0             ; Zero exponent
3560   19AB DC 4F 17            CALL    C,COMPL         ; If negative make positive
3561   19AE E1                  POP     HL              ; Restore pointer to number
3562   19AF C9                  RET
3563   19B0             
3564   19B0 1B          DCBCDE: DEC     DE              ; Decrement BCDE
3565   19B1 7A                  LD      A,D             ; Test LSBs
3566   19B2 A3                  AND     E
3567   19B3 3C                  INC     A
3568   19B4 C0                  RET     NZ              ; Exit if LSBs not FFFF
3569   19B5 0B                  DEC     BC              ; Decrement MSBs
3570   19B6 C9                  RET
3571   19B7             
3572   19B7 21 07 22    INT:    LD      HL,FPEXP        ; Point to exponent
3573   19BA 7E                  LD      A,(HL)          ; Get exponent
3574   19BB FE 98               CP      80H+24          ; Integer accuracy only?
3575   19BD 3A 04 22            LD      A,(FPREG)       ; Get LSB
3576   19C0 D0                  RET     NC              ; Yes - Already integer
3577   19C1 7E                  LD      A,(HL)          ; Get exponent
3578   19C2 CD 8C 19            CALL    FPINT           ; F.P to integer
3579   19C5 36 98               LD      (HL),80H+24     ; Save 24 bit integer
3580   19C7 7B                  LD      A,E             ; Get LSB of number
3581   19C8 F5                  PUSH    AF              ; Save LSB
3582   19C9 79                  LD      A,C             ; Get MSB of number
3583   19CA 17                  RLA                     ; Sign to carry
3584   19CB CD EC 16            CALL    CONPOS          ; Set sign of result
3585   19CE F1                  POP     AF              ; Restore LSB of number
3586   19CF C9                  RET
3587   19D0             
3588   19D0 21 00 00    MLDEBC: LD      HL,0            ; Clear partial product
3589   19D3 78                  LD      A,B             ; Test multiplier
3590   19D4 B1                  OR      C
3591   19D5 C8                  RET     Z               ; Return zero if zero
3592   19D6 3E 10               LD      A,16            ; 16 bits
3593   19D8 29          MLDBLP: ADD     HL,HL           ; Shift P.P left
3594   19D9 DA 10 12            JP      C,BSERR         ; ?BS Error if overflow
3595   19DC EB                  EX      DE,HL
3596   19DD 29                  ADD     HL,HL           ; Shift multiplier left
3597   19DE EB                  EX      DE,HL
3598   19DF D2 E6 19            JP      NC,NOMLAD       ; Bit was zero - No add
3599   19E2 09                  ADD     HL,BC           ; Add multiplicand
3600   19E3 DA 10 12            JP      C,BSERR         ; ?BS Error if overflow
3601   19E6 3D          NOMLAD: DEC     A               ; Count bits
3602   19E7 C2 D8 19            JP      NZ,MLDBLP       ; More
3603   19EA C9                  RET
3604   19EB             
3605   19EB FE 2D       ASCTFP: CP      '-'             ; Negative?
3606   19ED F5                  PUSH    AF              ; Save it and flags
3607   19EE CA F7 19            JP      Z,CNVNUM        ; Yes - Convert number
3608   19F1 FE 2B               CP      '+'             ; Positive?
3609   19F3 CA F7 19            JP      Z,CNVNUM        ; Yes - Convert number
3610   19F6 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3611   19F7 CD 04 17    CNVNUM: CALL    RESZER          ; Set result to zero
3612   19FA 47                  LD      B,A             ; Digits after point counter
3613   19FB 57                  LD      D,A             ; Sign of exponent
3614   19FC 5F                  LD      E,A             ; Exponent of ten
3615   19FD 2F                  CPL
3616   19FE 4F                  LD      C,A             ; Before or after point flag
3617   19FF CD 95 0A    MANLP:  CALL    GETCHR          ; Get next character
3618   1A02 DA 48 1A            JP      C,ADDIG         ; Digit - Add to number
3619   1A05 FE 2E               CP      '.'
3620   1A07 CA 23 1A            JP      Z,DPOINT        ; '.' - Flag point
3621   1A0A FE 45               CP      'E'
3622   1A0C C2 27 1A            JP      NZ,CONEXP       ; Not 'E' - Scale number
3623   1A0F CD 95 0A            CALL    GETCHR          ; Get next character
3624   1A12 CD 3B 10            CALL    SGNEXP          ; Get sign of exponent
3625   1A15 CD 95 0A    EXPLP:  CALL    GETCHR          ; Get next character
3626   1A18 DA 6A 1A            JP      C,EDIGIT        ; Digit - Add to exponent
3627   1A1B 14                  INC     D               ; Is sign negative?
3628   1A1C C2 27 1A            JP      NZ,CONEXP       ; No - Scale number
3629   1A1F AF                  XOR     A
3630   1A20 93                  SUB     E               ; Negate exponent
3631   1A21 5F                  LD      E,A             ; And re-save it
3632   1A22 0C                  INC     C               ; Flag end of number
3633   1A23 0C          DPOINT: INC     C               ; Flag point passed
3634   1A24 CA FF 19            JP      Z,MANLP         ; Zero - Get another digit
3635   1A27 E5          CONEXP: PUSH    HL              ; Save code string address
3636   1A28 7B                  LD      A,E             ; Get exponent
3637   1A29 90                  SUB     B               ; Subtract digits after point
3638   1A2A F4 40 1A    SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3639   1A2D F2 36 1A            JP      P,ENDCON        ; Positive - All done
3640   1A30 F5                  PUSH    AF              ; Save number of times to /10
3641   1A31 CD 2C 18            CALL    DIV10           ; Divide by 10
3642   1A34 F1                  POP     AF              ; Restore count
3643   1A35 3C                  INC     A               ; Count divides
3644   1A36             
3645   1A36 C2 2A 1A    ENDCON: JP      NZ,SCALMI       ; More to do
3646   1A39 D1                  POP     DE              ; Restore code string address
3647   1A3A F1                  POP     AF              ; Restore sign of number
3648   1A3B CC 0D 19            CALL    Z,INVSGN        ; Negative - Negate number
3649   1A3E EB                  EX      DE,HL           ; Code string address to HL
3650   1A3F C9                  RET
3651   1A40             
3652   1A40 C8          SCALPL: RET     Z               ; Exit if no scaling needed
3653   1A41 F5          MULTEN: PUSH    AF              ; Save count
3654   1A42 CD CD 18            CALL    MLSP10          ; Multiply number by 10
3655   1A45 F1                  POP     AF              ; Restore count
3656   1A46 3D                  DEC     A               ; Count multiplies
3657   1A47 C9                  RET
3658   1A48             
3659   1A48 D5          ADDIG:  PUSH    DE              ; Save sign of exponent
3660   1A49 57                  LD      D,A             ; Save digit
3661   1A4A 78                  LD      A,B             ; Get digits after point
3662   1A4B 89                  ADC     A,C             ; Add one if after point
3663   1A4C 47                  LD      B,A             ; Re-save counter
3664   1A4D C5                  PUSH    BC              ; Save point flags
3665   1A4E E5                  PUSH    HL              ; Save code string address
3666   1A4F D5                  PUSH    DE              ; Save digit
3667   1A50 CD CD 18            CALL    MLSP10          ; Multiply number by 10
3668   1A53 F1                  POP     AF              ; Restore digit
3669   1A54 D6 30               SUB     '0'             ; Make it absolute
3670   1A56 CD 5F 1A            CALL    RSCALE          ; Re-scale number
3671   1A59 E1                  POP     HL              ; Restore code string address
3672   1A5A C1                  POP     BC              ; Restore point flags
3673   1A5B D1                  POP     DE              ; Restore sign of exponent
3674   1A5C C3 FF 19            JP      MANLP           ; Get another digit
3675   1A5F             
3676   1A5F CD 15 19    RSCALE: CALL    STAKFP          ; Put number on stack
3677   1A62 CD F6 18            CALL    FLGREL          ; Digit to add to FPREG
3678   1A65 C1          PADD:   POP     BC              ; Restore number
3679   1A66 D1                  POP     DE
3680   1A67 C3 9E 16            JP      FPADD           ; Add BCDE to FPREG and return
3681   1A6A             
3682   1A6A 7B          EDIGIT: LD      A,E             ; Get digit
3683   1A6B 07                  RLCA                    ; Times 2
3684   1A6C 07                  RLCA                    ; Times 4
3685   1A6D 83                  ADD     A,E             ; Times 5
3686   1A6E 07                  RLCA                    ; Times 10
3687   1A6F 86                  ADD     A,(HL)          ; Add next digit
3688   1A70 D6 30               SUB     '0'             ; Make it absolute
3689   1A72 5F                  LD      E,A             ; Save new digit
3690   1A73 C3 15 1A            JP      EXPLP           ; Look for another digit
3691   1A76             
3692   1A76 E5          LINEIN: PUSH    HL              ; Save code string address
3693   1A77 21 D5 05            LD      HL,INMSG        ; Output " in "
3694   1A7A CD DB 13            CALL    PRS             ; Output string at HL
3695   1A7D E1                  POP     HL              ; Restore code string address
3696   1A7E EB          PRNTHL: EX      DE,HL           ; Code string address to DE
3697   1A7F AF                  XOR     A
3698   1A80 06 98               LD      B,80H+24        ; 24 bits
3699   1A82 CD FB 18            CALL    RETINT          ; Return the integer
3700   1A85 21 DA 13            LD      HL,PRNUMS       ; Print number string
3701   1A88 E5                  PUSH    HL              ; Save for return
3702   1A89 21 09 22    NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3703   1A8C E5                  PUSH    HL              ; Save for return
3704   1A8D CD E4 18            CALL    TSTSGN          ; Test sign of FPREG
3705   1A90 36 20               LD      (HL),' '        ; Space at start
3706   1A92 F2 97 1A            JP      P,SPCFST        ; Positive - Space to start
3707   1A95 36 2D               LD      (HL),'-'        ; '-' sign at start
3708   1A97 23          SPCFST: INC     HL              ; First byte of number
3709   1A98 36 30               LD      (HL),'0'        ; '0' if zero
3710   1A9A CA 4D 1B            JP      Z,JSTZER        ; Return '0' if zero
3711   1A9D E5                  PUSH    HL              ; Save buffer address
3712   1A9E FC 0D 19            CALL    M,INVSGN        ; Negate FPREG if negative
3713   1AA1 AF                  XOR     A               ; Zero A
3714   1AA2 F5                  PUSH    AF              ; Save it
3715   1AA3 CD 53 1B            CALL    RNGTST          ; Test number is in range
3716   1AA6 01 43 91    SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3717   1AA9 11 F8 4F            LD      DE,4FF8H
3718   1AAC CD 5F 19            CALL    CMPNUM          ; Compare numbers
3719   1AAF B7                  OR      A
3720   1AB0 E2 C4 1A            JP      PO,INRNG        ; > 99999.9 - Sort it out
3721   1AB3 F1                  POP     AF              ; Restore count
3722   1AB4 CD 41 1A            CALL    MULTEN          ; Multiply by ten
3723   1AB7 F5                  PUSH    AF              ; Re-save count
3724   1AB8 C3 A6 1A            JP      SIXDIG          ; Test it again
3725   1ABB             
3726   1ABB CD 2C 18    GTSIXD: CALL    DIV10           ; Divide by 10
3727   1ABE F1                  POP     AF              ; Get count
3728   1ABF 3C                  INC     A               ; Count divides
3729   1AC0 F5                  PUSH    AF              ; Re-save count
3730   1AC1 CD 53 1B            CALL    RNGTST          ; Test number is in range
3731   1AC4 CD 8C 16    INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3732   1AC7 3C                  INC     A
3733   1AC8 CD 8C 19            CALL    FPINT           ; F.P to integer
3734   1ACB CD 25 19            CALL    FPBCDE          ; Move BCDE to FPREG
3735   1ACE 01 06 03            LD      BC,0306H        ; 1E+06 to 1E-03 range
3736   1AD1 F1                  POP     AF              ; Restore count
3737   1AD2 81                  ADD     A,C             ; 6 digits before point
3738   1AD3 3C                  INC     A               ; Add one
3739   1AD4 FA E0 1A            JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3740   1AD7 FE 08               CP      6+1+1           ; More than 999999 ?
3741   1AD9 D2 E0 1A            JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3742   1ADC 3C                  INC     A               ; Adjust for exponent
3743   1ADD 47                  LD      B,A             ; Exponent of number
3744   1ADE 3E 02               LD      A,2             ; Make it zero after
3745   1AE0             
3746   1AE0 3D          MAKNUM: DEC     A               ; Adjust for digits to do
3747   1AE1 3D                  DEC     A
3748   1AE2 E1                  POP     HL              ; Restore buffer address
3749   1AE3 F5                  PUSH    AF              ; Save count
3750   1AE4 11 66 1B            LD      DE,POWERS       ; Powers of ten
3751   1AE7 05                  DEC     B               ; Count digits before point
3752   1AE8 C2 F1 1A            JP      NZ,DIGTXT       ; Not zero - Do number
3753   1AEB 36 2E               LD      (HL),'.'        ; Save point
3754   1AED 23                  INC     HL              ; Move on
3755   1AEE 36 30               LD      (HL),'0'        ; Save zero
3756   1AF0 23                  INC     HL              ; Move on
3757   1AF1 05          DIGTXT: DEC     B               ; Count digits before point
3758   1AF2 36 2E               LD      (HL),'.'        ; Save point in case
3759   1AF4 CC 3A 19            CALL    Z,INCHL         ; Last digit - move on
3760   1AF7 C5                  PUSH    BC              ; Save digits before point
3761   1AF8 E5                  PUSH    HL              ; Save buffer address
3762   1AF9 D5                  PUSH    DE              ; Save powers of ten
3763   1AFA CD 30 19            CALL    BCDEFP          ; Move FPREG to BCDE
3764   1AFD E1                  POP     HL              ; Powers of ten table
3765   1AFE 06 2F               LD      B, '0'-1        ; ASCII '0' - 1
3766   1B00 04          TRYAGN: INC     B               ; Count subtractions
3767   1B01 7B                  LD      A,E             ; Get LSB
3768   1B02 96                  SUB     (HL)            ; Subtract LSB
3769   1B03 5F                  LD      E,A             ; Save LSB
3770   1B04 23                  INC     HL
3771   1B05 7A                  LD      A,D             ; Get NMSB
3772   1B06 9E                  SBC     A,(HL)          ; Subtract NMSB
3773   1B07 57                  LD      D,A             ; Save NMSB
3774   1B08 23                  INC     HL
3775   1B09 79                  LD      A,C             ; Get MSB
3776   1B0A 9E                  SBC     A,(HL)          ; Subtract MSB
3777   1B0B 4F                  LD      C,A             ; Save MSB
3778   1B0C 2B                  DEC     HL              ; Point back to start
3779   1B0D 2B                  DEC     HL
3780   1B0E D2 00 1B            JP      NC,TRYAGN       ; No overflow - Try again
3781   1B11 CD 43 17            CALL    PLUCDE          ; Restore number
3782   1B14 23                  INC     HL              ; Start of next number
3783   1B15 CD 25 19            CALL    FPBCDE          ; Move BCDE to FPREG
3784   1B18 EB                  EX      DE,HL           ; Save point in table
3785   1B19 E1                  POP     HL              ; Restore buffer address
3786   1B1A 70                  LD      (HL),B          ; Save digit in buffer
3787   1B1B 23                  INC     HL              ; And move on
3788   1B1C C1                  POP     BC              ; Restore digit count
3789   1B1D 0D                  DEC     C               ; Count digits
3790   1B1E C2 F1 1A            JP      NZ,DIGTXT       ; More - Do them
3791   1B21 05                  DEC     B               ; Any decimal part?
3792   1B22 CA 31 1B            JP      Z,DOEBIT        ; No - Do 'E' bit
3793   1B25 2B          SUPTLZ: DEC     HL              ; Move back through buffer
3794   1B26 7E                  LD      A,(HL)          ; Get character
3795   1B27 FE 30               CP      '0'             ; '0' character?
3796   1B29 CA 25 1B            JP      Z,SUPTLZ        ; Yes - Look back for more
3797   1B2C FE 2E               CP      '.'             ; A decimal point?
3798   1B2E C4 3A 19            CALL    NZ,INCHL        ; Move back over digit
3799   1B31             
3800   1B31 F1          DOEBIT: POP     AF              ; Get 'E' flag
3801   1B32 CA 50 1B            JP      Z,NOENED        ; No 'E' needed - End buffer
3802   1B35 36 45               LD      (HL),'E'        ; Put 'E' in buffer
3803   1B37 23                  INC     HL              ; And move on
3804   1B38 36 2B               LD      (HL),'+'        ; Put '+' in buffer
3805   1B3A F2 41 1B            JP      P,OUTEXP        ; Positive - Output exponent
3806   1B3D 36 2D               LD      (HL),'-'        ; Put '-' in buffer
3807   1B3F 2F                  CPL                     ; Negate exponent
3808   1B40 3C                  INC     A
3809   1B41 06 2F       OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3810   1B43 04          EXPTEN: INC     B               ; Count subtractions
3811   1B44 D6 0A               SUB     10              ; Tens digit
3812   1B46 D2 43 1B            JP      NC,EXPTEN       ; More to do
3813   1B49 C6 3A               ADD     A,'0'+10        ; Restore and make ASCII
3814   1B4B 23                  INC     HL              ; Move on
3815   1B4C 70                  LD      (HL),B          ; Save MSB of exponent
3816   1B4D 23          JSTZER: INC     HL              ;
3817   1B4E 77                  LD      (HL),A          ; Save LSB of exponent
3818   1B4F 23                  INC     HL
3819   1B50 71          NOENED: LD      (HL),C          ; Mark end of buffer
3820   1B51 E1                  POP     HL              ; Restore code string address
3821   1B52 C9                  RET
3822   1B53             
3823   1B53 01 74 94    RNGTST: LD      BC,9474H        ; BCDE = 999999.
3824   1B56 11 F7 23            LD      DE,23F7H
3825   1B59 CD 5F 19            CALL    CMPNUM          ; Compare numbers
3826   1B5C B7                  OR      A
3827   1B5D E1                  POP     HL              ; Return address to HL
3828   1B5E E2 BB 1A            JP      PO,GTSIXD       ; Too big - Divide by ten
3829   1B61 E9                  JP      (HL)            ; Otherwise return to caller
3830   1B62             
3831   1B62 00 00 00 80 HALF:   .BYTE      00H,00H,00H,80H ; 0.5
3832   1B66             
3833   1B66 A0 86 01    POWERS: .BYTE      0A0H,086H,001H  ; 100000
3834   1B69 10 27 00            .BYTE      010H,027H,000H  ;  10000
3835   1B6C E8 03 00            .BYTE      0E8H,003H,000H  ;   1000
3836   1B6F 64 00 00            .BYTE      064H,000H,000H  ;    100
3837   1B72 0A 00 00            .BYTE      00AH,000H,000H  ;     10
3838   1B75 01 00 00            .BYTE      001H,000H,000H  ;      1
3839   1B78             
3840   1B78 21 0D 19    NEGAFT: LD  HL,INVSGN           ; Negate result
3841   1B7B E3                  EX      (SP),HL         ; To be done after caller
3842   1B7C E9                  JP      (HL)            ; Return to caller
3843   1B7D             
3844   1B7D CD 15 19    SQR:    CALL    STAKFP          ; Put value on stack
3845   1B80 21 62 1B            LD      HL,HALF         ; Set power to 1/2
3846   1B83 CD 22 19            CALL    PHLTFP          ; Move 1/2 to FPREG
3847   1B86             
3848   1B86 C1          POWER:  POP     BC              ; Get base
3849   1B87 D1                  POP     DE
3850   1B88 CD E4 18            CALL    TSTSGN          ; Test sign of power
3851   1B8B 78                  LD      A,B             ; Get exponent of base
3852   1B8C CA CB 1B            JP      Z,EXP           ; Make result 1 if zero
3853   1B8F F2 96 1B            JP      P,POWER1        ; Positive base - Ok
3854   1B92 B7                  OR      A               ; Zero to negative power?
3855   1B93 CA 40 06            JP      Z,DZERR         ; Yes - ?/0 Error
3856   1B96 B7          POWER1: OR      A               ; Base zero?
3857   1B97 CA 05 17            JP      Z,SAVEXP        ; Yes - Return zero
3858   1B9A D5                  PUSH    DE              ; Save base
3859   1B9B C5                  PUSH    BC
3860   1B9C 79                  LD      A,C             ; Get MSB of base
3861   1B9D F6 7F               OR      01111111B       ; Get sign status
3862   1B9F CD 30 19            CALL    BCDEFP          ; Move power to BCDE
3863   1BA2 F2 B3 1B            JP      P,POWER2        ; Positive base - Ok
3864   1BA5 D5                  PUSH    DE              ; Save power
3865   1BA6 C5                  PUSH    BC
3866   1BA7 CD B7 19            CALL    INT             ; Get integer of power
3867   1BAA C1                  POP     BC              ; Restore power
3868   1BAB D1                  POP     DE
3869   1BAC F5                  PUSH    AF              ; MSB of base
3870   1BAD CD 5F 19            CALL    CMPNUM          ; Power an integer?
3871   1BB0 E1                  POP     HL              ; Restore MSB of base
3872   1BB1 7C                  LD      A,H             ; but don't affect flags
3873   1BB2 1F                  RRA                     ; Exponent odd or even?
3874   1BB3 E1          POWER2: POP     HL              ; Restore MSB and exponent
3875   1BB4 22 06 22            LD      (FPREG+2),HL    ; Save base in FPREG
3876   1BB7 E1                  POP     HL              ; LSBs of base
3877   1BB8 22 04 22            LD      (FPREG),HL      ; Save in FPREG
3878   1BBB DC 78 1B            CALL    C,NEGAFT        ; Odd power - Negate result
3879   1BBE CC 0D 19            CALL    Z,INVSGN        ; Negative base - Negate it
3880   1BC1 D5                  PUSH    DE              ; Save power
3881   1BC2 C5                  PUSH    BC
3882   1BC3 CD 98 17            CALL    LOG             ; Get LOG of base
3883   1BC6 C1                  POP     BC              ; Restore power
3884   1BC7 D1                  POP     DE
3885   1BC8 CD D9 17            CALL    FPMULT          ; Multiply LOG by power
3886   1BCB             
3887   1BCB CD 15 19    EXP:    CALL    STAKFP          ; Put value on stack
3888   1BCE 01 38 81            LD      BC,08138H       ; BCDE = 1/Ln(2)
3889   1BD1 11 3B AA            LD      DE,0AA3BH
3890   1BD4 CD D9 17            CALL    FPMULT          ; Multiply value by 1/LN(2)
3891   1BD7 3A 07 22            LD      A,(FPEXP)       ; Get exponent
3892   1BDA FE 88               CP      80H+8           ; Is it in range?
3893   1BDC D2 C0 18            JP      NC,OVTST1       ; No - Test for overflow
3894   1BDF CD B7 19            CALL    INT             ; Get INT of FPREG
3895   1BE2 C6 80               ADD     A,80H           ; For excess 128
3896   1BE4 C6 02               ADD     A,2             ; Exponent > 126?
3897   1BE6 DA C0 18            JP      C,OVTST1        ; Yes - Test for overflow
3898   1BE9 F5                  PUSH    AF              ; Save scaling factor
3899   1BEA 21 87 17            LD      HL,UNITY        ; Point to 1.
3900   1BED CD 8F 16            CALL    ADDPHL          ; Add 1 to FPREG
3901   1BF0 CD D0 17            CALL    MULLN2          ; Multiply by LN(2)
3902   1BF3 F1                  POP     AF              ; Restore scaling factor
3903   1BF4 C1                  POP     BC              ; Restore exponent
3904   1BF5 D1                  POP     DE
3905   1BF6 F5                  PUSH    AF              ; Save scaling factor
3906   1BF7 CD 9B 16            CALL    SUBCDE          ; Subtract exponent from FPREG
3907   1BFA CD 0D 19            CALL    INVSGN          ; Negate result
3908   1BFD 21 0B 1C            LD      HL,EXPTAB       ; Coefficient table
3909   1C00 CD 3B 1C            CALL    SMSER1          ; Sum the series
3910   1C03 11 00 00            LD      DE,0            ; Zero LSBs
3911   1C06 C1                  POP     BC              ; Scaling factor
3912   1C07 4A                  LD      C,D             ; Zero MSB
3913   1C08 C3 D9 17            JP      FPMULT          ; Scale result to correct value
3914   1C0B             
3915   1C0B 08          EXPTAB: .BYTE      8                       ; Table used by EXP
3916   1C0C 40 2E 94 74         .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3917   1C10 70 4F 2E 77         .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3918   1C14 6E 02 88 7A         .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
3919   1C18 E6 A0 2A 7C         .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3920   1C1C 50 AA AA 7E         .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3921   1C20 FF FF 7F 7F         .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3922   1C24 00 00 80 81         .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
3923   1C28 00 00 00 81         .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
3924   1C2C             
3925   1C2C CD 15 19    SUMSER: CALL    STAKFP          ; Put FPREG on stack
3926   1C2F 11 D7 17            LD      DE,MULT         ; Multiply by "X"
3927   1C32 D5                  PUSH    DE              ; To be done after
3928   1C33 E5                  PUSH    HL              ; Save address of table
3929   1C34 CD 30 19            CALL    BCDEFP          ; Move FPREG to BCDE
3930   1C37 CD D9 17            CALL    FPMULT          ; Square the value
3931   1C3A E1                  POP     HL              ; Restore address of table
3932   1C3B CD 15 19    SMSER1: CALL    STAKFP          ; Put value on stack
3933   1C3E 7E                  LD      A,(HL)          ; Get number of coefficients
3934   1C3F 23                  INC     HL              ; Point to start of table
3935   1C40 CD 22 19            CALL    PHLTFP          ; Move coefficient to FPREG
3936   1C43 06                  .BYTE      06H             ; Skip "POP AF"
3937   1C44 F1          SUMLP:  POP     AF              ; Restore count
3938   1C45 C1                  POP     BC              ; Restore number
3939   1C46 D1                  POP     DE
3940   1C47 3D                  DEC     A               ; Cont coefficients
3941   1C48 C8                  RET     Z               ; All done
3942   1C49 D5                  PUSH    DE              ; Save number
3943   1C4A C5                  PUSH    BC
3944   1C4B F5                  PUSH    AF              ; Save count
3945   1C4C E5                  PUSH    HL              ; Save address in table
3946   1C4D CD D9 17            CALL    FPMULT          ; Multiply FPREG by BCDE
3947   1C50 E1                  POP     HL              ; Restore address in table
3948   1C51 CD 33 19            CALL    LOADFP          ; Number at HL to BCDE
3949   1C54 E5                  PUSH    HL              ; Save address in table
3950   1C55 CD 9E 16            CALL    FPADD           ; Add coefficient to FPREG
3951   1C58 E1                  POP     HL              ; Restore address in table
3952   1C59 C3 44 1C            JP      SUMLP           ; More coefficients
3953   1C5C             
3954   1C5C CD E4 18    RND:    CALL    TSTSGN          ; Test sign of FPREG
3955   1C5F 21 39 21            LD      HL,SEED+2       ; Random number seed
3956   1C62 FA BD 1C            JP      M,RESEED        ; Negative - Re-seed
3957   1C65 21 5A 21            LD      HL,LSTRND       ; Last random number
3958   1C68 CD 22 19            CALL    PHLTFP          ; Move last RND to FPREG
3959   1C6B 21 39 21            LD      HL,SEED+2       ; Random number seed
3960   1C6E C8                  RET     Z               ; Return if RND(0)
3961   1C6F 86                  ADD     A,(HL)          ; Add (SEED)+2)
3962   1C70 E6 07               AND     00000111B       ; 0 to 7
3963   1C72 06 00               LD      B,0
3964   1C74 77                  LD      (HL),A          ; Re-save seed
3965   1C75 23                  INC     HL              ; Move to coefficient table
3966   1C76 87                  ADD     A,A             ; 4 bytes
3967   1C77 87                  ADD     A,A             ; per entry
3968   1C78 4F                  LD      C,A             ; BC = Offset into table
3969   1C79 09                  ADD     HL,BC           ; Point to coefficient
3970   1C7A CD 33 19            CALL    LOADFP          ; Coefficient to BCDE
3971   1C7D CD D9 17            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3972   1C80 3A 38 21            LD      A,(SEED+1)      ; Get (SEED+1)
3973   1C83 3C                  INC     A               ; Add 1
3974   1C84 E6 03               AND     00000011B       ; 0 to 3
3975   1C86 06 00               LD      B,0
3976   1C88 FE 01               CP      1               ; Is it zero?
3977   1C8A 88                  ADC     A,B             ; Yes - Make it 1
3978   1C8B 32 38 21            LD      (SEED+1),A      ; Re-save seed
3979   1C8E 21 C1 1C            LD      HL,RNDTAB-4     ; Addition table
3980   1C91 87                  ADD     A,A             ; 4 bytes
3981   1C92 87                  ADD     A,A             ; per entry
3982   1C93 4F                  LD      C,A             ; BC = Offset into table
3983   1C94 09                  ADD     HL,BC           ; Point to value
3984   1C95 CD 8F 16            CALL    ADDPHL          ; Add value to FPREG
3985   1C98 CD 30 19    RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3986   1C9B 7B                  LD      A,E             ; Get LSB
3987   1C9C 59                  LD      E,C             ; LSB = MSB
3988   1C9D EE 4F               XOR     01001111B       ; Fiddle around
3989   1C9F 4F                  LD      C,A             ; New MSB
3990   1CA0 36 80               LD      (HL),80H        ; Set exponent
3991   1CA2 2B                  DEC     HL              ; Point to MSB
3992   1CA3 46                  LD      B,(HL)          ; Get MSB
3993   1CA4 36 80               LD      (HL),80H        ; Make value -0.5
3994   1CA6 21 37 21            LD      HL,SEED         ; Random number seed
3995   1CA9 34                  INC     (HL)            ; Count seed
3996   1CAA 7E                  LD      A,(HL)          ; Get seed
3997   1CAB D6 AB               SUB     171             ; Do it modulo 171
3998   1CAD C2 B4 1C            JP      NZ,RND2         ; Non-zero - Ok
3999   1CB0 77                  LD      (HL),A          ; Zero seed
4000   1CB1 0C                  INC     C               ; Fillde about
4001   1CB2 15                  DEC     D               ; with the
4002   1CB3 1C                  INC     E               ; number
4003   1CB4 CD EF 16    RND2:   CALL    BNORM           ; Normalise number
4004   1CB7 21 5A 21            LD      HL,LSTRND       ; Save random number
4005   1CBA C3 3C 19            JP      FPTHL           ; Move FPREG to last and return
4006   1CBD             
4007   1CBD 77          RESEED: LD      (HL),A          ; Re-seed random numbers
4008   1CBE 2B                  DEC     HL
4009   1CBF 77                  LD      (HL),A
4010   1CC0 2B                  DEC     HL
4011   1CC1 77                  LD      (HL),A
4012   1CC2 C3 98 1C            JP      RND1            ; Return RND seed
4013   1CC5             
4014   1CC5 68 B1 46 68 RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
4015   1CC9 99 E9 92 69         .BYTE   099H,0E9H,092H,069H
4016   1CCD 10 D1 75 68         .BYTE   010H,0D1H,075H,068H
4017   1CD1             
4018   1CD1 21 1B 1D    COS:    LD      HL,HALFPI       ; Point to PI/2
4019   1CD4 CD 8F 16            CALL    ADDPHL          ; Add it to PPREG
4020   1CD7 CD 15 19    SIN:    CALL    STAKFP          ; Put angle on stack
4021   1CDA 01 49 83            LD      BC,8349H        ; BCDE = 2 PI
4022   1CDD 11 DB 0F            LD      DE,0FDBH
4023   1CE0 CD 25 19            CALL    FPBCDE          ; Move 2 PI to FPREG
4024   1CE3 C1                  POP     BC              ; Restore angle
4025   1CE4 D1                  POP     DE
4026   1CE5 CD 3A 18            CALL    DVBCDE          ; Divide angle by 2 PI
4027   1CE8 CD 15 19            CALL    STAKFP          ; Put it on stack
4028   1CEB CD B7 19            CALL    INT             ; Get INT of result
4029   1CEE C1                  POP     BC              ; Restore number
4030   1CEF D1                  POP     DE
4031   1CF0 CD 9B 16            CALL    SUBCDE          ; Make it 0 <= value < 1
4032   1CF3 21 1F 1D            LD      HL,QUARTR       ; Point to 0.25
4033   1CF6 CD 95 16            CALL    SUBPHL          ; Subtract value from 0.25
4034   1CF9 CD E4 18            CALL    TSTSGN          ; Test sign of value
4035   1CFC 37                  SCF                     ; Flag positive
4036   1CFD F2 07 1D            JP      P,SIN1          ; Positive - Ok
4037   1D00 CD 8C 16            CALL    ROUND           ; Add 0.5 to value
4038   1D03 CD E4 18            CALL    TSTSGN          ; Test sign of value
4039   1D06 B7                  OR      A               ; Flag negative
4040   1D07 F5          SIN1:   PUSH    AF              ; Save sign
4041   1D08 F4 0D 19            CALL    P,INVSGN        ; Negate value if positive
4042   1D0B 21 1F 1D            LD      HL,QUARTR       ; Point to 0.25
4043   1D0E CD 8F 16            CALL    ADDPHL          ; Add 0.25 to value
4044   1D11 F1                  POP     AF              ; Restore sign
4045   1D12 D4 0D 19            CALL    NC,INVSGN       ; Negative - Make positive
4046   1D15 21 23 1D            LD      HL,SINTAB       ; Coefficient table
4047   1D18 C3 2C 1C            JP      SUMSER          ; Evaluate sum of series
4048   1D1B             
4049   1D1B DB 0F 49 81 HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4050   1D1F             
4051   1D1F 00 00 00 7F QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4052   1D23             
4053   1D23 05          SINTAB: .BYTE   5                       ; Table used by SIN
4054   1D24 BA D7 1E 86         .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4055   1D28 64 26 99 87         .BYTE   064H,026H,099H,087H     ;-76.575
4056   1D2C 58 34 23 87         .BYTE   058H,034H,023H,087H     ; 81.602
4057   1D30 E0 5D A5 86         .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4058   1D34 DA 0F 49 83         .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4059   1D38             
4060   1D38 CD 15 19    TAN:    CALL    STAKFP          ; Put angle on stack
4061   1D3B CD D7 1C            CALL    SIN             ; Get SIN of angle
4062   1D3E C1                  POP     BC              ; Restore angle
4063   1D3F E1                  POP     HL
4064   1D40 CD 15 19            CALL    STAKFP          ; Save SIN of angle
4065   1D43 EB                  EX      DE,HL           ; BCDE = Angle
4066   1D44 CD 25 19            CALL    FPBCDE          ; Angle to FPREG
4067   1D47 CD D1 1C            CALL    COS             ; Get COS of angle
4068   1D4A C3 38 18            JP      DIV             ; TAN = SIN / COS
4069   1D4D             
4070   1D4D CD E4 18    ATN:    CALL    TSTSGN          ; Test sign of value
4071   1D50 FC 78 1B            CALL    M,NEGAFT        ; Negate result after if -ve
4072   1D53 FC 0D 19            CALL    M,INVSGN        ; Negate value if -ve
4073   1D56 3A 07 22            LD      A,(FPEXP)       ; Get exponent
4074   1D59 FE 81               CP      81H             ; Number less than 1?
4075   1D5B DA 6A 1D            JP      C,ATN1          ; Yes - Get arc tangnt
4076   1D5E 01 00 81            LD      BC,8100H        ; BCDE = 1
4077   1D61 51                  LD      D,C
4078   1D62 59                  LD      E,C
4079   1D63 CD 3A 18            CALL    DVBCDE          ; Get reciprocal of number
4080   1D66 21 95 16            LD      HL,SUBPHL       ; Sub angle from PI/2
4081   1D69 E5                  PUSH    HL              ; Save for angle > 1
4082   1D6A 21 74 1D    ATN1:   LD      HL,ATNTAB       ; Coefficient table
4083   1D6D CD 2C 1C            CALL    SUMSER          ; Evaluate sum of series
4084   1D70 21 1B 1D            LD      HL,HALFPI       ; PI/2 - angle in case > 1
4085   1D73 C9                  RET                     ; Number > 1 - Sub from PI/2
4086   1D74             
4087   1D74 09          ATNTAB: .BYTE   9                       ; Table used by ATN
4088   1D75 4A D7 3B 78         .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4089   1D79 02 6E 84 7B         .BYTE   002H,06EH,084H,07BH     ;-1/15
4090   1D7D FE C1 2F 7C         .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4091   1D81 74 31 9A 7D         .BYTE   074H,031H,09AH,07DH     ;-1/11
4092   1D85 84 3D 5A 7D         .BYTE   084H,03DH,05AH,07DH     ; 1/9
4093   1D89 C8 7F 91 7E         .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4094   1D8D E4 BB 4C 7E         .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4095   1D91 6C AA AA 7F         .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4096   1D95 00 00 00 81         .BYTE   000H,000H,000H,081H     ; 1/1
4097   1D99             
4098   1D99             
4099   1D99 C9          ARET:   RET                     ; A RETurn instruction
4100   1D9A             
4101   1D9A D7          GETINP: RST	    10H             ;input a character
4102   1D9B C9                  RET
4103   1D9C             
4104   1D9C             CLS: 
4105   1D9C 3E 0C               LD      A,CS            ; ASCII Clear screen
4106   1D9E C3 D6 1E            JP      MONOUT          ; Output character
4107   1DA1             
4108   1DA1 CD 63 16    WIDTH:  CALL    GETINT          ; Get integer 0-255
4109   1DA4 7B                  LD      A,E             ; Width to A
4110   1DA5 32 62 21            LD      (LWIDTH),A      ; Set width
4111   1DA8 C9                  RET
4112   1DA9             
4113   1DA9 CD 02 0F    LINES:  CALL    GETNUM          ; Get a number
4114   1DAC CD 47 0B            CALL    DEINT           ; Get integer -32768 to 32767
4115   1DAF ED 53 66 21         LD      (LINESC),DE     ; Set lines counter
4116   1DB3 ED 53 68 21         LD      (LINESN),DE     ; Set lines number
4117   1DB7 C9                  RET
4118   1DB8             
4119   1DB8 CD 47 0B    DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4120   1DBB D5                  PUSH    DE              ; Save number
4121   1DBC E1                  POP     HL              ; Number to HL
4122   1DBD 46                  LD      B,(HL)          ; Get LSB of contents
4123   1DBE 23                  INC     HL
4124   1DBF 7E                  LD      A,(HL)          ; Get MSB of contents
4125   1DC0 C3 BD 12            JP      ABPASS          ; Return integer AB
4126   1DC3             
4127   1DC3 CD 02 0F    DOKE:   CALL    GETNUM          ; Get a number
4128   1DC6 CD 47 0B            CALL    DEINT           ; Get integer -32768 to 32767
4129   1DC9 D5                  PUSH    DE              ; Save address
4130   1DCA CD 0B 09            CALL    CHKSYN          ; Make sure ',' follows
4131   1DCD 2C                  .BYTE      ','
4132   1DCE CD 02 0F            CALL    GETNUM          ; Get a number
4133   1DD1 CD 47 0B            CALL    DEINT           ; Get integer -32768 to 32767
4134   1DD4 E3                  EX      (SP),HL         ; Save value,get address
4135   1DD5 73                  LD      (HL),E          ; Save LSB of value
4136   1DD6 23                  INC     HL
4137   1DD7 72                  LD      (HL),D          ; Save MSB of value
4138   1DD8 E1                  POP     HL              ; Restore code string address
4139   1DD9 C9                  RET
4140   1DDA             
4141   1DDA             
4142   1DDA             ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4143   1DDA             
4144   1DDA CD 05 0F    HEX: 	CALL	TSTNUM          ; Verify it's a number
4145   1DDD CD 47 0B            CALL	DEINT           ; Get integer -32768 to 32767
4146   1DE0 C5                  PUSH	BC              ; Save contents of BC
4147   1DE1 21 09 22            LD	    HL,PBUFF
4148   1DE4 7A                  LD	    A,D             ; Get high order into A
4149   1DE5 FE 00               CP      $0
4150   1DE7 28 0C       		JR      Z,HEX2          ; Skip output if both high digits are zero
4151   1DE9 CD 12 1E            CALL    BYT2ASC         ; Convert D to ASCII
4152   1DEC 78          		LD      A,B
4153   1DED FE 30       		CP      '0'
4154   1DEF 28 02       		JR      Z,HEX1          ; Don't store high digit if zero
4155   1DF1 70                  LD	    (HL),B          ; Store it to PBUFF
4156   1DF2 23                  INC	    HL              ; Next location
4157   1DF3 71          HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4158   1DF4 23                  INC     HL              ; Next location
4159   1DF5 7B          HEX2:   LD	    A,E             ; Get lower byte
4160   1DF6 CD 12 1E            CALL    BYT2ASC         ; Convert E to ASCII
4161   1DF9 7A          		LD      A,D
4162   1DFA FE 00               CP      $0
4163   1DFC 20 05       		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4164   1DFE 78          		LD      A,B
4165   1DFF FE 30       		CP      '0'             ; If high digit of lower byte is zero then don't print
4166   1E01 28 02       		JR      Z,HEX4
4167   1E03 70          HEX3:   LD      (HL),B          ; to PBUFF+2
4168   1E04 23                  INC     HL              ; Next location
4169   1E05 71          HEX4:   LD      (HL),C          ; to PBUFF+3
4170   1E06 23                  INC     HL              ; PBUFF+4 to zero
4171   1E07 AF                  XOR     A               ; Terminating character
4172   1E08 77                  LD      (HL),A          ; Store zero to terminate
4173   1E09 23                  INC     HL              ; Make sure PBUFF is terminated
4174   1E0A 77                  LD      (HL),A          ; Store the double zero there
4175   1E0B C1                  POP     BC              ; Get BC back
4176   1E0C 21 09 22            LD      HL,PBUFF        ; Reset to start of PBUFF
4177   1E0F C3 6B 13            JP      STR1            ; Convert the PBUFF to a string and return it
4178   1E12             
4179   1E12 47          BYT2ASC	LD      B,A             ; Save original value
4180   1E13 E6 0F               AND     $0F             ; Strip off upper nybble
4181   1E15 FE 0A               CP      $0A             ; 0-9?
4182   1E17 38 02               JR      C,ADD30         ; If A-F, add 7 more
4183   1E19 C6 07               ADD     A,$07           ; Bring value up to ASCII A-F
4184   1E1B C6 30       ADD30	ADD     A,$30           ; And make ASCII
4185   1E1D 4F                  LD      C,A             ; Save converted char to C
4186   1E1E 78                  LD      A,B             ; Retrieve original value
4187   1E1F 0F                  RRCA                    ; and Rotate it right
4188   1E20 0F                  RRCA
4189   1E21 0F                  RRCA
4190   1E22 0F                  RRCA
4191   1E23 E6 0F               AND     $0F             ; Mask off upper nybble
4192   1E25 FE 0A               CP      $0A             ; 0-9? < A hex?
4193   1E27 38 02               JR      C,ADD301        ; Skip Add 7
4194   1E29 C6 07               ADD     A,$07           ; Bring it up to ASCII A-F
4195   1E2B C6 30       ADD301	ADD     A,$30           ; And make it full ASCII
4196   1E2D 47                  LD      B,A             ; Store high order byte
4197   1E2E C9                  RET	
4198   1E2F             
4199   1E2F             ; Convert "&Hnnnn" to FPREG
4200   1E2F             ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4201   1E2F             ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4202   1E2F EB          HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4203   1E30 21 00 00            LD      HL,$0000        ; Zero out the value
4204   1E33 CD 48 1E            CALL    GETHEX          ; Check the number for valid hex
4205   1E36 DA 68 1E            JP      C,HXERR         ; First value wasn't hex, HX error
4206   1E39 18 05               JR      HEXLP1          ; Convert first character
4207   1E3B CD 48 1E    HEXLP   CALL    GETHEX          ; Get second and addtional characters
4208   1E3E 38 1F               JR      C,HEXIT         ; Exit if not a hex character
4209   1E40 29          HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4210   1E41 29                  ADD     HL,HL
4211   1E42 29                  ADD     HL,HL
4212   1E43 29                  ADD     HL,HL
4213   1E44 B5                  OR      L               ; Add in D0-D3 into L
4214   1E45 6F                  LD      L,A             ; Save new value
4215   1E46 18 F3               JR      HEXLP           ; And continue until all hex characters are in
4216   1E48             
4217   1E48 13          GETHEX  INC     DE              ; Next location
4218   1E49 1A                  LD      A,(DE)          ; Load character at pointer
4219   1E4A FE 20               CP      ' '
4220   1E4C CA 48 1E            JP      Z,GETHEX        ; Skip spaces
4221   1E4F D6 30               SUB     $30             ; Get absolute value
4222   1E51 D8                  RET     C               ; < "0", error
4223   1E52 FE 0A               CP      $0A
4224   1E54 38 05               JR      C,NOSUB7        ; Is already in the range 0-9
4225   1E56 D6 07               SUB     $07             ; Reduce to A-F
4226   1E58 FE 0A               CP      $0A             ; Value should be $0A-$0F at this point
4227   1E5A D8                  RET     C               ; CY set if was :            ; < = > ? @
4228   1E5B FE 10       NOSUB7  CP      $10             ; > Greater than "F"?
4229   1E5D 3F                  CCF
4230   1E5E C9                  RET                     ; CY set if it wasn't valid hex
4231   1E5F                 
4232   1E5F EB          HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4233   1E60 7A                  LD      A,D             ; Load DE into AC
4234   1E61 4B                  LD      C,E             ; For prep to 
4235   1E62 E5                  PUSH    HL
4236   1E63 CD BC 12            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4237   1E66 E1                  POP     HL
4238   1E67 C9                  RET
4239   1E68             
4240   1E68 1E 26       HXERR:  LD      E,HX            ; ?HEX Error
4241   1E6A C3 51 06            JP      ERROR
4242   1E6D             
4243   1E6D             ; BIN$(NN) Convert integer to a 1-16 char binary string
4244   1E6D CD 05 0F    BIN:    CALL    TSTNUM          ; Verify it's a number
4245   1E70 CD 47 0B            CALL    DEINT           ; Get integer -32768 to 32767
4246   1E73 C5          BIN2:   PUSH    BC              ; Save contents of BC
4247   1E74 21 09 22            LD      HL,PBUFF
4248   1E77 06 11               LD      B,17            ; One higher than max char count
4249   1E79             ZEROSUP:                        ; Suppress leading zeros
4250   1E79 05                  DEC     B               ; Max 16 chars
4251   1E7A 78                  LD      A,B
4252   1E7B FE 01               CP      $01
4253   1E7D 28 08               JR      Z,BITOUT        ; Always output at least one character
4254   1E7F CB 13               RL      E
4255   1E81 CB 12               RL      D
4256   1E83 30 F4               JR      NC,ZEROSUP
4257   1E85 18 04               JR      BITOUT2
4258   1E87             BITOUT:      
4259   1E87 CB 13               RL      E
4260   1E89 CB 12               RL      D               ; Top bit now in carry
4261   1E8B             BITOUT2:
4262   1E8B 3E 30               LD      A,'0'           ; Char for '0'
4263   1E8D CE 00               ADC     A,0             ; If carry set then '0' --> '1'
4264   1E8F 77                  LD      (HL),A
4265   1E90 23                  INC     HL
4266   1E91 05                  DEC     B
4267   1E92 20 F3               JR      NZ,BITOUT
4268   1E94 AF                  XOR     A               ; Terminating character
4269   1E95 77                  LD      (HL),A          ; Store zero to terminate
4270   1E96 23                  INC     HL              ; Make sure PBUFF is terminated
4271   1E97 77                  LD      (HL),A          ; Store the double zero there
4272   1E98 C1                  POP     BC
4273   1E99 21 09 22            LD      HL,PBUFF
4274   1E9C C3 6B 13            JP      STR1
4275   1E9F             
4276   1E9F             ; Convert "&Bnnnn" to FPREG
4277   1E9F             ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4278   1E9F EB          BINTFP: EX      DE,HL           ; Move code string pointer to DE
4279   1EA0 21 00 00            LD      HL,$0000        ; Zero out the value
4280   1EA3 CD BC 1E            CALL    CHKBIN          ; Check the number for valid bin
4281   1EA6 DA CA 1E            JP      C,BINERR        ; First value wasn't bin, HX error
4282   1EA9 D6 30       BINIT:  SUB     '0'
4283   1EAB 29                  ADD     HL,HL           ; Rotate HL left
4284   1EAC B5                  OR      L
4285   1EAD 6F                  LD      L,A
4286   1EAE CD BC 1E            CALL    CHKBIN          ; Get second and addtional characters
4287   1EB1 30 F6               JR      NC,BINIT        ; Process if a bin character
4288   1EB3 EB                  EX      DE,HL           ; Value into DE, Code string into HL
4289   1EB4 7A                  LD      A,D             ; Load DE into AC
4290   1EB5 4B                  LD      C,E             ; For prep to 
4291   1EB6 E5                  PUSH    HL
4292   1EB7 CD BC 12            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4293   1EBA E1                  POP     HL
4294   1EBB C9                  RET
4295   1EBC             
4296   1EBC             ; Char is in A, NC if char is 0 or 1
4297   1EBC 13          CHKBIN: INC     DE
4298   1EBD 1A                  LD      A,(DE)
4299   1EBE FE 20               CP      ' '
4300   1EC0 CA BC 1E            JP      Z,CHKBIN        ; Skip spaces
4301   1EC3 FE 30               CP      '0'             ; Set C if < '0'
4302   1EC5 D8                  RET     C
4303   1EC6 FE 32               CP      '2'
4304   1EC8 3F                  CCF                     ; Set C if > '1'
4305   1EC9 C9                  RET
4306   1ECA             
4307   1ECA 1E 28       BINERR: LD      E,BN            ; ?BIN Error
4308   1ECC C3 51 06            JP      ERROR
4309   1ECF             
4310   1ECF             
4311   1ECF             JJUMP1: 
4312   1ECF DD 21 FF FF         LD      IX,-1           ; Flag cold start
4313   1ED3 C3 A1 02            JP      CSTART          ; Go and initialise
4314   1ED6             
4315   1ED6             MONOUT: 
4316   1ED6 C3 08 00            JP      $0008           ; output a char
4317   1ED9             
4318   1ED9             
4319   1ED9             MONITR: 
4320   1ED9 C3 00 00            JP      $0000           ; Restart (Normally Monitor Start)
4321   1EDC             
4322   1EDC             
4323   1EDC 3E 00       INITST: LD      A,0             ; Clear break flag
4324   1EDE 32 6D 21            LD      (BRKFLG),A
4325   1EE1 C3 A8 02            JP      INIT
4326   1EE4             
4327   1EE4 ED 45       ARETN:  RETN                    ; Return from NMI
4328   1EE6             
4329   1EE6             
4330   1EE6 F5          TSTBIT: PUSH    AF              ; Save bit mask
4331   1EE7 A0                  AND     B               ; Get common bits
4332   1EE8 C1                  POP     BC              ; Restore bit mask
4333   1EE9 B8                  CP      B               ; Same bit set?
4334   1EEA 3E 00               LD      A,0             ; Return 0 in A
4335   1EEC C9                  RET
4336   1EED             
4337   1EED CD 16 09    OUTNCR: CALL    OUTC            ; Output character in A
4338   1EF0 C3 3D 0D            JP      PRNTCRLF        ; Output CRLF
4339   1EF3             
4340   1EF3             .end
4341   1EF3             



Label        Value      Label        Value      Label        Value
------------------      ------------------      ------------------
ARREND        21FA      ACCSUM        0B26      ATOH          0B61      
ASPCS         0D88      ANTVLU        0E26      ARLDSV        11DD      
ACPASS        12BC      ABPASS        12BD      ARRLP         1456      
ASC           155C      ALLFOL        158B      ADDPHL        168F      
ADDEXP        18A2      ABS           1909      ASCTFP        19EB      
ADDIG         1A48      ATN           1D4D      ATN1          1D6A      
ATNTAB        1D74      ARET          1D99      ADD30         1E1B      
ADD301        1E2B      ARETN         1EE4      BKSP          0008      
BRKFLG        216D      BASTXT        217E      BUFFER        2181      
BRKLIN        21EE      BS            0010      BN            0028      
BRKRET        0337      BFREE         033D      BRKMSG        05E0      
BAKSTK        05E6      BRK           0AD8      BADINP        0DAD      
BSERR         1210      BAKTMP        153C      BNORM         16EF      
BNRMLP        16F2      BYTSFT        1827      BCDEFP        1930      
BYT2ASC       1E12      BIN           1E6D      BIN2          1E73      
BITOUT        1E87      BITOUT2       1E8B      BINTFP        1E9F      
BINIT         1EA9      BINERR        1ECA      CTRLC         0003      
CTRLG         0007      CS            000C      CR            000D      
CTRLO         000F      CTRLQ         0011      CTRLR         0012      
CTRLS         0013      CTRLU         0015      COMMAN        2163      
CTLOFG        2165      CHKSUM        216A      CURPOS        21CB      
CUROPR        21E5      CONTAD        21F4      CN            0020      
COLD          0290      CSTART        02A1      COPY          02B0      
CHKSTK        061A      CLRPTR        074A      CLREG         076F      
CRUNCH        0799      CRNCLP        07A2      CPYLIT        0841      
CPDEHL        0905      CHKSYN        090B      CLOTST        0940      
COUNT         09B0      CONT          0B0B      CHKLTR        0B33      
CLEAR         0B86      CRESTR        0C85      CHKTYP        0F07      
CONVAR        0FF2      CMPLOG        1085      CMPLG1        1087      
CMPSTR        10B1      CMPRES        10C9      CHARTY        1121      
CFEVAL        1173      CREARY        1215      CRARLP        1230      
CHEKFN        1354      CRTMST        138D      CRTST         1399      
CRTSTE        13AF      CONCAT        14D1      CHR           156D      
CONPOS        16EC      COMPL         174F      CMPNUM        195F      
CMPFP         1979      CNVNUM        19F7      CONEXP        1A27      
COS           1CD1      CLS           1D9C      CHKBIN        1EBC      
DEL           007F      DIVSUP        2129      DIV1          212A      
DIV2          212E      DIV3          2132      DIV4          2135      
DATFLG        21CE      DATLIN        21E9      DD            0012      
DZ            0014      DATSNR        0637      DZERR         0640      
DDERR         0646      DOAGN         0788      DODEL         0851      
DELCHR        0871      DINPOS        093A      DEPINT        0B41      
DEINT         0B47      DATA          0C2C      DONULL        0D47      
DOCOM         0D59      DOTAB         0D70      DOSPC         0D83      
DIMRET        10EA      DIM           10F3      DEFSIZ        1238      
DEF           12D1      DOFN          12FE      DTSTR         139D      
DIV10         182C      DIV           1838      DVBCDE        183A      
DIVLP         185F      DETHL4        193F      DETHLB        1941      
DCBCDE        19B0      DPOINT        1A23      DIGTXT        1AF1      
DOEBIT        1B31      DEEK          1DB8      DOKE          1DC3      
ESC           001B      ERRLIN        21F2      ERRORS        0544      
ERRMSG        05CE      ENFMEM        0623      ERROR         0651      
ERRIN         0671      ENDBUF        0848      ECHDEL        0865      
EXCUTE        0A75      ENDPRG        0AE7      ENDINP        0D38      
EXTIG         0E82      EVAL          0F14      EVAL1         0F17      
EVAL2         0F20      EVAL3         0F23      EVLPAR        0FD9      
EVNOT         10D3      ENDNAM        1115      ENDDIM        1297      
EXPLP         1A15      ENDCON        1A36      EDIGIT        1A6A      
EXPTEN        1B43      EXP           1BCB      EXPTAB        1C0B      
FORFLG        21EB      FNRGNM        21FE      FNARG         2200      
FPREG         2204      FPEXP         2207      FC            0008      
FNCTAB        038E      FNDEND        071D      FNDWRD        07CC      
FNDTOK        098F      FOR           09DC      FORSLP        09F0      
FORFND        0A0C      FPSINT        0B3B      FCERR         0B5C      
FDTLP         0E93      FANDT         0EAC      FOPRND        0F4C      
FRMEVL        0FF5      FNOFST        1003      FNVAL         102A      
FNDVAR        115A      FNTHR         1168      FNDARY        11E3      
FINDEL        1273      FNDELP        1278      FRE           129B      
FRENUM        12B7      FNDNUM        1660      FPADD         169E      
FPROND        1736      FPMULT        17D9      FLGDIF        18EF      
FLGREL        18F6      FPBCDE        1925      FPTHL         193C      
FPINT         198C      GETCMD        0695      GETNXT        07E7      
GETLIN        0882      GETCHR        0A95      GETLN         0B62      
GTLNLP        0B65      GOSUB         0BD8      GOTO          0BE9      
GTVLUS        0DFE      GETNUM        0F02      GOFUNC        1032      
GETVAR        10F8      GTFNAM        10FD      GRBDON        13F6      
GARBGE        141E      GARBLP        1421      GRBLP         142F      
GNXARY        1455      GRBARY        1475      GETSTR        151B      
GSTRCU        151E      GSTRHL        1521      GSTRDE        1522      
GETLEN        1551      GTFLNM        1560      GETINT        1663      
GTSIXD        1ABB      GETINP        1D9A      GETHEX        1E48      
HX            0026      HALF          1B62      HALFPI        1D1B      
HEX           1DDA      HEX1          1DF3      HEX2          1DF5      
HEX3          1E03      HEX4          1E05      HEXTFP        1E2F      
HEXLP         1E3B      HEXLP1        1E40      HEXIT         1E5F      
HXERR         1E68      INPSUB        215E      INPORT        215F      
ID            0016      INIT          02A8      INITAB        056E      
INITBE        05CE      INMSG         05D5      INDFND        0600      
INEWLN        06E5      INTVAR        0759      INCLEN        0936      
IFJMP         0A7C      INPBRK        0AE4      IF            0CBB      
IFGO          0CC9      INPUT         0DBE      ITMSEP        0E41      
INPBIN        0E50      IDTEST        1346      INP           1620      
INVSGN        190D      INCHL         193A      INT           19B7      
INRNG         1AC4      INITST        1EDC      JSTZER        1B4D      
JJUMP1        1ECF      KILIN         087C      KILFOR        0EF2      
LF            000A      LSTRND        215A      LWIDTH        2162      
LINESC        2166      LINESN        2168      LINEAT        217C      
LCRFLG        21CC      LSTRAM        21CF      LOOPST        21E7      
LSTBIN        21EC      LS            001C      LOKFOR        05EA      
LINFND        06CE      LIST          0951      LISTLP        095D      
LSTLP2        097D      LSTLP3        0980      LET           0C43      
LETSTR        0C5E      LETNUM        0C96      LTSTND        0E5B      
LEN           154D      LEFT          157D      LFRGNM        1616      
LOGTAB        178B      LOG           1798      LOADFP        1933      
LINEIN        1A76      LINES         1DA9      MULVAL        2216      
MO            0024      MSIZE         02C5      MLOOP         02D8      
MEMMSG        0383      MOVUP         0609      MOVSTR        060C      
MOVLP         060F      MOVBUF        0704      MATCH         0819      
MOVDIR        0821      MORINP        088B      MVSTPT        0C8D      
MRPRNT        0CDB      MORDT         0E67      MINUS         0FE1      
MKTMST        138A      MID1          1583      MID           15B7      
MIDNUM        161B      MAKINT        1666      MINCDE        16DE      
MULLN2        17D0      MULT          17D7      MULT8         17FB      
MUL8LP        1804      MLSP10        18CD      MLDEBC        19D0      
MLDBLP        19D8      MANLP         19FF      MULTEN        1A41      
MAKNUM        1AE0      MONOUT        1ED6      MONITR        1ED9      
NULLS         2161      NULFLG        2164      NMIFLG        216C      
NXTOPR        21F0      NXTDAT        21FC      NF            0000      
NFERR         0643      NEW           0749      NXTBYT        07F7      
NOSPC         0808      NOCHNG        0811      NXTCHR        0838      
NOLIN         0AFA      NULL          0B1E      NXTDTA        0C2B      
NXTSTL        0C32      NXTSTT        0C35      NULLP         0D4E      
NEXITM        0D93      NOPMPT        0DD8      NXTITM        0DF2      
NEDMOR        0DFA      NEXT          0EB7      NEXT1         0EBA      
NOTAMP        0FB6      NOTSTR        1130      NSCFOR        1140      
NXTARY        11F7      NOXOR         1646      NOSWAP        16B8      
NORMAL        1709      NOMADD        1815      NOMLAD        19E6      
NUMASC        1A89      NOENED        1B50      NEGAFT        1B78      
NOSUB7        1E5B      OUTSUB        2126      OTPORT        2127      
OD            0006      OV            000A      OM            000C      
OS            001A      OKMSG         05DA      OMERR         0632      
OVERR         064C      OTKLN         0879      OUTIT         08F7      
OUTNBS        08FD      OUTC          0916      OUTWRD        0999      
ONJMP         0A7D      ON            0C9D      ONGO          0CAC      
ONGOLP        0CAD      OPNPAR        0F10      OPRND         0F8B      
OVTST1        18C0      OVTST2        18C5      OVTST3        18C6      
OUTEXP        1B41      OUTNCR        1EED      POINT         2171      
PSET          2174      PROGND        21F6      PBUFF         2209      
PROGST        2219      PRITAB        052F      POPNOK        0687      
PRNTOK        0688      PTRLP         0711      PROMPT        078C      
PROCES        08A4      PUTBUF        08E3      PUTCTL        08E8      
PUTFID        0A51      PEND          0ADF      POSINT        0B3E      
PRINT         0CDF      PRNTLP        0CE2      PRNTNB        0D25      
PRNTST        0D29      PRNTCRLF      0D3D      POR           104B      
PAND          104C      POR1          106E      POS           12C9      
PASSA         12CC      PRNUMS        13DA      PRS           13DB      
PRS1          13DE      PRSLP         13E5      POPAF         1410      
POPHL         153A      POUT          162C      PEEK          1674      
POKE          167B      PSUB          1699      PNORM         1711      
PLUCDE        1743      POPHRT        1825      PHLTFP        1922      
PADD          1A65      PRNTHL        1A7E      POWERS        1B66      
POWER         1B86      POWER1        1B96      POWER2        1BB3      
QTSTR         139A      QTSTLP        13A0      QUARTR        1D1F      
RINPUT        216E      RESET         2177      READFG        21ED      
RG            0004      RUNFST        0755      RETNAD        081D      
RSLNBK        09D3      RUNCNT        0A55      RESTOR        0AA5      
RESTNL        0ABA      RUN           0BCC      RUNLIN        0BE8      
RETURN        0C07      RETLIN        0C26      REM           0C2E      
REDO          0D9A      READ          0DED      RLTLP         0F30      
RETNUM        0FED      RETADR        11A7      RETNUL        11AA      
RIGHT1        1581      RIGHT         15AD      RSTSTR        15D0      
ROUND         168C      RESZER        1704      RONDUP        1724      
RONDB         1725      RESDIV        1872      RETREL        18ED      
RETINT        18FB      RSCALE        1A5F      RNGTST        1B53      
RND           1C5C      RND1          1C98      RND2          1CB4      
RESEED        1CBD      RNDTAB        1CC5      SEED          2137      
STRSPC        217A      STACK         2186      STRBOT        21E3      
SGNRES        2208      STLOOK        227D      SN            0002      
ST            001E      STARTB        0296      SETTOP        02FC      
SIGNON        034C      SNERR         063D      SFTPRG        06D6      
SETPTR        070C      SRCHLN        0729      SRCHLP        072C      
SEARCH        07E5      SETLIT        082F      SETLIN        09A7      
SAVSTP        0A48      STALL         0ACE      STOP          0ADD      
STORED        0BA9      STTLIN        0D30      SPCLP         0D8C      
STRENT        0E44      STKTHS        0F74      SGNEXP        103B      
SVNAM2        1114      SBSCPT        11B5      SCPTLP        11BB      
STR           1365      STR1          136B      SAVSTR        1375      
SVSTAD        1393      SMPVAR        1440      STPOOL        1483      
STRADD        1486      SCNEND        14AC      SSTSA         1508      
SETIO         1650      SUBPHL        1695      SUBCDE        169B      
SAVEXP        1705      SCALE         1763      SCALLP        1765      
SHRITE        1772      SHRLP         1775      SHRT1         1779      
SGN           18F3      STAKFP        1915      SIGNS         194A      
SCALMI        1A2A      SCALPL        1A40      SPCFST        1A97      
SIXDIG        1AA6      SUPTLZ        1B25      SQR           1B7D      
SUMSER        1C2C      SMSER1        1C3B      SUMLP         1C44      
SIN           1CD7      SIN1          1D07      SINTAB        1D23      
TYPE          21CD      TMSTPT        21D1      TMSTPL        21D3      
TMPSTR        21DF      TM            0018      TSTMEM        02EA      
TMERR         064F      TSTREM        0832      TTYLIN        0882      
TSTBRK        0AC0      TSTNUM        0F05      TSTSTR        0F06      
TSTRED        1073      TSTOPL        13BB      TESTR         13F4      
TESTOS        1412      TOSTRA        1511      TSALP         1512      
TOPOOL        1579      TSTSGN        18E4      TRYAGN        1B00      
TAN           1D38      TSTBIT        1EE6      USR           2123      
UL            000E      UF            0022      UFERR         0649      
UPDATA        0ABB      ULERR         0C02      UNITY         1787      
VAREND        21F8      VAL           15E7      VAL1          1605      
VAL2          160F      VAL3          1612      WRKSPC        2120      
WARM          0293      WARMST        0334      WORDS         03C6      
WORDTB        04E5      WAIT          1632      WAITLP        1647      
WIDTH         1DA1      ZEND          0080      ZFOR          0081      
ZDATA         0083      ZGOTO         0088      ZGOSUB        008C      
ZREM          008E      ZPRINT        009E      ZNEW          00A4      
ZTAB          00A5      ZTO           00A6      ZFN           00A7      
ZSPC          00A8      ZTHEN         00A9      ZNOT          00AA      
ZSTEP         00AB      ZPLUS         00AC      ZMINUS        00AD      
ZTIMES        00AE      ZDIV          00AF      ZOR           00B2      
ZGTR          00B3      ZEQUAL        00B4      ZLTH          00B5      
ZSGN          00B6      ZPOINT        00C7      ZLEFT         00CF      
ZERBYT        05D9      ZONELP        0D67      ZEROLP        1199      
ZERARY        1256      ZEROSUP       1E79      

tasm: Number of errors = 0
