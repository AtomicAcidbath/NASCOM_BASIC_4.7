0001   0000             ;==================================================================================
0002   0000             ; The updates to the original BASIC within this file are copyright Grant Searle
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; http://searle.hostei.com/grant/index.html
0008   0000             ;
0009   0000             ; eMail: home.micros01@btinternet.com
0010   0000             ;
0011   0000             ; If the above don't work, please perform an Internet search to see if I have
0012   0000             ; updated the web page hosting service.
0013   0000             ;
0014   0000             ;==================================================================================
0015   0000             
0016   0000             ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
0017   0000             ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
0018   0000             ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
0019   0000             ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
0020   0000             ; the original ROM code (checksum A934H). PA
0021   0000             
0022   0000             ; GENERAL EQUATES
0023   0000             
0024   0000             CTRLC   .EQU    03H             ; Control "C"
0025   0000             CTRLG   .EQU    07H             ; Control "G"
0026   0000             BKSP    .EQU    08H             ; Back space
0027   0000             LF      .EQU    0AH             ; Line feed
0028   0000             CS      .EQU    0CH             ; Clear screen
0029   0000             CR      .EQU    0DH             ; Carriage return
0030   0000             CTRLO   .EQU    0FH             ; Control "O"
0031   0000             CTRLQ	.EQU	11H		; Control "Q"
0032   0000             CTRLR   .EQU    12H             ; Control "R"
0033   0000             CTRLS   .EQU    13H             ; Control "S"
0034   0000             CTRLU   .EQU    15H             ; Control "U"
0035   0000             ESC     .EQU    1BH             ; Escape
0036   0000             DEL     .EQU    7FH             ; Delete
0037   0000             
0038   0000             ; BASIC WORK SPACE LOCATIONS
0039   0000             
0040   0000             WRKSPC  .EQU    2120H           ; <<<< BASIC Work space ** larger Rx buffer & Tx buffer **
0041   0000             USR     .EQU    WRKSPC+3H       ; "USR (x)" jump
0042   0000             OUTSUB  .EQU    WRKSPC+6H       ; "OUT p,n"
0043   0000             OTPORT  .EQU    WRKSPC+7H       ; Port (p)
0044   0000             DIVSUP  .EQU    WRKSPC+9H       ; Division support routine
0045   0000             DIV1    .EQU    WRKSPC+0AH      ; <- Values
0046   0000             DIV2    .EQU    WRKSPC+0EH      ; <-   to
0047   0000             DIV3    .EQU    WRKSPC+12H      ; <-   be
0048   0000             DIV4    .EQU    WRKSPC+15H      ; <-inserted
0049   0000             SEED    .EQU    WRKSPC+17H      ; Random number seed
0050   0000             LSTRND  .EQU    WRKSPC+3AH      ; Last random number
0051   0000             INPSUB  .EQU    WRKSPC+3EH      ; #INP (x)" Routine
0052   0000             INPORT  .EQU    WRKSPC+3FH      ; PORT (x)
0053   0000             NULLS   .EQU    WRKSPC+41H      ; Number of nulls
0054   0000             LWIDTH  .EQU    WRKSPC+42H      ; Terminal width
0055   0000             COMMAN  .EQU    WRKSPC+43H      ; Width for commas
0056   0000             NULFLG  .EQU    WRKSPC+44H      ; Null after input byte flag
0057   0000             CTLOFG  .EQU    WRKSPC+45H      ; Control "O" flag
0058   0000             LINESC  .EQU    WRKSPC+46H      ; Lines counter
0059   0000             LINESN  .EQU    WRKSPC+48H      ; Lines number
0060   0000             CHKSUM  .EQU    WRKSPC+4AH      ; Array load/save check sum
0061   0000             NMIFLG  .EQU    WRKSPC+4CH      ; Flag for NMI break routine
0062   0000             BRKFLG  .EQU    WRKSPC+4DH      ; Break flag
0063   0000             RINPUT  .EQU    WRKSPC+4EH      ; Input reflection
0064   0000             POINT   .EQU    WRKSPC+51H      ; "POINT" reflection (unused)
0065   0000             PSET    .EQU    WRKSPC+54H      ; "SET"   reflection
0066   0000             RESET   .EQU    WRKSPC+57H      ; "RESET" reflection
0067   0000             STRSPC  .EQU    WRKSPC+5AH      ; Bottom of string space
0068   0000             LINEAT  .EQU    WRKSPC+5CH      ; Current line number
0069   0000             BASTXT  .EQU    WRKSPC+5EH      ; Pointer to start of program
0070   0000             BUFFER  .EQU    WRKSPC+61H      ; Input buffer
0071   0000             STACK   .EQU    WRKSPC+66H      ; Initial stack
0072   0000             CURPOS  .EQU    WRKSPC+0ABH     ; <<<< Character position on line ** Top of TEMPSTACK **
0073   0000             LCRFLG  .EQU    WRKSPC+0ACH     ; Locate/Create flag
0074   0000             TYPE    .EQU    WRKSPC+0ADH     ; Data type flag
0075   0000             DATFLG  .EQU    WRKSPC+0AEH     ; Literal statement flag
0076   0000             LSTRAM  .EQU    WRKSPC+0AFH     ; Last available RAM
0077   0000             TMSTPT  .EQU    WRKSPC+0B1H     ; Temporary string pointer
0078   0000             TMSTPL  .EQU    WRKSPC+0B3H     ; Temporary string pool
0079   0000             TMPSTR  .EQU    WRKSPC+0BFH     ; Temporary string
0080   0000             STRBOT  .EQU    WRKSPC+0C3H     ; Bottom of string space
0081   0000             CUROPR  .EQU    WRKSPC+0C5H     ; Current operator in EVAL
0082   0000             LOOPST  .EQU    WRKSPC+0C7H     ; First statement of loop
0083   0000             DATLIN  .EQU    WRKSPC+0C9H     ; Line of current DATA item
0084   0000             FORFLG  .EQU    WRKSPC+0CBH     ; "FOR" loop flag
0085   0000             LSTBIN  .EQU    WRKSPC+0CCH     ; Last byte entered
0086   0000             READFG  .EQU    WRKSPC+0CDH     ; Read/Input flag
0087   0000             BRKLIN  .EQU    WRKSPC+0CEH     ; Line of break
0088   0000             NXTOPR  .EQU    WRKSPC+0D0H     ; Next operator in EVAL
0089   0000             ERRLIN  .EQU    WRKSPC+0D2H     ; Line of error
0090   0000             CONTAD  .EQU    WRKSPC+0D4H     ; Where to CONTinue
0091   0000             PROGND  .EQU    WRKSPC+0D6H     ; End of program
0092   0000             VAREND  .EQU    WRKSPC+0D8H     ; End of variables
0093   0000             ARREND  .EQU    WRKSPC+0DAH     ; End of arrays
0094   0000             NXTDAT  .EQU    WRKSPC+0DCH     ; Next data item
0095   0000             FNRGNM  .EQU    WRKSPC+0DEH     ; Name of FN argument
0096   0000             FNARG   .EQU    WRKSPC+0E0H     ; FN argument value
0097   0000             FPREG   .EQU    WRKSPC+0E4H     ; Floating point register
0098   0000             FPEXP   .EQU    FPREG+3         ; Floating point exponent
0099   0000             SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0100   0000             PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0101   0000             MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0102   0000             PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
0103   0000             STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0104   0000             
0105   0000             ; BASIC ERROR CODE VALUES
0106   0000             
0107   0000             NF      .EQU    00H             ; NEXT without FOR
0108   0000             SN      .EQU    02H             ; Syntax error
0109   0000             RG      .EQU    04H             ; RETURN without GOSUB
0110   0000             OD      .EQU    06H             ; Out of DATA
0111   0000             FC      .EQU    08H             ; Function call error
0112   0000             OV      .EQU    0AH             ; Overflow
0113   0000             OM      .EQU    0CH             ; Out of memory
0114   0000             UL      .EQU    0EH             ; Undefined line number
0115   0000             BS      .EQU    10H             ; Bad subscript
0116   0000             DD      .EQU    12H             ; Re-DIMensioned array
0117   0000             DZ      .EQU    14H             ; Division by zero (/0)
0118   0000             ID      .EQU    16H             ; Illegal direct
0119   0000             TM      .EQU    18H             ; Type miss-match
0120   0000             OS      .EQU    1AH             ; Out of string space
0121   0000             LS      .EQU    1CH             ; String too long
0122   0000             ST      .EQU    1EH             ; String formula too complex
0123   0000             CN      .EQU    20H             ; Can't CONTinue
0124   0000             UF      .EQU    22H             ; UnDEFined FN function
0125   0000             MO      .EQU    24H             ; Missing operand
0126   0000             HX      .EQU    26H             ; HEX error
0127   0000             BN      .EQU    28H             ; BIN error
0128   0000             
0129   01C0                     .ORG    001C0H          ; <<<< Modified to allow for Tx/Rx buffers
0130   01C0             
0131   01C0 C3 C6 01    COLD:   JP      STARTB          ; Jump in for cold start (001C0H)
0132   01C3 C3 64 02    WARM:   JP      WARMST          ; Jump in for warm start (001C3H)
0133   01C6             STARTB: 
0134   01C6 DD 21 00 00         LD      IX,0            ; Flag cold start
0135   01CA C3 D1 01            JP      CSTART          ; Jump to initialise
0136   01CD             
0137   01CD 77 0A               .WORD   DEINT           ; Get integer -32768 to 32767
0138   01CF ED 11               .WORD   ABPASS          ; Return integer in AB
0139   01D1             
0140   01D1             
0141   01D1 21 20 21    CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0142   01D4 F9                  LD      SP,HL           ; Set up a temporary stack
0143   01D5 C3 0C 1E            JP      INITST          ; Go to initialise
0144   01D8             
0145   01D8 11 9E 04    INIT:   LD      DE,INITAB       ; Initialise workspace
0146   01DB 06 63               LD      B,INITBE-INITAB+3; Bytes to copy
0147   01DD 21 20 21            LD      HL,WRKSPC       ; Into workspace RAM
0148   01E0 1A          COPY:   LD      A,(DE)          ; Get source
0149   01E1 77                  LD      (HL),A          ; To destination
0150   01E2 23                  INC     HL              ; Next destination
0151   01E3 13                  INC     DE              ; Next source
0152   01E4 05                  DEC     B               ; Count bytes
0153   01E5 C2 E0 01            JP      NZ,COPY         ; More to move
0154   01E8 F9                  LD      SP,HL           ; Temporary stack
0155   01E9 CD 9F 06            CALL    CLREG           ; Clear registers and stack
0156   01EC CD 6D 0C            CALL    PRNTCRLF        ; Output CRLF
0157   01EF 32 CA 21            LD      (BUFFER+72+1),A ; Mark end of buffer
0158   01F2 32 19 22            LD      (PROGST),A      ; Initialise program area
0159   01F5 21 B3 02    MSIZE:  LD      HL,MEMMSG       ; Point to message
0160   01F8 CD 0B 13            CALL    PRS             ; Output "Memory size"
0161   01FB CD BC 06            CALL    PROMPT          ; Get input with '?'
0162   01FE CD C5 09            CALL    GETCHR          ; Get next character
0163   0201 B7                  OR      A               ; Set flags
0164   0202 C2 1A 02            JP      NZ,TSTMEM       ; If number - Test if RAM there
0165   0205 21 7D 22            LD      HL,STLOOK       ; Point to start of RAM
0166   0208 23          MLOOP:  INC     HL              ; Next byte
0167   0209 7C                  LD      A,H             ; Above address FFFF ?
0168   020A B5                  OR      L
0169   020B CA 2C 02            JP      Z,SETTOP        ; Yes - 64K RAM
0170   020E 7E                  LD      A,(HL)          ; Get contents
0171   020F 47                  LD      B,A             ; Save it
0172   0210 2F                  CPL                     ; Flip all bits
0173   0211 77                  LD      (HL),A          ; Put it back
0174   0212 BE                  CP      (HL)            ; RAM there if same
0175   0213 70                  LD      (HL),B          ; Restore old contents
0176   0214 CA 08 02            JP      Z,MLOOP         ; If RAM - test next byte
0177   0217 C3 2C 02            JP      SETTOP          ; Top of RAM found
0178   021A             
0179   021A CD 91 0A    TSTMEM: CALL    ATOH            ; Get high memory into DE
0180   021D B7                  OR      A               ; Set flags on last byte
0181   021E C2 6D 05            JP      NZ,SNERR        ; ?SN Error if bad character
0182   0221 EB                  EX      DE,HL           ; Address into HL
0183   0222 2B                  DEC     HL              ; Back one byte
0184   0223 3E D9               LD      A,11011001B     ; Test byte
0185   0225 46                  LD      B,(HL)          ; Get old contents
0186   0226 77                  LD      (HL),A          ; Load test byte
0187   0227 BE                  CP      (HL)            ; RAM there if same
0188   0228 70                  LD      (HL),B          ; Restore old contents
0189   0229 C2 F5 01            JP      NZ,MSIZE        ; Ask again if no RAM
0190   022C             
0191   022C 2B          SETTOP: DEC     HL              ; Back one byte
0192   022D 11 7C 22            LD      DE,STLOOK-1     ; See if enough RAM
0193   0230 CD 35 08            CALL    CPDEHL          ; Compare DE with HL
0194   0233 DA F5 01            JP      C,MSIZE         ; Ask again if not enough RAM
0195   0236 11 CE FF            LD      DE,0-50         ; 50 Bytes string space
0196   0239 22 CF 21            LD      (LSTRAM),HL     ; Save last available RAM
0197   023C 19                  ADD     HL,DE           ; Allocate string space
0198   023D 22 7A 21            LD      (STRSPC),HL     ; Save string space
0199   0240 CD 7A 06            CALL    CLRPTR          ; Clear program area
0200   0243 2A 7A 21            LD      HL,(STRSPC)     ; Get end of memory
0201   0246 11 EF FF            LD      DE,0-17         ; Offset for free bytes
0202   0249 19                  ADD     HL,DE           ; Adjust HL
0203   024A 11 19 22            LD      DE,PROGST       ; Start of program text
0204   024D 7D                  LD      A,L             ; Get LSB
0205   024E 93                  SUB     E               ; Adjust it
0206   024F 6F                  LD      L,A             ; Re-save
0207   0250 7C                  LD      A,H             ; Get MSB
0208   0251 9A                  SBC     A,D             ; Adjust it
0209   0252 67                  LD      H,A             ; Re-save
0210   0253 E5                  PUSH    HL              ; Save bytes free
0211   0254 21 7C 02            LD      HL,SIGNON       ; Sign-on message
0212   0257 CD 0B 13            CALL    PRS             ; Output string
0213   025A E1                  POP     HL              ; Get bytes free back
0214   025B CD AE 19            CALL    PRNTHL          ; Output amount of free memory
0215   025E 21 6D 02            LD      HL,BFREE        ; " Bytes free" message
0216   0261 CD 0B 13            CALL    PRS             ; Output string
0217   0264             
0218   0264 31 86 21    WARMST: LD      SP,STACK        ; Temporary stack
0219   0267 CD 9F 06    BRKRET: CALL    CLREG           ; Clear registers and stack
0220   026A C3 B8 05            JP      PRNTOK          ; Go to get command line
0221   026D             
0222   026D 204279746573BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0222   0273 20667265650D0A0000
0223   027C             
0224   027C 5A3830204241SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
0224   0282 5349432056657220342E37620D0A
0225   0290 436F70797269        .BYTE   "Copyright ",40,"C",41
0225   0296 67687420284329
0226   029D 203139373820        .BYTE   " 1978 by Microsoft",CR,LF,0,0
0226   02A3 6279204D6963726F736F66740D0A0000
0227   02B3             
0228   02B3 4D656D6F7279MEMMSG: .BYTE   "Memory top",0
0228   02B9 20746F7000
0229   02BE             
0230   02BE             ; FUNCTION ADDRESS TABLE
0231   02BE             
0232   02BE 23 18       FNCTAB: .WORD   SGN
0233   02C0 E7 18               .WORD   INT
0234   02C2 39 18               .WORD   ABS
0235   02C4 23 21               .WORD   USR
0236   02C6 CB 11               .WORD   FRE
0237   02C8 50 15               .WORD   INP
0238   02CA F9 11               .WORD   POS
0239   02CC AD 1A               .WORD   SQR
0240   02CE 8C 1B               .WORD   RND
0241   02D0 C8 16               .WORD   LOG
0242   02D2 FB 1A               .WORD   EXP
0243   02D4 01 1C               .WORD   COS
0244   02D6 07 1C               .WORD   SIN
0245   02D8 68 1C               .WORD   TAN
0246   02DA 7D 1C               .WORD   ATN
0247   02DC A4 15               .WORD   PEEK
0248   02DE E8 1C               .WORD   DEEK
0249   02E0 71 21               .WORD   POINT
0250   02E2 7D 14               .WORD   LEN
0251   02E4 95 12               .WORD   STR
0252   02E6 17 15               .WORD   VAL
0253   02E8 8C 14               .WORD   ASC
0254   02EA 9D 14               .WORD   CHR
0255   02EC 0A 1D               .WORD   HEX
0256   02EE 9D 1D               .WORD   BIN
0257   02F0 AD 14               .WORD   LEFT
0258   02F2 DD 14               .WORD   RIGHT
0259   02F4 E7 14               .WORD   MID
0260   02F6             
0261   02F6             ; RESERVED WORD LIST
0262   02F6             
0263   02F6 C5 4E 44    WORDS:  .BYTE   'E'+80H,"ND"
0264   02F9 C6 4F 52            .BYTE   'F'+80H,"OR"
0265   02FC CE 45 58 54         .BYTE   'N'+80H,"EXT"
0266   0300 C4 41 54 41         .BYTE   'D'+80H,"ATA"
0267   0304 C94E505554          .BYTE   'I'+80H,"NPUT"
0268   0309 C4 49 4D            .BYTE   'D'+80H,"IM"
0269   030C D2 45 41 44         .BYTE   'R'+80H,"EAD"
0270   0310 CC 45 54            .BYTE   'L'+80H,"ET"
0271   0313 C7 4F 54 4F         .BYTE   'G'+80H,"OTO"
0272   0317 D2 55 4E            .BYTE   'R'+80H,"UN"
0273   031A C9 46               .BYTE   'I'+80H,"F"
0274   031C D24553544F52        .BYTE   'R'+80H,"ESTORE"
0274   0322 45
0275   0323 C74F535542          .BYTE   'G'+80H,"OSUB"
0276   0328 D2455455524E        .BYTE   'R'+80H,"ETURN"
0277   032E D2 45 4D            .BYTE   'R'+80H,"EM"
0278   0331 D3 54 4F 50         .BYTE   'S'+80H,"TOP"
0279   0335 CF 55 54            .BYTE   'O'+80H,"UT"
0280   0338 CF 4E               .BYTE   'O'+80H,"N"
0281   033A CE 55 4C 4C         .BYTE   'N'+80H,"ULL"
0282   033E D7 41 49 54         .BYTE   'W'+80H,"AIT"
0283   0342 C4 45 46            .BYTE   'D'+80H,"EF"
0284   0345 D0 4F 4B 45         .BYTE   'P'+80H,"OKE"
0285   0349 C4 4F 4B 45         .BYTE   'D'+80H,"OKE"
0286   034D D3435245454E        .BYTE   'S'+80H,"CREEN"
0287   0353 CC494E4553          .BYTE   'L'+80H,"INES"
0288   0358 C3 4C 53            .BYTE   'C'+80H,"LS"
0289   035B D749445448          .BYTE   'W'+80H,"IDTH"
0290   0360 CD4F4E49544F        .BYTE   'M'+80H,"ONITOR"
0290   0366 52
0291   0367 D3 45 54            .BYTE   'S'+80H,"ET"
0292   036A D245534554          .BYTE   'R'+80H,"ESET"
0293   036F D052494E54          .BYTE   'P'+80H,"RINT"
0294   0374 C3 4F 4E 54         .BYTE   'C'+80H,"ONT"
0295   0378 CC 49 53 54         .BYTE   'L'+80H,"IST"
0296   037C C34C454152          .BYTE   'C'+80H,"LEAR"
0297   0381 C34C4F4144          .BYTE   'C'+80H,"LOAD"
0298   0386 C353415645          .BYTE   'C'+80H,"SAVE"
0299   038B CE 45 57            .BYTE   'N'+80H,"EW"
0300   038E             
0301   038E D4 41 42 28         .BYTE   'T'+80H,"AB("
0302   0392 D4 4F               .BYTE   'T'+80H,"O"
0303   0394 C6 4E               .BYTE   'F'+80H,"N"
0304   0396 D3 50 43 28         .BYTE   'S'+80H,"PC("
0305   039A D4 48 45 4E         .BYTE   'T'+80H,"HEN"
0306   039E CE 4F 54            .BYTE   'N'+80H,"OT"
0307   03A1 D3 54 45 50         .BYTE   'S'+80H,"TEP"
0308   03A5             
0309   03A5 AB                  .BYTE   '+'+80H
0310   03A6 AD                  .BYTE   '-'+80H
0311   03A7 AA                  .BYTE   '*'+80H
0312   03A8 AF                  .BYTE   '/'+80H
0313   03A9 DE                  .BYTE   '^'+80H
0314   03AA C1 4E 44            .BYTE   'A'+80H,"ND"
0315   03AD CF 52               .BYTE   'O'+80H,"R"
0316   03AF BE                  .BYTE   '>'+80H
0317   03B0 BD                  .BYTE   '='+80H
0318   03B1 BC                  .BYTE   '<'+80H
0319   03B2             
0320   03B2 D3 47 4E            .BYTE   'S'+80H,"GN"
0321   03B5 C9 4E 54            .BYTE   'I'+80H,"NT"
0322   03B8 C1 42 53            .BYTE   'A'+80H,"BS"
0323   03BB D5 53 52            .BYTE   'U'+80H,"SR"
0324   03BE C6 52 45            .BYTE   'F'+80H,"RE"
0325   03C1 C9 4E 50            .BYTE   'I'+80H,"NP"
0326   03C4 D0 4F 53            .BYTE   'P'+80H,"OS"
0327   03C7 D3 51 52            .BYTE   'S'+80H,"QR"
0328   03CA D2 4E 44            .BYTE   'R'+80H,"ND"
0329   03CD CC 4F 47            .BYTE   'L'+80H,"OG"
0330   03D0 C5 58 50            .BYTE   'E'+80H,"XP"
0331   03D3 C3 4F 53            .BYTE   'C'+80H,"OS"
0332   03D6 D3 49 4E            .BYTE   'S'+80H,"IN"
0333   03D9 D4 41 4E            .BYTE   'T'+80H,"AN"
0334   03DC C1 54 4E            .BYTE   'A'+80H,"TN"
0335   03DF D0 45 45 4B         .BYTE   'P'+80H,"EEK"
0336   03E3 C4 45 45 4B         .BYTE   'D'+80H,"EEK"
0337   03E7 D04F494E54          .BYTE   'P'+80H,"OINT"
0338   03EC CC 45 4E            .BYTE   'L'+80H,"EN"
0339   03EF D3 54 52 24         .BYTE   'S'+80H,"TR$"
0340   03F3 D6 41 4C            .BYTE   'V'+80H,"AL"
0341   03F6 C1 53 43            .BYTE   'A'+80H,"SC"
0342   03F9 C3 48 52 24         .BYTE   'C'+80H,"HR$"
0343   03FD C8 45 58 24         .BYTE   'H'+80H,"EX$"
0344   0401 C2 49 4E 24         .BYTE   'B'+80H,"IN$"
0345   0405 CC45465424          .BYTE   'L'+80H,"EFT$"
0346   040A D24947485424        .BYTE   'R'+80H,"IGHT$"
0347   0410 CD 49 44 24         .BYTE   'M'+80H,"ID$"
0348   0414 80                  .BYTE   80H             ; End of list marker
0349   0415             
0350   0415             ; KEYWORD ADDRESS TABLE
0351   0415             
0352   0415 0F 0A       WORDTB: .WORD   PEND
0353   0417 0C 09               .WORD   FOR
0354   0419 E7 0D               .WORD   NEXT
0355   041B 5C 0B               .WORD   DATA
0356   041D EE 0C               .WORD   INPUT
0357   041F 23 10               .WORD   DIM
0358   0421 1D 0D               .WORD   READ
0359   0423 73 0B               .WORD   LET
0360   0425 19 0B               .WORD   GOTO
0361   0427 FC 0A               .WORD   RUN
0362   0429 EB 0B               .WORD   IF
0363   042B D5 09               .WORD   RESTOR
0364   042D 08 0B               .WORD   GOSUB
0365   042F 37 0B               .WORD   RETURN
0366   0431 5E 0B               .WORD   REM
0367   0433 0D 0A               .WORD   STOP
0368   0435 5C 15               .WORD   POUT
0369   0437 CD 0B               .WORD   ON
0370   0439 4E 0A               .WORD   NULL
0371   043B 62 15               .WORD   WAIT
0372   043D 01 12               .WORD   DEF
0373   043F AB 15               .WORD   POKE
0374   0441 F3 1C               .WORD   DOKE
0375   0443 5E 0B               .WORD   REM
0376   0445 D9 1C               .WORD   LINES
0377   0447 CC 1C               .WORD   CLS
0378   0449 D1 1C               .WORD   WIDTH
0379   044B 09 1E               .WORD   MONITR
0380   044D 74 21               .WORD   PSET
0381   044F 77 21               .WORD   RESET
0382   0451 0F 0C               .WORD   PRINT
0383   0453 3B 0A               .WORD   CONT
0384   0455 81 08               .WORD   LIST
0385   0457 B6 0A               .WORD   CLEAR
0386   0459 5E 0B               .WORD   REM
0387   045B 5E 0B               .WORD   REM
0388   045D 79 06               .WORD   NEW
0389   045F             
0390   045F             ; RESERVED WORD TOKEN VALUES
0391   045F             
0392   045F             ZEND    .EQU    080H            ; END
0393   045F             ZFOR    .EQU    081H            ; FOR
0394   045F             ZDATA   .EQU    083H            ; DATA
0395   045F             ZGOTO   .EQU    088H            ; GOTO
0396   045F             ZGOSUB  .EQU    08CH            ; GOSUB
0397   045F             ZREM    .EQU    08EH            ; REM
0398   045F             ZPRINT  .EQU    09EH            ; PRINT
0399   045F             ZNEW    .EQU    0A4H            ; NEW
0400   045F             
0401   045F             ZTAB    .EQU    0A5H            ; TAB
0402   045F             ZTO     .EQU    0A6H            ; TO
0403   045F             ZFN     .EQU    0A7H            ; FN
0404   045F             ZSPC    .EQU    0A8H            ; SPC
0405   045F             ZTHEN   .EQU    0A9H            ; THEN
0406   045F             ZNOT    .EQU    0AAH            ; NOT
0407   045F             ZSTEP   .EQU    0ABH            ; STEP
0408   045F             
0409   045F             ZPLUS   .EQU    0ACH            ; +
0410   045F             ZMINUS  .EQU    0ADH            ; -
0411   045F             ZTIMES  .EQU    0AEH            ; *
0412   045F             ZDIV    .EQU    0AFH            ; /
0413   045F             ZOR     .EQU    0B2H            ; OR
0414   045F             ZGTR    .EQU    0B3H            ; >
0415   045F             ZEQUAL  .EQU    0B4H            ; M
0416   045F             ZLTH    .EQU    0B5H            ; <
0417   045F             ZSGN    .EQU    0B6H            ; SGN
0418   045F             ZPOINT  .EQU    0C7H            ; POINT
0419   045F             ZLEFT   .EQU    0CDH +2         ; LEFT$
0420   045F             
0421   045F             ; ARITHMETIC PRECEDENCE TABLE
0422   045F             
0423   045F 79          PRITAB: .BYTE   79H             ; Precedence value
0424   0460 95 19               .WORD   PADD            ; FPREG = <last> + FPREG
0425   0462             
0426   0462 79                  .BYTE   79H             ; Precedence value
0427   0463 C9 15               .WORD   PSUB            ; FPREG = <last> - FPREG
0428   0465             
0429   0465 7C                  .BYTE   7CH             ; Precedence value
0430   0466 07 17               .WORD   MULT            ; PPREG = <last> * FPREG
0431   0468             
0432   0468 7C                  .BYTE   7CH             ; Precedence value
0433   0469 68 17               .WORD   DIV             ; FPREG = <last> / FPREG
0434   046B             
0435   046B 7F                  .BYTE   7FH             ; Precedence value
0436   046C B6 1A               .WORD   POWER           ; FPREG = <last> ^ FPREG
0437   046E             
0438   046E 50                  .BYTE   50H             ; Precedence value
0439   046F 7C 0F               .WORD   PAND            ; FPREG = <last> AND FPREG
0440   0471             
0441   0471 46                  .BYTE   46H             ; Precedence value
0442   0472 7B 0F               .WORD   POR             ; FPREG = <last> OR FPREG
0443   0474             
0444   0474             ; BASIC ERROR CODE LIST
0445   0474             
0446   0474 4E 46       ERRORS: .BYTE   "NF"            ; NEXT without FOR
0447   0476 53 4E               .BYTE   "SN"            ; Syntax error
0448   0478 52 47               .BYTE   "RG"            ; RETURN without GOSUB
0449   047A 4F 44               .BYTE   "OD"            ; Out of DATA
0450   047C 46 43               .BYTE   "FC"            ; Illegal function call
0451   047E 4F 56               .BYTE   "OV"            ; Overflow error
0452   0480 4F 4D               .BYTE   "OM"            ; Out of memory
0453   0482 55 4C               .BYTE   "UL"            ; Undefined line
0454   0484 42 53               .BYTE   "BS"            ; Bad subscript
0455   0486 44 44               .BYTE   "DD"            ; Re-DIMensioned array
0456   0488 2F 30               .BYTE   "/0"            ; Division by zero
0457   048A 49 44               .BYTE   "ID"            ; Illegal direct
0458   048C 54 4D               .BYTE   "TM"            ; Type mis-match
0459   048E 4F 53               .BYTE   "OS"            ; Out of string space
0460   0490 4C 53               .BYTE   "LS"            ; String too long
0461   0492 53 54               .BYTE   "ST"            ; String formula too complex
0462   0494 43 4E               .BYTE   "CN"            ; Can't CONTinue
0463   0496 55 46               .BYTE   "UF"            ; Undefined FN function
0464   0498 4D 4F               .BYTE   "MO"            ; Missing operand
0465   049A 48 58               .BYTE   "HX"            ; HEX error
0466   049C 42 4E               .BYTE   "BN"            ; BIN error
0467   049E             
0468   049E             ; INITIALISATION TABLE -------------------------------------------------------
0469   049E             
0470   049E C3 64 02    INITAB: JP      WARMST          ; Warm start jump
0471   04A1 C3 8C 0A            JP      FCERR           ; "USR (X)" jump (Set to Error)
0472   04A4 D3 00               OUT     (0),A           ; "OUT p,n" skeleton
0473   04A6 C9                  RET
0474   04A7 D6 00               SUB     0               ; Division support routine
0475   04A9 6F                  LD      L,A
0476   04AA 7C                  LD      A,H
0477   04AB DE 00               SBC     A,0
0478   04AD 67                  LD      H,A
0479   04AE 78                  LD      A,B
0480   04AF DE 00               SBC     A,0
0481   04B1 47                  LD      B,A
0482   04B2 3E 00               LD      A,0
0483   04B4 C9                  RET
0484   04B5 00 00 00            .BYTE   0,0,0                   ; Random number seed table used by RND
0485   04B8 35 4A CA 99         .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
0486   04BC 39 1C 76 98         .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
0487   04C0 22 95 B3 98         .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
0488   04C4 0A DD 47 98         .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
0489   04C8 53 D1 99 99         .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
0490   04CC 0A 1A 9F 98         .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
0491   04D0 65 BC CD 98         .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
0492   04D4 D6 77 3E 98         .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
0493   04D8 52 C7 4F 80         .BYTE   052H,0C7H,04FH,080H     ; Last random number
0494   04DC DB 00               IN      A,(0)           ; INP (x) skeleton
0495   04DE C9                  RET
0496   04DF 01                  .BYTE   1               ; POS (x) number (1)
0497   04E0 FF                  .BYTE   255             ; Terminal width (255 = no auto CRLF)
0498   04E1 1C                  .BYTE   28              ; Width for commas (3 columns)
0499   04E2 00                  .BYTE   0               ; No nulls after input bytes
0500   04E3 00                  .BYTE   0               ; Output enabled (^O off)
0501   04E4 14 00               .WORD   20              ; Initial lines counter
0502   04E6 14 00               .WORD   20              ; Initial lines number
0503   04E8 00 00               .WORD   0               ; Array load/save check sum
0504   04EA 00                  .BYTE   0               ; Break not by NMI
0505   04EB 00                  .BYTE   0               ; Break flag
0506   04EC C3 B2 07            JP      TTYLIN          ; Input reflection (set to TTY)
0507   04EF C3 00 00            JP      $0000           ; POINT reflection unused
0508   04F2 C3 00 00            JP      $0000           ; SET reflection
0509   04F5 C3 00 00            JP      $0000          	; RESET reflection
0510   04F8 7D 22               .WORD   STLOOK          ; Temp string space
0511   04FA FE FF               .WORD   -2              ; Current line number (cold)
0512   04FC 1A 22               .WORD   PROGST+1        ; Start of program text
0513   04FE             INITBE:                         
0514   04FE             
0515   04FE             ; END OF INITIALISATION TABLE ---------------------------------------------------
0516   04FE             
0517   04FE 204572726F72ERRMSG: .BYTE   " Error",0
0517   0504 00
0518   0505 20696E2000  INMSG:  .BYTE   " in ",0
0519   050A             ZERBYT  .EQU    $-1             ; A zero byte
0520   050A 4F6B0D0A0000OKMSG:  .BYTE   "Ok",CR,LF,0,0
0521   0510 427265616B00BRKMSG: .BYTE   "Break",0
0522   0516             
0523   0516 21 04 00    BAKSTK: LD      HL,4            ; Look for "FOR" block with
0524   0519 39                  ADD     HL,SP           ; same index as specified
0525   051A 7E          LOKFOR: LD      A,(HL)          ; Get block ID
0526   051B 23                  INC     HL              ; Point to index address
0527   051C FE 81               CP      ZFOR            ; Is it a "FOR" token
0528   051E C0                  RET     NZ              ; No - exit
0529   051F 4E                  LD      C,(HL)          ; BC = Address of "FOR" index
0530   0520 23                  INC     HL
0531   0521 46                  LD      B,(HL)
0532   0522 23                  INC     HL              ; Point to sign of STEP
0533   0523 E5                  PUSH    HL              ; Save pointer to sign
0534   0524 69                  LD      L,C             ; HL = address of "FOR" index
0535   0525 60                  LD      H,B
0536   0526 7A                  LD      A,D             ; See if an index was specified
0537   0527 B3                  OR      E               ; DE = 0 if no index specified
0538   0528 EB                  EX      DE,HL           ; Specified index into HL
0539   0529 CA 30 05            JP      Z,INDFND        ; Skip if no index given
0540   052C EB                  EX      DE,HL           ; Index back into DE
0541   052D CD 35 08            CALL    CPDEHL          ; Compare index with one given
0542   0530 01 0D 00    INDFND: LD      BC,16-3         ; Offset to next block
0543   0533 E1                  POP     HL              ; Restore pointer to sign
0544   0534 C8                  RET     Z               ; Return if block found
0545   0535 09                  ADD     HL,BC           ; Point to next block
0546   0536 C3 1A 05            JP      LOKFOR          ; Keep on looking
0547   0539             
0548   0539 CD 53 05    MOVUP:  CALL    ENFMEM          ; See if enough memory
0549   053C C5          MOVSTR: PUSH    BC              ; Save end of source
0550   053D E3                  EX      (SP),HL         ; Swap source and dest" end
0551   053E C1                  POP     BC              ; Get end of destination
0552   053F CD 35 08    MOVLP:  CALL    CPDEHL          ; See if list moved
0553   0542 7E                  LD      A,(HL)          ; Get byte
0554   0543 02                  LD      (BC),A          ; Move it
0555   0544 C8                  RET     Z               ; Exit if all done
0556   0545 0B                  DEC     BC              ; Next byte to move to
0557   0546 2B                  DEC     HL              ; Next byte to move
0558   0547 C3 3F 05            JP      MOVLP           ; Loop until all bytes moved
0559   054A             
0560   054A E5          CHKSTK: PUSH    HL              ; Save code string address
0561   054B 2A FA 21            LD      HL,(ARREND)     ; Lowest free memory
0562   054E 06 00               LD      B,0             ; BC = Number of levels to test
0563   0550 09                  ADD     HL,BC           ; 2 Bytes for each level
0564   0551 09                  ADD     HL,BC
0565   0552 3E                  .BYTE   3EH             ; Skip "PUSH HL"
0566   0553 E5          ENFMEM: PUSH    HL              ; Save code string address
0567   0554 3E D0               LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
0568   0556 95                  SUB     L
0569   0557 6F                  LD      L,A
0570   0558 3E FF               LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
0571   055A 9C                  SBC     A,H
0572   055B DA 62 05            JP      C,OMERR         ; Not enough - ?OM Error
0573   055E 67                  LD      H,A
0574   055F 39                  ADD     HL,SP           ; Test if stack is overflowed
0575   0560 E1                  POP     HL              ; Restore code string address
0576   0561 D8                  RET     C               ; Return if enough mmory
0577   0562 1E 0C       OMERR:  LD      E,OM            ; ?OM Error
0578   0564 C3 81 05            JP      ERROR
0579   0567             
0580   0567 2A E9 21    DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
0581   056A 22 7C 21            LD      (LINEAT),HL     ; Save as current line
0582   056D 1E 02       SNERR:  LD      E,SN            ; ?SN Error
0583   056F 01                  .BYTE   01H             ; Skip "LD E,DZ"
0584   0570 1E 14       DZERR:  LD      E,DZ            ; ?/0 Error
0585   0572 01                  .BYTE   01H             ; Skip "LD E,NF"
0586   0573 1E 00       NFERR:  LD      E,NF            ; ?NF Error
0587   0575 01                  .BYTE   01H             ; Skip "LD E,DD"
0588   0576 1E 12       DDERR:  LD      E,DD            ; ?DD Error
0589   0578 01                  .BYTE   01H             ; Skip "LD E,UF"
0590   0579 1E 22       UFERR:  LD      E,UF            ; ?UF Error
0591   057B 01                  .BYTE   01H             ; Skip "LD E,OV
0592   057C 1E 0A       OVERR:  LD      E,OV            ; ?OV Error
0593   057E 01                  .BYTE   01H             ; Skip "LD E,TM"
0594   057F 1E 18       TMERR:  LD      E,TM            ; ?TM Error
0595   0581             
0596   0581 CD 9F 06    ERROR:  CALL    CLREG           ; Clear registers and stack
0597   0584 32 65 21            LD      (CTLOFG),A      ; Enable output (A is 0)
0598   0587 CD 60 0C            CALL    STTLIN          ; Start new line
0599   058A 21 74 04            LD      HL,ERRORS       ; Point to error codes
0600   058D 57                  LD      D,A             ; D = 0 (A is 0)
0601   058E 3E 3F               LD      A,'?'
0602   0590 CD 46 08            CALL    OUTC            ; Output '?'
0603   0593 19                  ADD     HL,DE           ; Offset to correct error code
0604   0594 7E                  LD      A,(HL)          ; First character
0605   0595 CD 46 08            CALL    OUTC            ; Output it
0606   0598 CD C5 09            CALL    GETCHR          ; Get next character
0607   059B CD 46 08            CALL    OUTC            ; Output it
0608   059E 21 FE 04            LD      HL,ERRMSG       ; "Error" message
0609   05A1 CD 0B 13    ERRIN:  CALL    PRS             ; Output message
0610   05A4 2A 7C 21            LD      HL,(LINEAT)     ; Get line of error
0611   05A7 11 FE FF            LD      DE,-2           ; Cold start error if -2
0612   05AA CD 35 08            CALL    CPDEHL          ; See if cold start error
0613   05AD CA D1 01            JP      Z,CSTART        ; Cold start error - Restart
0614   05B0 7C                  LD      A,H             ; Was it a direct error?
0615   05B1 A5                  AND     L               ; Line = -1 if direct error
0616   05B2 3C                  INC     A
0617   05B3 C4 A6 19            CALL    NZ,LINEIN       ; No - output line of error
0618   05B6 3E                  .BYTE   3EH             ; Skip "POP BC"
0619   05B7 C1          POPNOK: POP     BC              ; Drop address in input buffer
0620   05B8             
0621   05B8 AF          PRNTOK: XOR     A               ; Output "Ok" and get command
0622   05B9 32 65 21            LD      (CTLOFG),A      ; Enable output
0623   05BC CD 60 0C            CALL    STTLIN          ; Start new line
0624   05BF 21 0A 05            LD      HL,OKMSG        ; "Ok" message
0625   05C2 CD 0B 13            CALL    PRS             ; Output "Ok"
0626   05C5 21 FF FF    GETCMD: LD      HL,-1           ; Flag direct mode
0627   05C8 22 7C 21            LD      (LINEAT),HL     ; Save as current line
0628   05CB CD B2 07            CALL    GETLIN          ; Get an input line
0629   05CE DA C5 05            JP      C,GETCMD        ; Get line again if break
0630   05D1 CD C5 09            CALL    GETCHR          ; Get first character
0631   05D4 3C                  INC     A               ; Test if end of line
0632   05D5 3D                  DEC     A               ; Without affecting Carry
0633   05D6 CA C5 05            JP      Z,GETCMD        ; Nothing entered - Get another
0634   05D9 F5                  PUSH    AF              ; Save Carry status
0635   05DA CD 91 0A            CALL    ATOH            ; Get line number into DE
0636   05DD D5                  PUSH    DE              ; Save line number
0637   05DE CD C9 06            CALL    CRUNCH          ; Tokenise rest of line
0638   05E1 47                  LD      B,A             ; Length of tokenised line
0639   05E2 D1                  POP     DE              ; Restore line number
0640   05E3 F1                  POP     AF              ; Restore Carry
0641   05E4 D2 A5 09            JP      NC,EXCUTE       ; No line number - Direct mode
0642   05E7 D5                  PUSH    DE              ; Save line number
0643   05E8 C5                  PUSH    BC              ; Save length of tokenised line
0644   05E9 AF                  XOR     A
0645   05EA 32 EC 21            LD      (LSTBIN),A      ; Clear last byte input
0646   05ED CD C5 09            CALL    GETCHR          ; Get next character
0647   05F0 B7                  OR      A               ; Set flags
0648   05F1 F5                  PUSH    AF              ; And save them
0649   05F2 CD 59 06            CALL    SRCHLN          ; Search for line number in DE
0650   05F5 DA FE 05            JP      C,LINFND        ; Jump if line found
0651   05F8 F1                  POP     AF              ; Get status
0652   05F9 F5                  PUSH    AF              ; And re-save
0653   05FA CA 32 0B            JP      Z,ULERR         ; Nothing after number - Error
0654   05FD B7                  OR      A               ; Clear Carry
0655   05FE C5          LINFND: PUSH    BC              ; Save address of line in prog
0656   05FF D2 15 06            JP      NC,INEWLN       ; Line not found - Insert new
0657   0602 EB                  EX      DE,HL           ; Next line address in DE
0658   0603 2A F6 21            LD      HL,(PROGND)     ; End of program
0659   0606 1A          SFTPRG: LD      A,(DE)          ; Shift rest of program down
0660   0607 02                  LD      (BC),A
0661   0608 03                  INC     BC              ; Next destination
0662   0609 13                  INC     DE              ; Next source
0663   060A CD 35 08            CALL    CPDEHL          ; All done?
0664   060D C2 06 06            JP      NZ,SFTPRG       ; More to do
0665   0610 60                  LD      H,B             ; HL - New end of program
0666   0611 69                  LD      L,C
0667   0612 22 F6 21            LD      (PROGND),HL     ; Update end of program
0668   0615             
0669   0615 D1          INEWLN: POP     DE              ; Get address of line,
0670   0616 F1                  POP     AF              ; Get status
0671   0617 CA 3C 06            JP      Z,SETPTR        ; No text - Set up pointers
0672   061A 2A F6 21            LD      HL,(PROGND)     ; Get end of program
0673   061D E3                  EX      (SP),HL         ; Get length of input line
0674   061E C1                  POP     BC              ; End of program to BC
0675   061F 09                  ADD     HL,BC           ; Find new end
0676   0620 E5                  PUSH    HL              ; Save new end
0677   0621 CD 39 05            CALL    MOVUP           ; Make space for line
0678   0624 E1                  POP     HL              ; Restore new end
0679   0625 22 F6 21            LD      (PROGND),HL     ; Update end of program pointer
0680   0628 EB                  EX      DE,HL           ; Get line to move up in HL
0681   0629 74                  LD      (HL),H          ; Save MSB
0682   062A D1                  POP     DE              ; Get new line number
0683   062B 23                  INC     HL              ; Skip pointer
0684   062C 23                  INC     HL
0685   062D 73                  LD      (HL),E          ; Save LSB of line number
0686   062E 23                  INC     HL
0687   062F 72                  LD      (HL),D          ; Save MSB of line number
0688   0630 23                  INC     HL              ; To first byte in line
0689   0631 11 81 21            LD      DE,BUFFER       ; Copy buffer to program
0690   0634 1A          MOVBUF: LD      A,(DE)          ; Get source
0691   0635 77                  LD      (HL),A          ; Save destinations
0692   0636 23                  INC     HL              ; Next source
0693   0637 13                  INC     DE              ; Next destination
0694   0638 B7                  OR      A               ; Done?
0695   0639 C2 34 06            JP      NZ,MOVBUF       ; No - Repeat
0696   063C CD 85 06    SETPTR: CALL    RUNFST          ; Set line pointers
0697   063F 23                  INC     HL              ; To LSB of pointer
0698   0640 EB                  EX      DE,HL           ; Address to DE
0699   0641 62          PTRLP:  LD      H,D             ; Address to HL
0700   0642 6B                  LD      L,E
0701   0643 7E                  LD      A,(HL)          ; Get LSB of pointer
0702   0644 23                  INC     HL              ; To MSB of pointer
0703   0645 B6                  OR      (HL)            ; Compare with MSB pointer
0704   0646 CA C5 05            JP      Z,GETCMD        ; Get command line if end
0705   0649 23                  INC     HL              ; To LSB of line number
0706   064A 23                  INC     HL              ; Skip line number
0707   064B 23                  INC     HL              ; Point to first byte in line
0708   064C AF                  XOR     A               ; Looking for 00 byte
0709   064D BE          FNDEND: CP      (HL)            ; Found end of line?
0710   064E 23                  INC     HL              ; Move to next byte
0711   064F C2 4D 06            JP      NZ,FNDEND       ; No - Keep looking
0712   0652 EB                  EX      DE,HL           ; Next line address to HL
0713   0653 73                  LD      (HL),E          ; Save LSB of pointer
0714   0654 23                  INC     HL
0715   0655 72                  LD      (HL),D          ; Save MSB of pointer
0716   0656 C3 41 06            JP      PTRLP           ; Do next line
0717   0659             
0718   0659 2A 7E 21    SRCHLN: LD      HL,(BASTXT)     ; Start of program text
0719   065C 44          SRCHLP: LD      B,H             ; BC = Address to look at
0720   065D 4D                  LD      C,L
0721   065E 7E                  LD      A,(HL)          ; Get address of next line
0722   065F 23                  INC     HL
0723   0660 B6                  OR      (HL)            ; End of program found?
0724   0661 2B                  DEC     HL
0725   0662 C8                  RET     Z               ; Yes - Line not found
0726   0663 23                  INC     HL
0727   0664 23                  INC     HL
0728   0665 7E                  LD      A,(HL)          ; Get LSB of line number
0729   0666 23                  INC     HL
0730   0667 66                  LD      H,(HL)          ; Get MSB of line number
0731   0668 6F                  LD      L,A
0732   0669 CD 35 08            CALL    CPDEHL          ; Compare with line in DE
0733   066C 60                  LD      H,B             ; HL = Start of this line
0734   066D 69                  LD      L,C
0735   066E 7E                  LD      A,(HL)          ; Get LSB of next line address
0736   066F 23                  INC     HL
0737   0670 66                  LD      H,(HL)          ; Get MSB of next line address
0738   0671 6F                  LD      L,A             ; Next line to HL
0739   0672 3F                  CCF
0740   0673 C8                  RET     Z               ; Lines found - Exit
0741   0674 3F                  CCF
0742   0675 D0                  RET     NC              ; Line not found,at line after
0743   0676 C3 5C 06            JP      SRCHLP          ; Keep looking
0744   0679             
0745   0679 C0          NEW:    RET     NZ              ; Return if any more on line
0746   067A 2A 7E 21    CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
0747   067D AF                  XOR     A               ; Set program area to empty
0748   067E 77                  LD      (HL),A          ; Save LSB = 00
0749   067F 23                  INC     HL
0750   0680 77                  LD      (HL),A          ; Save MSB = 00
0751   0681 23                  INC     HL
0752   0682 22 F6 21            LD      (PROGND),HL     ; Set program end
0753   0685             
0754   0685 2A 7E 21    RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0755   0688 2B                  DEC     HL
0756   0689             
0757   0689 22 EE 21    INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
0758   068C 2A CF 21            LD      HL,(LSTRAM)     ; Get end of RAM
0759   068F 22 E3 21            LD      (STRBOT),HL     ; Clear string space
0760   0692 AF                  XOR     A
0761   0693 CD D5 09            CALL    RESTOR          ; Reset DATA pointers
0762   0696 2A F6 21            LD      HL,(PROGND)     ; Get end of program
0763   0699 22 F8 21            LD      (VAREND),HL     ; Clear variables
0764   069C 22 FA 21            LD      (ARREND),HL     ; Clear arrays
0765   069F             
0766   069F C1          CLREG:  POP     BC              ; Save return address
0767   06A0 2A 7A 21            LD      HL,(STRSPC)     ; Get end of working RAN
0768   06A3 F9                  LD      SP,HL           ; Set stack
0769   06A4 21 D3 21            LD      HL,TMSTPL       ; Temporary string pool
0770   06A7 22 D1 21            LD      (TMSTPT),HL     ; Reset temporary string ptr
0771   06AA AF                  XOR     A               ; A = 00
0772   06AB 6F                  LD      L,A             ; HL = 0000
0773   06AC 67                  LD      H,A
0774   06AD 22 F4 21            LD      (CONTAD),HL     ; No CONTinue
0775   06B0 32 EB 21            LD      (FORFLG),A      ; Clear FOR flag
0776   06B3 22 FE 21            LD      (FNRGNM),HL     ; Clear FN argument
0777   06B6 E5                  PUSH    HL              ; HL = 0000
0778   06B7 C5                  PUSH    BC              ; Put back return
0779   06B8 2A EE 21    DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
0780   06BB C9                  RET                     ; Return to execution driver
0781   06BC             
0782   06BC 3E 3F       PROMPT: LD      A,'?'           ; '?'
0783   06BE CD 46 08            CALL    OUTC            ; Output character
0784   06C1 3E 20               LD      A,' '           ; Space
0785   06C3 CD 46 08            CALL    OUTC            ; Output character
0786   06C6 C3 6E 21            JP      RINPUT          ; Get input line
0787   06C9             
0788   06C9 AF          CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
0789   06CA 32 CE 21            LD      (DATFLG),A      ; Reset literal flag
0790   06CD 0E 05               LD      C,2+3           ; 2 byte number and 3 nulls
0791   06CF 11 81 21            LD      DE,BUFFER       ; Start of input buffer
0792   06D2 7E          CRNCLP: LD      A,(HL)          ; Get byte
0793   06D3 FE 20               CP      ' '             ; Is it a space?
0794   06D5 CA 51 07            JP      Z,MOVDIR        ; Yes - Copy direct
0795   06D8 47                  LD      B,A             ; Save character
0796   06D9 FE 22               CP      '"'             ; Is it a quote?
0797   06DB CA 71 07            JP      Z,CPYLIT        ; Yes - Copy literal string
0798   06DE B7                  OR      A               ; Is it end of buffer?
0799   06DF CA 78 07            JP      Z,ENDBUF        ; Yes - End buffer
0800   06E2 3A CE 21            LD      A,(DATFLG)      ; Get data type
0801   06E5 B7                  OR      A               ; Literal?
0802   06E6 7E                  LD      A,(HL)          ; Get byte to copy
0803   06E7 C2 51 07            JP      NZ,MOVDIR       ; Literal - Copy direct
0804   06EA FE 3F               CP      '?'             ; Is it '?' short for PRINT
0805   06EC 3E 9E               LD      A,ZPRINT        ; "PRINT" token
0806   06EE CA 51 07            JP      Z,MOVDIR        ; Yes - replace it
0807   06F1 7E                  LD      A,(HL)          ; Get byte again
0808   06F2 FE 30               CP      '0'             ; Is it less than '0'
0809   06F4 DA FC 06            JP      C,FNDWRD        ; Yes - Look for reserved words
0810   06F7 FE 3C               CP      60; ";"+1           ; Is it "0123456789:;" ?
0811   06F9 DA 51 07            JP      C,MOVDIR        ; Yes - copy it direct
0812   06FC D5          FNDWRD: PUSH    DE              ; Look for reserved words
0813   06FD 11 F5 02            LD      DE,WORDS-1      ; Point to table
0814   0700 C5                  PUSH    BC              ; Save count
0815   0701 01 4D 07            LD      BC,RETNAD       ; Where to return to
0816   0704 C5                  PUSH    BC              ; Save return address
0817   0705 06 7F               LD      B,ZEND-1        ; First token value -1
0818   0707 7E                  LD      A,(HL)          ; Get byte
0819   0708 FE 61               CP      'a'             ; Less than 'a' ?
0820   070A DA 15 07            JP      C,SEARCH        ; Yes - search for words
0821   070D FE 7B               CP      'z'+1           ; Greater than 'z' ?
0822   070F D2 15 07            JP      NC,SEARCH       ; Yes - search for words
0823   0712 E6 5F               AND     01011111B       ; Force upper case
0824   0714 77                  LD      (HL),A          ; Replace byte
0825   0715 4E          SEARCH: LD      C,(HL)          ; Search for a word
0826   0716 EB                  EX      DE,HL
0827   0717 23          GETNXT: INC     HL              ; Get next reserved word
0828   0718 B6                  OR      (HL)            ; Start of word?
0829   0719 F2 17 07            JP      P,GETNXT        ; No - move on
0830   071C 04                  INC     B               ; Increment token value
0831   071D 7E                  LD      A, (HL)         ; Get byte from table
0832   071E E6 7F               AND     01111111B       ; Strip bit 7
0833   0720 C8                  RET     Z               ; Return if end of list
0834   0721 B9                  CP      C               ; Same character as in buffer?
0835   0722 C2 17 07            JP      NZ,GETNXT       ; No - get next word
0836   0725 EB                  EX      DE,HL
0837   0726 E5                  PUSH    HL              ; Save start of word
0838   0727             
0839   0727 13          NXTBYT: INC     DE              ; Look through rest of word
0840   0728 1A                  LD      A,(DE)          ; Get byte from table
0841   0729 B7                  OR      A               ; End of word ?
0842   072A FA 49 07            JP      M,MATCH         ; Yes - Match found
0843   072D 4F                  LD      C,A             ; Save it
0844   072E 78                  LD      A,B             ; Get token value
0845   072F FE 88               CP      ZGOTO           ; Is it "GOTO" token ?
0846   0731 C2 38 07            JP      NZ,NOSPC        ; No - Don't allow spaces
0847   0734 CD C5 09            CALL    GETCHR          ; Get next character
0848   0737 2B                  DEC     HL              ; Cancel increment from GETCHR
0849   0738 23          NOSPC:  INC     HL              ; Next byte
0850   0739 7E                  LD      A,(HL)          ; Get byte
0851   073A FE 61               CP      'a'             ; Less than 'a' ?
0852   073C DA 41 07            JP      C,NOCHNG        ; Yes - don't change
0853   073F E6 5F               AND     01011111B       ; Make upper case
0854   0741 B9          NOCHNG: CP      C               ; Same as in buffer ?
0855   0742 CA 27 07            JP      Z,NXTBYT        ; Yes - keep testing
0856   0745 E1                  POP     HL              ; Get back start of word
0857   0746 C3 15 07            JP      SEARCH          ; Look at next word
0858   0749             
0859   0749 48          MATCH:  LD      C,B             ; Word found - Save token value
0860   074A F1                  POP     AF              ; Throw away return
0861   074B EB                  EX      DE,HL
0862   074C C9                  RET                     ; Return to "RETNAD"
0863   074D EB          RETNAD: EX      DE,HL           ; Get address in string
0864   074E 79                  LD      A,C             ; Get token value
0865   074F C1                  POP     BC              ; Restore buffer length
0866   0750 D1                  POP     DE              ; Get destination address
0867   0751 23          MOVDIR: INC     HL              ; Next source in buffer
0868   0752 12                  LD      (DE),A          ; Put byte in buffer
0869   0753 13                  INC     DE              ; Move up buffer
0870   0754 0C                  INC     C               ; Increment length of buffer
0871   0755 D6 3A               SUB     ':'             ; End of statement?
0872   0757 CA 5F 07            JP      Z,SETLIT        ; Jump if multi-statement line
0873   075A FE 49               CP      ZDATA-3AH       ; Is it DATA statement ?
0874   075C C2 62 07            JP      NZ,TSTREM       ; No - see if REM
0875   075F 32 CE 21    SETLIT: LD      (DATFLG),A      ; Set literal flag
0876   0762 D6 54       TSTREM: SUB     ZREM-3AH        ; Is it REM?
0877   0764 C2 D2 06            JP      NZ,CRNCLP       ; No - Leave flag
0878   0767 47                  LD      B,A             ; Copy rest of buffer
0879   0768 7E          NXTCHR: LD      A,(HL)          ; Get byte
0880   0769 B7                  OR      A               ; End of line ?
0881   076A CA 78 07            JP      Z,ENDBUF        ; Yes - Terminate buffer
0882   076D B8                  CP      B               ; End of statement ?
0883   076E CA 51 07            JP      Z,MOVDIR        ; Yes - Get next one
0884   0771 23          CPYLIT: INC     HL              ; Move up source string
0885   0772 12                  LD      (DE),A          ; Save in destination
0886   0773 0C                  INC     C               ; Increment length
0887   0774 13                  INC     DE              ; Move up destination
0888   0775 C3 68 07            JP      NXTCHR          ; Repeat
0889   0778             
0890   0778 21 80 21    ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
0891   077B 12                  LD      (DE),A          ; Mark end of buffer (A = 00)
0892   077C 13                  INC     DE
0893   077D 12                  LD      (DE),A          ; A = 00
0894   077E 13                  INC     DE
0895   077F 12                  LD      (DE),A          ; A = 00
0896   0780 C9                  RET
0897   0781             
0898   0781 3A 64 21    DODEL:  LD      A,(NULFLG)      ; Get null flag status
0899   0784 B7                  OR      A               ; Is it zero?
0900   0785 3E 00               LD      A,0             ; Zero A - Leave flags
0901   0787 32 64 21            LD      (NULFLG),A      ; Zero null flag
0902   078A C2 95 07            JP      NZ,ECHDEL       ; Set - Echo it
0903   078D 05                  DEC     B               ; Decrement length
0904   078E CA B2 07            JP      Z,GETLIN        ; Get line again if empty
0905   0791 CD 46 08            CALL    OUTC            ; Output null character
0906   0794 3E                  .BYTE   3EH             ; Skip "DEC B"
0907   0795 05          ECHDEL: DEC     B               ; Count bytes in buffer
0908   0796 2B                  DEC     HL              ; Back space buffer
0909   0797 CA A9 07            JP      Z,OTKLN         ; No buffer - Try again
0910   079A 7E                  LD      A,(HL)          ; Get deleted byte
0911   079B CD 46 08            CALL    OUTC            ; Echo it
0912   079E C3 BB 07            JP      MORINP          ; Get more input
0913   07A1             
0914   07A1 05          DELCHR: DEC     B               ; Count bytes in buffer
0915   07A2 2B                  DEC     HL              ; Back space buffer
0916   07A3 CD 46 08            CALL    OUTC            ; Output character in A
0917   07A6 C2 BB 07            JP      NZ,MORINP       ; Not end - Get more
0918   07A9 CD 46 08    OTKLN:  CALL    OUTC            ; Output character in A
0919   07AC CD 6D 0C    KILIN:  CALL    PRNTCRLF        ; Output CRLF
0920   07AF C3 B2 07            JP      TTYLIN          ; Get line again
0921   07B2             
0922   07B2             GETLIN:
0923   07B2 21 81 21    TTYLIN: LD      HL,BUFFER       ; Get a line by character
0924   07B5 06 01               LD      B,1             ; Set buffer as empty
0925   07B7 AF                  XOR     A
0926   07B8 32 64 21            LD      (NULFLG),A      ; Clear null flag
0927   07BB CD 70 08    MORINP: CALL    CLOTST          ; Get character and test ^O
0928   07BE 4F                  LD      C,A             ; Save character in C
0929   07BF FE 7F               CP      DEL             ; Delete character?
0930   07C1 CA 81 07            JP      Z,DODEL         ; Yes - Process it
0931   07C4 3A 64 21            LD      A,(NULFLG)      ; Get null flag
0932   07C7 B7                  OR      A               ; Test null flag status
0933   07C8 CA D4 07            JP      Z,PROCES        ; Reset - Process character
0934   07CB 3E 00               LD      A,0             ; Set a null
0935   07CD CD 46 08            CALL    OUTC            ; Output null
0936   07D0 AF                  XOR     A               ; Clear A
0937   07D1 32 64 21            LD      (NULFLG),A      ; Reset null flag
0938   07D4 79          PROCES: LD      A,C             ; Get character
0939   07D5 FE 07               CP      CTRLG           ; Bell?
0940   07D7 CA 18 08            JP      Z,PUTCTL        ; Yes - Save it
0941   07DA FE 03               CP      CTRLC           ; Is it control "C"?
0942   07DC CC 6D 0C            CALL    Z,PRNTCRLF      ; Yes - Output CRLF
0943   07DF 37                  SCF                     ; Flag break
0944   07E0 C8                  RET     Z               ; Return if control "C"
0945   07E1 FE 0D               CP      CR              ; Is it enter?
0946   07E3 CA 68 0C            JP      Z,ENDINP        ; Yes - Terminate input
0947   07E6 FE 15               CP      CTRLU           ; Is it control "U"?
0948   07E8 CA AC 07            JP      Z,KILIN         ; Yes - Get another line
0949   07EB FE 40               CP      '@'             ; Is it "kill line"?
0950   07ED CA A9 07            JP      Z,OTKLN         ; Yes - Kill line
0951   07F0 FE 5F               CP      '_'             ; Is it delete?
0952   07F2 CA A1 07            JP      Z,DELCHR        ; Yes - Delete character
0953   07F5 FE 08               CP      BKSP            ; Is it backspace?
0954   07F7 CA A1 07            JP      Z,DELCHR        ; Yes - Delete character
0955   07FA FE 12               CP      CTRLR           ; Is it control "R"?
0956   07FC C2 13 08            JP      NZ,PUTBUF       ; No - Put in buffer
0957   07FF C5                  PUSH    BC              ; Save buffer length
0958   0800 D5                  PUSH    DE              ; Save DE
0959   0801 E5                  PUSH    HL              ; Save buffer address
0960   0802 36 00               LD      (HL),0          ; Mark end of buffer
0961   0804 CD 1D 1E            CALL    OUTNCR          ; Output and do CRLF
0962   0807 21 81 21            LD      HL,BUFFER       ; Point to buffer start
0963   080A CD 0B 13            CALL    PRS             ; Output buffer
0964   080D E1                  POP     HL              ; Restore buffer address
0965   080E D1                  POP     DE              ; Restore DE
0966   080F C1                  POP     BC              ; Restore buffer length
0967   0810 C3 BB 07            JP      MORINP          ; Get another character
0968   0813             
0969   0813 FE 20       PUTBUF: CP      ' '             ; Is it a control code?
0970   0815 DA BB 07            JP      C,MORINP        ; Yes - Ignore
0971   0818 78          PUTCTL: LD      A,B             ; Get number of bytes in buffer
0972   0819 FE 49               CP      72+1            ; Test for line overflow
0973   081B 3E 07               LD      A,CTRLG         ; Set a bell
0974   081D D2 2D 08            JP      NC,OUTNBS       ; Ring bell if buffer full
0975   0820 79                  LD      A,C             ; Get character
0976   0821 71                  LD      (HL),C          ; Save in buffer
0977   0822 32 EC 21            LD      (LSTBIN),A      ; Save last input byte
0978   0825 23                  INC     HL              ; Move up buffer
0979   0826 04                  INC     B               ; Increment length
0980   0827 CD 46 08    OUTIT:  CALL    OUTC            ; Output the character entered
0981   082A C3 BB 07            JP      MORINP          ; Get another character
0982   082D             
0983   082D CD 46 08    OUTNBS: CALL    OUTC            ; Output bell and back over it
0984   0830 3E 08               LD      A,BKSP          ; Set back space
0985   0832 C3 27 08            JP      OUTIT           ; Output it and get more
0986   0835             
0987   0835 7C          CPDEHL: LD      A,H             ; Get H
0988   0836 92                  SUB     D               ; Compare with D
0989   0837 C0                  RET     NZ              ; Different - Exit
0990   0838 7D                  LD      A,L             ; Get L
0991   0839 93                  SUB     E               ; Compare with E
0992   083A C9                  RET                     ; Return status
0993   083B             
0994   083B 7E          CHKSYN: LD      A,(HL)          ; Check syntax of character
0995   083C E3                  EX      (SP),HL         ; Address of test byte
0996   083D BE                  CP      (HL)            ; Same as in code string?
0997   083E 23                  INC     HL              ; Return address
0998   083F E3                  EX      (SP),HL         ; Put it back
0999   0840 CA C5 09            JP      Z,GETCHR        ; Yes - Get next character
1000   0843 C3 6D 05            JP      SNERR           ; Different - ?SN Error
1001   0846             
1002   0846 F5          OUTC:   PUSH    AF              ; Save character
1003   0847 3A 65 21            LD      A,(CTLOFG)      ; Get control "O" flag
1004   084A B7                  OR      A               ; Is it set?
1005   084B C2 40 13            JP      NZ,POPAF        ; Yes - don't output
1006   084E F1                  POP     AF              ; Restore character
1007   084F C5                  PUSH    BC              ; Save buffer length
1008   0850 F5                  PUSH    AF              ; Save character
1009   0851 FE 20               CP      ' '             ; Is it a control code?
1010   0853 DA 6A 08            JP      C,DINPOS        ; Yes - Don't INC POS(X)
1011   0856 3A 62 21            LD      A,(LWIDTH)      ; Get line width
1012   0859 47                  LD      B,A             ; To B
1013   085A 3A CB 21            LD      A,(CURPOS)      ; Get cursor position
1014   085D 04                  INC     B               ; Width 255?
1015   085E CA 66 08            JP      Z,INCLEN        ; Yes - No width limit
1016   0861 05                  DEC     B               ; Restore width
1017   0862 B8                  CP      B               ; At end of line?
1018   0863 CC 6D 0C            CALL    Z,PRNTCRLF      ; Yes - output CRLF
1019   0866 3C          INCLEN: INC     A               ; Move on one character
1020   0867 32 CB 21            LD      (CURPOS),A      ; Save new position
1021   086A F1          DINPOS: POP     AF              ; Restore character
1022   086B C1                  POP     BC              ; Restore buffer length
1023   086C CD 06 1E            CALL    MONOUT          ; Send it
1024   086F C9                  RET
1025   0870             
1026   0870 CD CA 1C    CLOTST: CALL    GETINP          ; Get input character
1027   0873 E6 7F               AND     01111111B       ; Strip bit 7
1028   0875 FE 0F               CP      CTRLO           ; Is it control "O"?
1029   0877 C0                  RET     NZ              ; No don't flip flag
1030   0878 3A 65 21            LD      A,(CTLOFG)      ; Get flag
1031   087B 2F                  CPL                     ; Flip it
1032   087C 32 65 21            LD      (CTLOFG),A      ; Put it back
1033   087F AF                  XOR     A               ; Null character
1034   0880 C9                  RET
1035   0881             
1036   0881 CD 91 0A    LIST:   CALL    ATOH            ; ASCII number to DE
1037   0884 C0                  RET     NZ              ; Return if anything extra
1038   0885 C1                  POP     BC              ; Rubbish - Not needed
1039   0886 CD 59 06            CALL    SRCHLN          ; Search for line number in DE
1040   0889 C5                  PUSH    BC              ; Save address of line
1041   088A CD D7 08            CALL    SETLIN          ; Set up lines counter
1042   088D E1          LISTLP: POP     HL              ; Restore address of line
1043   088E 4E                  LD      C,(HL)          ; Get LSB of next line
1044   088F 23                  INC     HL
1045   0890 46                  LD      B,(HL)          ; Get MSB of next line
1046   0891 23                  INC     HL
1047   0892 78                  LD      A,B             ; BC = 0 (End of program)?
1048   0893 B1                  OR      C
1049   0894 CA B8 05            JP      Z,PRNTOK        ; Yes - Go to command mode
1050   0897 CD E0 08            CALL    COUNT           ; Count lines
1051   089A CD F0 09            CALL    TSTBRK          ; Test for break key
1052   089D C5                  PUSH    BC              ; Save address of next line
1053   089E CD 6D 0C            CALL    PRNTCRLF        ; Output CRLF
1054   08A1 5E                  LD      E,(HL)          ; Get LSB of line number
1055   08A2 23                  INC     HL
1056   08A3 56                  LD      D,(HL)          ; Get MSB of line number
1057   08A4 23                  INC     HL
1058   08A5 E5                  PUSH    HL              ; Save address of line start
1059   08A6 EB                  EX      DE,HL           ; Line number to HL
1060   08A7 CD AE 19            CALL    PRNTHL          ; Output line number in decimal
1061   08AA 3E 20               LD      A,' '           ; Space after line number
1062   08AC E1                  POP     HL              ; Restore start of line address
1063   08AD CD 46 08    LSTLP2: CALL    OUTC            ; Output character in A
1064   08B0 7E          LSTLP3: LD      A,(HL)          ; Get next byte in line
1065   08B1 B7                  OR      A               ; End of line?
1066   08B2 23                  INC     HL              ; To next byte in line
1067   08B3 CA 8D 08            JP      Z,LISTLP        ; Yes - get next line
1068   08B6 F2 AD 08            JP      P,LSTLP2        ; No token - output it
1069   08B9 D6 7F               SUB     ZEND-1          ; Find and output word
1070   08BB 4F                  LD      C,A             ; Token offset+1 to C
1071   08BC 11 F6 02            LD      DE,WORDS        ; Reserved word list
1072   08BF 1A          FNDTOK: LD      A,(DE)          ; Get character in list
1073   08C0 13                  INC     DE              ; Move on to next
1074   08C1 B7                  OR      A               ; Is it start of word?
1075   08C2 F2 BF 08            JP      P,FNDTOK        ; No - Keep looking for word
1076   08C5 0D                  DEC     C               ; Count words
1077   08C6 C2 BF 08            JP      NZ,FNDTOK       ; Not there - keep looking
1078   08C9 E6 7F       OUTWRD: AND     01111111B       ; Strip bit 7
1079   08CB CD 46 08            CALL    OUTC            ; Output first character
1080   08CE 1A                  LD      A,(DE)          ; Get next character
1081   08CF 13                  INC     DE              ; Move on to next
1082   08D0 B7                  OR      A               ; Is it end of word?
1083   08D1 F2 C9 08            JP      P,OUTWRD        ; No - output the rest
1084   08D4 C3 B0 08            JP      LSTLP3          ; Next byte in line
1085   08D7             
1086   08D7 E5          SETLIN: PUSH    HL              ; Set up LINES counter
1087   08D8 2A 68 21            LD      HL,(LINESN)     ; Get LINES number
1088   08DB 22 66 21            LD      (LINESC),HL     ; Save in LINES counter
1089   08DE E1                  POP     HL
1090   08DF C9                  RET
1091   08E0             
1092   08E0 E5          COUNT:  PUSH    HL              ; Save code string address
1093   08E1 D5                  PUSH    DE
1094   08E2 2A 66 21            LD      HL,(LINESC)     ; Get LINES counter
1095   08E5 11 FF FF            LD      DE,-1
1096   08E8 ED 5A               ADC     HL,DE           ; Decrement
1097   08EA 22 66 21            LD      (LINESC),HL     ; Put it back
1098   08ED D1                  POP     DE
1099   08EE E1                  POP     HL              ; Restore code string address
1100   08EF F0                  RET     P               ; Return if more lines to go
1101   08F0 E5                  PUSH    HL              ; Save code string address
1102   08F1 2A 68 21            LD      HL,(LINESN)     ; Get LINES number
1103   08F4 22 66 21            LD      (LINESC),HL     ; Reset LINES counter
1104   08F7 CD CA 1C            CALL    GETINP          ; Get input character
1105   08FA FE 03               CP      CTRLC           ; Is it control "C"?
1106   08FC CA 03 09            JP      Z,RSLNBK        ; Yes - Reset LINES and break
1107   08FF E1                  POP     HL              ; Restore code string address
1108   0900 C3 E0 08            JP      COUNT           ; Keep on counting
1109   0903             
1110   0903 2A 68 21    RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1111   0906 22 66 21            LD      (LINESC),HL     ; Reset LINES counter
1112   0909 C3 67 02            JP      BRKRET          ; Go and output "Break"
1113   090C             
1114   090C 3E 64       FOR:    LD      A,64H           ; Flag "FOR" assignment
1115   090E 32 EB 21            LD      (FORFLG),A      ; Save "FOR" flag
1116   0911 CD 73 0B            CALL    LET             ; Set up initial index
1117   0914 C1                  POP     BC              ; Drop RETurn address
1118   0915 E5                  PUSH    HL              ; Save code string address
1119   0916 CD 5C 0B            CALL    DATA            ; Get next statement address
1120   0919 22 E7 21            LD      (LOOPST),HL     ; Save it for start of loop
1121   091C 21 02 00            LD      HL,2            ; Offset for "FOR" block
1122   091F 39                  ADD     HL,SP           ; Point to it
1123   0920 CD 1A 05    FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1124   0923 D1                  POP     DE              ; Get code string address
1125   0924 C2 3C 09            JP      NZ,FORFND       ; No nesting found
1126   0927 09                  ADD     HL,BC           ; Move into "FOR" block
1127   0928 D5                  PUSH    DE              ; Save code string address
1128   0929 2B                  DEC     HL
1129   092A 56                  LD      D,(HL)          ; Get MSB of loop statement
1130   092B 2B                  DEC     HL
1131   092C 5E                  LD      E,(HL)          ; Get LSB of loop statement
1132   092D 23                  INC     HL
1133   092E 23                  INC     HL
1134   092F E5                  PUSH    HL              ; Save block address
1135   0930 2A E7 21            LD      HL,(LOOPST)     ; Get address of loop statement
1136   0933 CD 35 08            CALL    CPDEHL          ; Compare the FOR loops
1137   0936 E1                  POP     HL              ; Restore block address
1138   0937 C2 20 09            JP      NZ,FORSLP       ; Different FORs - Find another
1139   093A D1                  POP     DE              ; Restore code string address
1140   093B F9                  LD      SP,HL           ; Remove all nested loops
1141   093C             
1142   093C EB          FORFND: EX      DE,HL           ; Code string address to HL
1143   093D 0E 08               LD      C,8
1144   093F CD 4A 05            CALL    CHKSTK          ; Check for 8 levels of stack
1145   0942 E5                  PUSH    HL              ; Save code string address
1146   0943 2A E7 21            LD      HL,(LOOPST)     ; Get first statement of loop
1147   0946 E3                  EX      (SP),HL         ; Save and restore code string
1148   0947 E5                  PUSH    HL              ; Re-save code string address
1149   0948 2A 7C 21            LD      HL,(LINEAT)     ; Get current line number
1150   094B E3                  EX      (SP),HL         ; Save and restore code string
1151   094C CD 35 0E            CALL    TSTNUM          ; Make sure it's a number
1152   094F CD 3B 08            CALL    CHKSYN          ; Make sure "TO" is next
1153   0952 A6                  .BYTE   ZTO          ; "TO" token
1154   0953 CD 32 0E            CALL    GETNUM          ; Get "TO" expression value
1155   0956 E5                  PUSH    HL              ; Save code string address
1156   0957 CD 60 18            CALL    BCDEFP          ; Move "TO" value to BCDE
1157   095A E1                  POP     HL              ; Restore code string address
1158   095B C5                  PUSH    BC              ; Save "TO" value in block
1159   095C D5                  PUSH    DE
1160   095D 01 00 81            LD      BC,8100H        ; BCDE - 1 (default STEP)
1161   0960 51                  LD      D,C             ; C=0
1162   0961 5A                  LD      E,D             ; D=0
1163   0962 7E                  LD      A,(HL)          ; Get next byte in code string
1164   0963 FE AB               CP      ZSTEP           ; See if "STEP" is stated
1165   0965 3E 01               LD      A,1             ; Sign of step = 1
1166   0967 C2 78 09            JP      NZ,SAVSTP       ; No STEP given - Default to 1
1167   096A CD C5 09            CALL    GETCHR          ; Jump over "STEP" token
1168   096D CD 32 0E            CALL    GETNUM          ; Get step value
1169   0970 E5                  PUSH    HL              ; Save code string address
1170   0971 CD 60 18            CALL    BCDEFP          ; Move STEP to BCDE
1171   0974 CD 14 18            CALL    TSTSGN          ; Test sign of FPREG
1172   0977 E1                  POP     HL              ; Restore code string address
1173   0978 C5          SAVSTP: PUSH    BC              ; Save the STEP value in block
1174   0979 D5                  PUSH    DE
1175   097A F5                  PUSH    AF              ; Save sign of STEP
1176   097B 33                  INC     SP              ; Don't save flags
1177   097C E5                  PUSH    HL              ; Save code string address
1178   097D 2A EE 21            LD      HL,(BRKLIN)     ; Get address of index variable
1179   0980 E3                  EX      (SP),HL         ; Save and restore code string
1180   0981 06 81       PUTFID: LD      B,ZFOR          ; "FOR" block marker
1181   0983 C5                  PUSH    BC              ; Save it
1182   0984 33                  INC     SP              ; Don't save C
1183   0985             
1184   0985 CD F0 09    RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1185   0988 22 EE 21            LD      (BRKLIN),HL     ; Save code address for break
1186   098B 7E                  LD      A,(HL)          ; Get next byte in code string
1187   098C FE 3A               CP      ':'             ; Multi statement line?
1188   098E CA A5 09            JP      Z,EXCUTE        ; Yes - Execute it
1189   0991 B7                  OR      A               ; End of line?
1190   0992 C2 6D 05            JP      NZ,SNERR        ; No - Syntax error
1191   0995 23                  INC     HL              ; Point to address of next line
1192   0996 7E                  LD      A,(HL)          ; Get LSB of line pointer
1193   0997 23                  INC     HL
1194   0998 B6                  OR      (HL)            ; Is it zero (End of prog)?
1195   0999 CA 17 0A            JP      Z,ENDPRG        ; Yes - Terminate execution
1196   099C 23                  INC     HL              ; Point to line number
1197   099D 5E                  LD      E,(HL)          ; Get LSB of line number
1198   099E 23                  INC     HL
1199   099F 56                  LD      D,(HL)          ; Get MSB of line number
1200   09A0 EB                  EX      DE,HL           ; Line number to HL
1201   09A1 22 7C 21            LD      (LINEAT),HL     ; Save as current line number
1202   09A4 EB                  EX      DE,HL           ; Line number back to DE
1203   09A5 CD C5 09    EXCUTE: CALL    GETCHR          ; Get key word
1204   09A8 11 85 09            LD      DE,RUNCNT       ; Where to RETurn to
1205   09AB D5                  PUSH    DE              ; Save for RETurn
1206   09AC C8          IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1207   09AD D6 80       ONJMP:  SUB     ZEND            ; Is it a token?
1208   09AF DA 73 0B            JP      C,LET           ; No - try to assign it
1209   09B2 FE 25               CP      ZNEW+1-ZEND     ; END to NEW ?
1210   09B4 D2 6D 05            JP      NC,SNERR        ; Not a key word - ?SN Error
1211   09B7 07                  RLCA                    ; Double it
1212   09B8 4F                  LD      C,A             ; BC = Offset into table
1213   09B9 06 00               LD      B,0
1214   09BB EB                  EX      DE,HL           ; Save code string address
1215   09BC 21 15 04            LD      HL,WORDTB       ; Keyword address table
1216   09BF 09                  ADD     HL,BC           ; Point to routine address
1217   09C0 4E                  LD      C,(HL)          ; Get LSB of routine address
1218   09C1 23                  INC     HL
1219   09C2 46                  LD      B,(HL)          ; Get MSB of routine address
1220   09C3 C5                  PUSH    BC              ; Save routine address
1221   09C4 EB                  EX      DE,HL           ; Restore code string address
1222   09C5             
1223   09C5 23          GETCHR: INC     HL              ; Point to next character
1224   09C6 7E                  LD      A,(HL)          ; Get next code string byte
1225   09C7 FE 3A               CP      ':'             ; Z if ':'
1226   09C9 D0                  RET     NC              ; NC if > "9"
1227   09CA FE 20               CP      ' '
1228   09CC CA C5 09            JP      Z,GETCHR        ; Skip over spaces
1229   09CF FE 30               CP      '0'
1230   09D1 3F                  CCF                     ; NC if < '0'
1231   09D2 3C                  INC     A               ; Test for zero - Leave carry
1232   09D3 3D                  DEC     A               ; Z if Null
1233   09D4 C9                  RET
1234   09D5             
1235   09D5 EB          RESTOR: EX      DE,HL           ; Save code string address
1236   09D6 2A 7E 21            LD      HL,(BASTXT)     ; Point to start of program
1237   09D9 CA EA 09            JP      Z,RESTNL        ; Just RESTORE - reset pointer
1238   09DC EB                  EX      DE,HL           ; Restore code string address
1239   09DD CD 91 0A            CALL    ATOH            ; Get line number to DE
1240   09E0 E5                  PUSH    HL              ; Save code string address
1241   09E1 CD 59 06            CALL    SRCHLN          ; Search for line number in DE
1242   09E4 60                  LD      H,B             ; HL = Address of line
1243   09E5 69                  LD      L,C
1244   09E6 D1                  POP     DE              ; Restore code string address
1245   09E7 D2 32 0B            JP      NC,ULERR        ; ?UL Error if not found
1246   09EA 2B          RESTNL: DEC     HL              ; Byte before DATA statement
1247   09EB 22 FC 21    UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1248   09EE EB                  EX      DE,HL           ; Restore code string address
1249   09EF C9                  RET
1250   09F0             
1251   09F0             
1252   09F0 DF          TSTBRK: RST     18H             ; Check input status
1253   09F1 C8                  RET     Z               ; No key, go back
1254   09F2 D7                  RST     10H             ; Get the key into A
1255   09F3 FE 1B               CP      ESC             ; Escape key?
1256   09F5 28 11               JR      Z,BRK           ; Yes, break
1257   09F7 FE 03               CP      CTRLC           ; <Ctrl-C>
1258   09F9 28 0D               JR      Z,BRK           ; Yes, break
1259   09FB FE 13               CP      CTRLS           ; Stop scrolling?
1260   09FD C0                  RET     NZ              ; Other key, ignore
1261   09FE             
1262   09FE             
1263   09FE D7          STALL:  RST     10H             ; Wait for key
1264   09FF FE 11               CP      CTRLQ           ; Resume scrolling?
1265   0A01 C8                  RET      Z              ; Release the chokehold
1266   0A02 FE 03               CP      CTRLC           ; Second break?
1267   0A04 28 07               JR      Z,STOP          ; Break during hold exits prog
1268   0A06 18 F6               JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1269   0A08             
1270   0A08 3E FF       BRK     LD      A,$FF           ; Set BRKFLG
1271   0A0A 32 6D 21            LD      (BRKFLG),A      ; Store it
1272   0A0D             
1273   0A0D             
1274   0A0D C0          STOP:   RET     NZ              ; Exit if anything else
1275   0A0E F6                  .BYTE   0F6H            ; Flag "STOP"
1276   0A0F C0          PEND:   RET     NZ              ; Exit if anything else
1277   0A10 22 EE 21            LD      (BRKLIN),HL     ; Save point of break
1278   0A13 21                  .BYTE   21H             ; Skip "OR 11111111B"
1279   0A14 F6 FF       INPBRK: OR      11111111B       ; Flag "Break" wanted
1280   0A16 C1                  POP     BC              ; Return not needed and more
1281   0A17 2A 7C 21    ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1282   0A1A F5                  PUSH    AF              ; Save STOP / END status
1283   0A1B 7D                  LD      A,L             ; Is it direct break?
1284   0A1C A4                  AND     H
1285   0A1D 3C                  INC     A               ; Line is -1 if direct break
1286   0A1E CA 2A 0A            JP      Z,NOLIN         ; Yes - No line number
1287   0A21 22 F2 21            LD      (ERRLIN),HL     ; Save line of break
1288   0A24 2A EE 21            LD      HL,(BRKLIN)     ; Get point of break
1289   0A27 22 F4 21            LD      (CONTAD),HL     ; Save point to CONTinue
1290   0A2A AF          NOLIN:  XOR     A
1291   0A2B 32 65 21            LD      (CTLOFG),A      ; Enable output
1292   0A2E CD 60 0C            CALL    STTLIN          ; Start a new line
1293   0A31 F1                  POP     AF              ; Restore STOP / END status
1294   0A32 21 10 05            LD      HL,BRKMSG       ; "Break" message
1295   0A35 C2 A1 05            JP      NZ,ERRIN        ; "in line" wanted?
1296   0A38 C3 B8 05            JP      PRNTOK          ; Go to command mode
1297   0A3B             
1298   0A3B 2A F4 21    CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1299   0A3E 7C                  LD      A,H             ; Is it zero?
1300   0A3F B5                  OR      L
1301   0A40 1E 20               LD      E,CN            ; ?CN Error
1302   0A42 CA 81 05            JP      Z,ERROR         ; Yes - output "?CN Error"
1303   0A45 EB                  EX      DE,HL           ; Save code string address
1304   0A46 2A F2 21            LD      HL,(ERRLIN)     ; Get line of last break
1305   0A49 22 7C 21            LD      (LINEAT),HL     ; Set up current line number
1306   0A4C EB                  EX      DE,HL           ; Restore code string address
1307   0A4D C9                  RET                     ; CONTinue where left off
1308   0A4E             
1309   0A4E CD 93 15    NULL:   CALL    GETINT          ; Get integer 0-255
1310   0A51 C0                  RET     NZ              ; Return if bad value
1311   0A52 32 61 21            LD      (NULLS),A       ; Set nulls number
1312   0A55 C9                  RET
1313   0A56             
1314   0A56             
1315   0A56 E5          ACCSUM: PUSH    HL              ; Save address in array
1316   0A57 2A 6A 21            LD      HL,(CHKSUM)     ; Get check sum
1317   0A5A 06 00               LD      B,0             ; BC - Value of byte
1318   0A5C 4F                  LD      C,A
1319   0A5D 09                  ADD     HL,BC           ; Add byte to check sum
1320   0A5E 22 6A 21            LD      (CHKSUM),HL     ; Re-save check sum
1321   0A61 E1                  POP     HL              ; Restore address in array
1322   0A62 C9                  RET
1323   0A63             
1324   0A63 7E          CHKLTR: LD      A,(HL)          ; Get byte
1325   0A64 FE 41               CP      'A'             ; < 'a' ?
1326   0A66 D8                  RET     C               ; Carry set if not letter
1327   0A67 FE 5B               CP      'Z'+1           ; > 'z' ?
1328   0A69 3F                  CCF
1329   0A6A C9                  RET                     ; Carry set if not letter
1330   0A6B             
1331   0A6B CD C5 09    FPSINT: CALL    GETCHR          ; Get next character
1332   0A6E CD 32 0E    POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1333   0A71 CD 14 18    DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1334   0A74 FA 8C 0A            JP      M,FCERR         ; Negative - ?FC Error
1335   0A77 3A 07 22    DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1336   0A7A FE 90               CP      80H+16          ; Exponent in range (16 bits)?
1337   0A7C DA BC 18            JP      C,FPINT         ; Yes - convert it
1338   0A7F 01 80 90            LD      BC,9080H        ; BCDE = -32768
1339   0A82 11 00 00            LD      DE,0000
1340   0A85 E5                  PUSH    HL              ; Save code string address
1341   0A86 CD 8F 18            CALL    CMPNUM          ; Compare FPREG with BCDE
1342   0A89 E1                  POP     HL              ; Restore code string address
1343   0A8A 51                  LD      D,C             ; MSB to D
1344   0A8B C8                  RET     Z               ; Return if in range
1345   0A8C 1E 08       FCERR:  LD      E,FC            ; ?FC Error
1346   0A8E C3 81 05            JP      ERROR           ; Output error-
1347   0A91             
1348   0A91 2B          ATOH:   DEC     HL              ; ASCII number to DE binary
1349   0A92 11 00 00    GETLN:  LD      DE,0            ; Get number to DE
1350   0A95 CD C5 09    GTLNLP: CALL    GETCHR          ; Get next character
1351   0A98 D0                  RET     NC              ; Exit if not a digit
1352   0A99 E5                  PUSH    HL              ; Save code string address
1353   0A9A F5                  PUSH    AF              ; Save digit
1354   0A9B 21 98 19            LD      HL,65529/10     ; Largest number 65529
1355   0A9E CD 35 08            CALL    CPDEHL          ; Number in range?
1356   0AA1 DA 6D 05            JP      C,SNERR         ; No - ?SN Error
1357   0AA4 62                  LD      H,D             ; HL = Number
1358   0AA5 6B                  LD      L,E
1359   0AA6 19                  ADD     HL,DE           ; Times 2
1360   0AA7 29                  ADD     HL,HL           ; Times 4
1361   0AA8 19                  ADD     HL,DE           ; Times 5
1362   0AA9 29                  ADD     HL,HL           ; Times 10
1363   0AAA F1                  POP     AF              ; Restore digit
1364   0AAB D6 30               SUB     '0'             ; Make it 0 to 9
1365   0AAD 5F                  LD      E,A             ; DE = Value of digit
1366   0AAE 16 00               LD      D,0
1367   0AB0 19                  ADD     HL,DE           ; Add to number
1368   0AB1 EB                  EX      DE,HL           ; Number to DE
1369   0AB2 E1                  POP     HL              ; Restore code string address
1370   0AB3 C3 95 0A            JP      GTLNLP          ; Go to next character
1371   0AB6             
1372   0AB6 CA 89 06    CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1373   0AB9 CD 6E 0A            CALL    POSINT          ; Get integer 0 to 32767 to DE
1374   0ABC 2B                  DEC     HL              ; Cancel increment
1375   0ABD CD C5 09            CALL    GETCHR          ; Get next character
1376   0AC0 E5                  PUSH    HL              ; Save code string address
1377   0AC1 2A CF 21            LD      HL,(LSTRAM)     ; Get end of RAM
1378   0AC4 CA D9 0A            JP      Z,STORED        ; No value given - Use stored
1379   0AC7 E1                  POP     HL              ; Restore code string address
1380   0AC8 CD 3B 08            CALL    CHKSYN          ; Check for comma
1381   0ACB 2C                  .BYTE      ','
1382   0ACC D5                  PUSH    DE              ; Save number
1383   0ACD CD 6E 0A            CALL    POSINT          ; Get integer 0 to 32767
1384   0AD0 2B                  DEC     HL              ; Cancel increment
1385   0AD1 CD C5 09            CALL    GETCHR          ; Get next character
1386   0AD4 C2 6D 05            JP      NZ,SNERR        ; ?SN Error if more on line
1387   0AD7 E3                  EX      (SP),HL         ; Save code string address
1388   0AD8 EB                  EX      DE,HL           ; Number to DE
1389   0AD9 7D          STORED: LD      A,L             ; Get LSB of new RAM top
1390   0ADA 93                  SUB     E               ; Subtract LSB of string space
1391   0ADB 5F                  LD      E,A             ; Save LSB
1392   0ADC 7C                  LD      A,H             ; Get MSB of new RAM top
1393   0ADD 9A                  SBC     A,D             ; Subtract MSB of string space
1394   0ADE 57                  LD      D,A             ; Save MSB
1395   0ADF DA 62 05            JP      C,OMERR         ; ?OM Error if not enough mem
1396   0AE2 E5                  PUSH    HL              ; Save RAM top
1397   0AE3 2A F6 21            LD      HL,(PROGND)     ; Get program end
1398   0AE6 01 28 00            LD      BC,40           ; 40 Bytes minimum working RAM
1399   0AE9 09                  ADD     HL,BC           ; Get lowest address
1400   0AEA CD 35 08            CALL    CPDEHL          ; Enough memory?
1401   0AED D2 62 05            JP      NC,OMERR        ; No - ?OM Error
1402   0AF0 EB                  EX      DE,HL           ; RAM top to HL
1403   0AF1 22 7A 21            LD      (STRSPC),HL     ; Set new string space
1404   0AF4 E1                  POP     HL              ; End of memory to use
1405   0AF5 22 CF 21            LD      (LSTRAM),HL     ; Set new top of RAM
1406   0AF8 E1                  POP     HL              ; Restore code string address
1407   0AF9 C3 89 06            JP      INTVAR          ; Initialise variables
1408   0AFC             
1409   0AFC CA 85 06    RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1410   0AFF CD 89 06            CALL    INTVAR          ; Initialise variables
1411   0B02 01 85 09            LD      BC,RUNCNT       ; Execution driver loop
1412   0B05 C3 18 0B            JP      RUNLIN          ; RUN from line number
1413   0B08             
1414   0B08 0E 03       GOSUB:  LD      C,3             ; 3 Levels of stack needed
1415   0B0A CD 4A 05            CALL    CHKSTK          ; Check for 3 levels of stack
1416   0B0D C1                  POP     BC              ; Get return address
1417   0B0E E5                  PUSH    HL              ; Save code string for RETURN
1418   0B0F E5                  PUSH    HL              ; And for GOSUB routine
1419   0B10 2A 7C 21            LD      HL,(LINEAT)     ; Get current line
1420   0B13 E3                  EX      (SP),HL         ; Into stack - Code string out
1421   0B14 3E 8C               LD      A,ZGOSUB        ; "GOSUB" token
1422   0B16 F5                  PUSH    AF              ; Save token
1423   0B17 33                  INC     SP              ; Don't save flags
1424   0B18             
1425   0B18 C5          RUNLIN: PUSH    BC              ; Save return address
1426   0B19 CD 91 0A    GOTO:   CALL    ATOH            ; ASCII number to DE binary
1427   0B1C CD 5E 0B            CALL    REM             ; Get end of line
1428   0B1F E5                  PUSH    HL              ; Save end of line
1429   0B20 2A 7C 21            LD      HL,(LINEAT)     ; Get current line
1430   0B23 CD 35 08            CALL    CPDEHL          ; Line after current?
1431   0B26 E1                  POP     HL              ; Restore end of line
1432   0B27 23                  INC     HL              ; Start of next line
1433   0B28 DC 5C 06            CALL    C,SRCHLP        ; Line is after current line
1434   0B2B D4 59 06            CALL    NC,SRCHLN       ; Line is before current line
1435   0B2E 60                  LD      H,B             ; Set up code string address
1436   0B2F 69                  LD      L,C
1437   0B30 2B                  DEC     HL              ; Incremented after
1438   0B31 D8                  RET     C               ; Line found
1439   0B32 1E 0E       ULERR:  LD      E,UL            ; ?UL Error
1440   0B34 C3 81 05            JP      ERROR           ; Output error message
1441   0B37             
1442   0B37 C0          RETURN: RET     NZ              ; Return if not just RETURN
1443   0B38 16 FF               LD      D,-1            ; Flag "GOSUB" search
1444   0B3A CD 16 05            CALL    BAKSTK          ; Look "GOSUB" block
1445   0B3D F9                  LD      SP,HL           ; Kill all FORs in subroutine
1446   0B3E FE 8C               CP      ZGOSUB          ; Test for "GOSUB" token
1447   0B40 1E 04               LD      E,RG            ; ?RG Error
1448   0B42 C2 81 05            JP      NZ,ERROR        ; Error if no "GOSUB" found
1449   0B45 E1                  POP     HL              ; Get RETURN line number
1450   0B46 22 7C 21            LD      (LINEAT),HL     ; Save as current
1451   0B49 23                  INC     HL              ; Was it from direct statement?
1452   0B4A 7C                  LD      A,H
1453   0B4B B5                  OR      L               ; Return to line
1454   0B4C C2 56 0B            JP      NZ,RETLIN       ; No - Return to line
1455   0B4F 3A EC 21            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1456   0B52 B7                  OR      A               ; If so buffer is corrupted
1457   0B53 C2 B7 05            JP      NZ,POPNOK       ; Yes - Go to command mode
1458   0B56 21 85 09    RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1459   0B59 E3                  EX      (SP),HL         ; Into stack - Code string out
1460   0B5A 3E                  .BYTE      3EH             ; Skip "POP HL"
1461   0B5B E1          NXTDTA: POP     HL              ; Restore code string address
1462   0B5C             
1463   0B5C 01 3A       DATA:   .BYTE      01H,3AH         ; ':' End of statement
1464   0B5E 0E 00       REM:    LD      C,0             ; 00  End of statement
1465   0B60 06 00               LD      B,0
1466   0B62 79          NXTSTL: LD      A,C             ; Statement and byte
1467   0B63 48                  LD      C,B
1468   0B64 47                  LD      B,A             ; Statement end byte
1469   0B65 7E          NXTSTT: LD      A,(HL)          ; Get byte
1470   0B66 B7                  OR      A               ; End of line?
1471   0B67 C8                  RET     Z               ; Yes - Exit
1472   0B68 B8                  CP      B               ; End of statement?
1473   0B69 C8                  RET     Z               ; Yes - Exit
1474   0B6A 23                  INC     HL              ; Next byte
1475   0B6B FE 22               CP      '"'             ; Literal string?
1476   0B6D CA 62 0B            JP      Z,NXTSTL        ; Yes - Look for another '"'
1477   0B70 C3 65 0B            JP      NXTSTT          ; Keep looking
1478   0B73             
1479   0B73 CD 28 10    LET:    CALL    GETVAR          ; Get variable name
1480   0B76 CD 3B 08            CALL    CHKSYN          ; Make sure "=" follows
1481   0B79 B4                  .BYTE      ZEQUAL          ; "=" token
1482   0B7A D5                  PUSH    DE              ; Save address of variable
1483   0B7B 3A CD 21            LD      A,(TYPE)        ; Get data type
1484   0B7E F5                  PUSH    AF              ; Save type
1485   0B7F CD 44 0E            CALL    EVAL            ; Evaluate expression
1486   0B82 F1                  POP     AF              ; Restore type
1487   0B83 E3                  EX      (SP),HL         ; Save code - Get var addr
1488   0B84 22 EE 21            LD      (BRKLIN),HL     ; Save address of variable
1489   0B87 1F                  RRA                     ; Adjust type
1490   0B88 CD 37 0E            CALL    CHKTYP          ; Check types are the same
1491   0B8B CA C6 0B            JP      Z,LETNUM        ; Numeric - Move value
1492   0B8E E5          LETSTR: PUSH    HL              ; Save address of string var
1493   0B8F 2A 04 22            LD      HL,(FPREG)      ; Pointer to string entry
1494   0B92 E5                  PUSH    HL              ; Save it on stack
1495   0B93 23                  INC     HL              ; Skip over length
1496   0B94 23                  INC     HL
1497   0B95 5E                  LD      E,(HL)          ; LSB of string address
1498   0B96 23                  INC     HL
1499   0B97 56                  LD      D,(HL)          ; MSB of string address
1500   0B98 2A 7E 21            LD      HL,(BASTXT)     ; Point to start of program
1501   0B9B CD 35 08            CALL    CPDEHL          ; Is string before program?
1502   0B9E D2 B5 0B            JP      NC,CRESTR       ; Yes - Create string entry
1503   0BA1 2A 7A 21            LD      HL,(STRSPC)     ; Point to string space
1504   0BA4 CD 35 08            CALL    CPDEHL          ; Is string literal in program?
1505   0BA7 D1                  POP     DE              ; Restore address of string
1506   0BA8 D2 BD 0B            JP      NC,MVSTPT       ; Yes - Set up pointer
1507   0BAB 21 DF 21            LD      HL,TMPSTR       ; Temporary string pool
1508   0BAE CD 35 08            CALL    CPDEHL          ; Is string in temporary pool?
1509   0BB1 D2 BD 0B            JP      NC,MVSTPT       ; No - Set up pointer
1510   0BB4 3E                  .BYTE   3EH             ; Skip "POP DE"
1511   0BB5 D1          CRESTR: POP     DE              ; Restore address of string
1512   0BB6 CD 6C 14            CALL    BAKTMP          ; Back to last tmp-str entry
1513   0BB9 EB                  EX      DE,HL           ; Address of string entry
1514   0BBA CD A5 12            CALL    SAVSTR          ; Save string in string area
1515   0BBD CD 6C 14    MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1516   0BC0 E1                  POP     HL              ; Get string pointer
1517   0BC1 CD 6F 18            CALL    DETHL4          ; Move string pointer to var
1518   0BC4 E1                  POP     HL              ; Restore code string address
1519   0BC5 C9                  RET
1520   0BC6             
1521   0BC6 E5          LETNUM: PUSH    HL              ; Save address of variable
1522   0BC7 CD 6C 18            CALL    FPTHL           ; Move value to variable
1523   0BCA D1                  POP     DE              ; Restore address of variable
1524   0BCB E1                  POP     HL              ; Restore code string address
1525   0BCC C9                  RET
1526   0BCD             
1527   0BCD CD 93 15    ON:     CALL    GETINT          ; Get integer 0-255
1528   0BD0 7E                  LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1529   0BD1 47                  LD      B,A             ; Save in B
1530   0BD2 FE 8C               CP      ZGOSUB          ; "GOSUB" token?
1531   0BD4 CA DC 0B            JP      Z,ONGO          ; Yes - Find line number
1532   0BD7 CD 3B 08            CALL    CHKSYN          ; Make sure it's "GOTO"
1533   0BDA 88                  .BYTE   ZGOTO           ; "GOTO" token
1534   0BDB 2B                  DEC     HL              ; Cancel increment
1535   0BDC 4B          ONGO:   LD      C,E             ; Integer of branch value
1536   0BDD 0D          ONGOLP: DEC     C               ; Count branches
1537   0BDE 78                  LD      A,B             ; Get "GOTO" or "GOSUB" token
1538   0BDF CA AD 09            JP      Z,ONJMP         ; Go to that line if right one
1539   0BE2 CD 92 0A            CALL    GETLN           ; Get line number to DE
1540   0BE5 FE 2C               CP      ','             ; Another line number?
1541   0BE7 C0                  RET     NZ              ; No - Drop through
1542   0BE8 C3 DD 0B            JP      ONGOLP          ; Yes - loop
1543   0BEB             
1544   0BEB CD 44 0E    IF:     CALL    EVAL            ; Evaluate expression
1545   0BEE 7E                  LD      A,(HL)          ; Get token
1546   0BEF FE 88               CP      ZGOTO           ; "GOTO" token?
1547   0BF1 CA F9 0B            JP      Z,IFGO          ; Yes - Get line
1548   0BF4 CD 3B 08            CALL    CHKSYN          ; Make sure it's "THEN"
1549   0BF7 A9                  .BYTE      ZTHEN           ; "THEN" token
1550   0BF8 2B                  DEC     HL              ; Cancel increment
1551   0BF9 CD 35 0E    IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1552   0BFC CD 14 18            CALL    TSTSGN          ; Test state of expression
1553   0BFF CA 5E 0B            JP      Z,REM           ; False - Drop through
1554   0C02 CD C5 09            CALL    GETCHR          ; Get next character
1555   0C05 DA 19 0B            JP      C,GOTO          ; Number - GOTO that line
1556   0C08 C3 AC 09            JP      IFJMP           ; Otherwise do statement
1557   0C0B             
1558   0C0B 2B          MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1559   0C0C CD C5 09            CALL    GETCHR          ; Get next character
1560   0C0F CA 6D 0C    PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1561   0C12 C8          PRNTLP: RET     Z               ; End of list - Exit
1562   0C13 FE A5               CP      ZTAB            ; "TAB(" token?
1563   0C15 CA A0 0C            JP      Z,DOTAB         ; Yes - Do TAB routine
1564   0C18 FE A8               CP      ZSPC            ; "SPC(" token?
1565   0C1A CA A0 0C            JP      Z,DOTAB         ; Yes - Do SPC routine
1566   0C1D E5                  PUSH    HL              ; Save code string address
1567   0C1E FE 2C               CP      ','             ; Comma?
1568   0C20 CA 89 0C            JP      Z,DOCOM         ; Yes - Move to next zone
1569   0C23 FE 3B               CP      59 ;";"         ; Semi-colon?
1570   0C25 CA C3 0C            JP      Z,NEXITM        ; Do semi-colon routine
1571   0C28 C1                  POP     BC              ; Code string address to BC
1572   0C29 CD 44 0E            CALL    EVAL            ; Evaluate expression
1573   0C2C E5                  PUSH    HL              ; Save code string address
1574   0C2D 3A CD 21            LD      A,(TYPE)        ; Get variable type
1575   0C30 B7                  OR      A               ; Is it a string variable?
1576   0C31 C2 59 0C            JP      NZ,PRNTST       ; Yes - Output string contents
1577   0C34 CD B9 19            CALL    NUMASC          ; Convert number to text
1578   0C37 CD C9 12            CALL    CRTST           ; Create temporary string
1579   0C3A 36 20               LD      (HL),' '        ; Followed by a space
1580   0C3C 2A 04 22            LD      HL,(FPREG)      ; Get length of output
1581   0C3F 34                  INC     (HL)            ; Plus 1 for the space
1582   0C40 2A 04 22            LD      HL,(FPREG)      ; < Not needed >
1583   0C43 3A 62 21            LD      A,(LWIDTH)      ; Get width of line
1584   0C46 47                  LD      B,A             ; To B
1585   0C47 04                  INC     B               ; Width 255 (No limit)?
1586   0C48 CA 55 0C            JP      Z,PRNTNB        ; Yes - Output number string
1587   0C4B 04                  INC     B               ; Adjust it
1588   0C4C 3A CB 21            LD      A,(CURPOS)      ; Get cursor position
1589   0C4F 86                  ADD     A,(HL)          ; Add length of string
1590   0C50 3D                  DEC     A               ; Adjust it
1591   0C51 B8                  CP      B               ; Will output fit on this line?
1592   0C52 D4 6D 0C            CALL    NC,PRNTCRLF     ; No - CRLF first
1593   0C55 CD 0E 13    PRNTNB: CALL    PRS1            ; Output string at (HL)
1594   0C58 AF                  XOR     A               ; Skip CALL by setting 'z' flag
1595   0C59 C4 0E 13    PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1596   0C5C E1                  POP     HL              ; Restore code string address
1597   0C5D C3 0B 0C            JP      MRPRNT          ; See if more to PRINT
1598   0C60             
1599   0C60 3A CB 21    STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1600   0C63 B7                  OR      A               ; Already at start?
1601   0C64 C8                  RET     Z               ; Yes - Do nothing
1602   0C65 C3 6D 0C            JP      PRNTCRLF        ; Start a new line
1603   0C68             
1604   0C68 36 00       ENDINP: LD      (HL),0          ; Mark end of buffer
1605   0C6A 21 80 21            LD      HL,BUFFER-1     ; Point to buffer
1606   0C6D 3E 0D       PRNTCRLF: LD    A,CR            ; Load a CR
1607   0C6F CD 46 08            CALL    OUTC            ; Output character
1608   0C72 3E 0A               LD      A,LF            ; Load a LF
1609   0C74 CD 46 08            CALL    OUTC            ; Output character
1610   0C77 AF          DONULL: XOR     A               ; Set to position 0
1611   0C78 32 CB 21            LD      (CURPOS),A      ; Store it
1612   0C7B 3A 61 21            LD      A,(NULLS)       ; Get number of nulls
1613   0C7E 3D          NULLP:  DEC     A               ; Count them
1614   0C7F C8                  RET     Z               ; Return if done
1615   0C80 F5                  PUSH    AF              ; Save count
1616   0C81 AF                  XOR     A               ; Load a null
1617   0C82 CD 46 08            CALL    OUTC            ; Output it
1618   0C85 F1                  POP     AF              ; Restore count
1619   0C86 C3 7E 0C            JP      NULLP           ; Keep counting
1620   0C89             
1621   0C89 3A 63 21    DOCOM:  LD      A,(COMMAN)      ; Get comma width
1622   0C8C 47                  LD      B,A             ; Save in B
1623   0C8D 3A CB 21            LD      A,(CURPOS)      ; Get current position
1624   0C90 B8                  CP      B               ; Within the limit?
1625   0C91 D4 6D 0C            CALL    NC,PRNTCRLF     ; No - output CRLF
1626   0C94 D2 C3 0C            JP      NC,NEXITM       ; Get next item
1627   0C97 D6 0E       ZONELP: SUB     14              ; Next zone of 14 characters
1628   0C99 D2 97 0C            JP      NC,ZONELP       ; Repeat if more zones
1629   0C9C 2F                  CPL                     ; Number of spaces to output
1630   0C9D C3 B8 0C            JP      ASPCS           ; Output them
1631   0CA0             
1632   0CA0 F5          DOTAB:  PUSH    AF              ; Save token
1633   0CA1 CD 90 15            CALL    FNDNUM          ; Evaluate expression
1634   0CA4 CD 3B 08            CALL    CHKSYN          ; Make sure ")" follows
1635   0CA7 29                  .BYTE   ")"
1636   0CA8 2B                  DEC     HL              ; Back space on to ")"
1637   0CA9 F1                  POP     AF              ; Restore token
1638   0CAA D6 A8               SUB     ZSPC            ; Was it "SPC(" ?
1639   0CAC E5                  PUSH    HL              ; Save code string address
1640   0CAD CA B3 0C            JP      Z,DOSPC         ; Yes - Do 'E' spaces
1641   0CB0 3A CB 21            LD      A,(CURPOS)      ; Get current position
1642   0CB3 2F          DOSPC:  CPL                     ; Number of spaces to print to
1643   0CB4 83                  ADD     A,E             ; Total number to print
1644   0CB5 D2 C3 0C            JP      NC,NEXITM       ; TAB < Current POS(X)
1645   0CB8 3C          ASPCS:  INC     A               ; Output A spaces
1646   0CB9 47                  LD      B,A             ; Save number to print
1647   0CBA 3E 20               LD      A,' '           ; Space
1648   0CBC CD 46 08    SPCLP:  CALL    OUTC            ; Output character in A
1649   0CBF 05                  DEC     B               ; Count them
1650   0CC0 C2 BC 0C            JP      NZ,SPCLP        ; Repeat if more
1651   0CC3 E1          NEXITM: POP     HL              ; Restore code string address
1652   0CC4 CD C5 09            CALL    GETCHR          ; Get next character
1653   0CC7 C3 12 0C            JP      PRNTLP          ; More to print
1654   0CCA             
1655   0CCA 3F5265646F20REDO:   .BYTE   "?Redo from start",CR,LF,0
1655   0CD0 66726F6D2073746172740D0A00
1656   0CDD             
1657   0CDD 3A ED 21    BADINP: LD      A,(READFG)      ; READ or INPUT?
1658   0CE0 B7                  OR      A
1659   0CE1 C2 67 05            JP      NZ,DATSNR       ; READ - ?SN Error
1660   0CE4 C1                  POP     BC              ; Throw away code string addr
1661   0CE5 21 CA 0C            LD      HL,REDO         ; "Redo from start" message
1662   0CE8 CD 0B 13            CALL    PRS             ; Output string
1663   0CEB C3 B8 06            JP      DOAGN           ; Do last INPUT again
1664   0CEE             
1665   0CEE CD 76 12    INPUT:  CALL    IDTEST          ; Test for illegal direct
1666   0CF1 7E                  LD      A,(HL)          ; Get character after "INPUT"
1667   0CF2 FE 22               CP      '"'             ; Is there a prompt string?
1668   0CF4 3E 00               LD      A,0             ; Clear A and leave flags
1669   0CF6 32 65 21            LD      (CTLOFG),A      ; Enable output
1670   0CF9 C2 08 0D            JP      NZ,NOPMPT       ; No prompt - get input
1671   0CFC CD CA 12            CALL    QTSTR           ; Get string terminated by '"'
1672   0CFF CD 3B 08            CALL    CHKSYN          ; Check for ';' after prompt
1673   0D02 3B                  .BYTE   ';'
1674   0D03 E5                  PUSH    HL              ; Save code string address
1675   0D04 CD 0E 13            CALL    PRS1            ; Output prompt string
1676   0D07 3E                  .BYTE   3EH             ; Skip "PUSH HL"
1677   0D08 E5          NOPMPT: PUSH    HL              ; Save code string address
1678   0D09 CD BC 06            CALL    PROMPT          ; Get input with "? " prompt
1679   0D0C C1                  POP     BC              ; Restore code string address
1680   0D0D DA 14 0A            JP      C,INPBRK        ; Break pressed - Exit
1681   0D10 23                  INC     HL              ; Next byte
1682   0D11 7E                  LD      A,(HL)          ; Get it
1683   0D12 B7                  OR      A               ; End of line?
1684   0D13 2B                  DEC     HL              ; Back again
1685   0D14 C5                  PUSH    BC              ; Re-save code string address
1686   0D15 CA 5B 0B            JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1687   0D18 36 2C               LD      (HL),','        ; Store comma as separator
1688   0D1A C3 22 0D            JP      NXTITM          ; Get next item
1689   0D1D             
1690   0D1D E5          READ:   PUSH    HL              ; Save code string address
1691   0D1E 2A FC 21            LD      HL,(NXTDAT)     ; Next DATA statement
1692   0D21 F6                  .BYTE   0F6H            ; Flag "READ"
1693   0D22 AF          NXTITM: XOR     A               ; Flag "INPUT"
1694   0D23 32 ED 21            LD      (READFG),A      ; Save "READ"/"INPUT" flag
1695   0D26 E3                  EX      (SP),HL         ; Get code str' , Save pointer
1696   0D27 C3 2E 0D            JP      GTVLUS          ; Get values
1697   0D2A             
1698   0D2A CD 3B 08    NEDMOR: CALL    CHKSYN          ; Check for comma between items
1699   0D2D 2C                  .BYTE      ','
1700   0D2E CD 28 10    GTVLUS: CALL    GETVAR          ; Get variable name
1701   0D31 E3                  EX      (SP),HL         ; Save code str" , Get pointer
1702   0D32 D5                  PUSH    DE              ; Save variable address
1703   0D33 7E                  LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1704   0D34 FE 2C               CP      ','             ; Comma?
1705   0D36 CA 56 0D            JP      Z,ANTVLU        ; Yes - Get another value
1706   0D39 3A ED 21            LD      A,(READFG)      ; Is it READ?
1707   0D3C B7                  OR      A
1708   0D3D C2 C3 0D            JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1709   0D40 3E 3F               LD      A,'?'           ; More INPUT needed
1710   0D42 CD 46 08            CALL    OUTC            ; Output character
1711   0D45 CD BC 06            CALL    PROMPT          ; Get INPUT with prompt
1712   0D48 D1                  POP     DE              ; Variable address
1713   0D49 C1                  POP     BC              ; Code string address
1714   0D4A DA 14 0A            JP      C,INPBRK        ; Break pressed
1715   0D4D 23                  INC     HL              ; Point to next DATA byte
1716   0D4E 7E                  LD      A,(HL)          ; Get byte
1717   0D4F B7                  OR      A               ; Is it zero (No input) ?
1718   0D50 2B                  DEC     HL              ; Back space INPUT pointer
1719   0D51 C5                  PUSH    BC              ; Save code string address
1720   0D52 CA 5B 0B            JP      Z,NXTDTA        ; Find end of buffer
1721   0D55 D5                  PUSH    DE              ; Save variable address
1722   0D56 3A CD 21    ANTVLU: LD      A,(TYPE)        ; Check data type
1723   0D59 B7                  OR      A               ; Is it numeric?
1724   0D5A CA 80 0D            JP      Z,INPBIN        ; Yes - Convert to binary
1725   0D5D CD C5 09            CALL    GETCHR          ; Get next character
1726   0D60 57                  LD      D,A             ; Save input character
1727   0D61 47                  LD      B,A             ; Again
1728   0D62 FE 22               CP      '"'             ; Start of literal sting?
1729   0D64 CA 74 0D            JP      Z,STRENT        ; Yes - Create string entry
1730   0D67 3A ED 21            LD      A,(READFG)      ; "READ" or "INPUT" ?
1731   0D6A B7                  OR      A
1732   0D6B 57                  LD      D,A             ; Save 00 if "INPUT"
1733   0D6C CA 71 0D            JP      Z,ITMSEP        ; "INPUT" - End with 00
1734   0D6F 16 3A               LD      D,':'           ; "DATA" - End with 00 or ':'
1735   0D71 06 2C       ITMSEP: LD      B,','           ; Item separator
1736   0D73 2B                  DEC     HL              ; Back space for DTSTR
1737   0D74 CD CD 12    STRENT: CALL    DTSTR           ; Get string terminated by D
1738   0D77 EB                  EX      DE,HL           ; String address to DE
1739   0D78 21 8B 0D            LD      HL,LTSTND       ; Where to go after LETSTR
1740   0D7B E3                  EX      (SP),HL         ; Save HL , get input pointer
1741   0D7C D5                  PUSH    DE              ; Save address of string
1742   0D7D C3 8E 0B            JP      LETSTR          ; Assign string to variable
1743   0D80             
1744   0D80 CD C5 09    INPBIN: CALL    GETCHR          ; Get next character
1745   0D83 CD 1B 19            CALL    ASCTFP          ; Convert ASCII to FP number
1746   0D86 E3                  EX      (SP),HL         ; Save input ptr, Get var addr
1747   0D87 CD 6C 18            CALL    FPTHL           ; Move FPREG to variable
1748   0D8A E1                  POP     HL              ; Restore input pointer
1749   0D8B 2B          LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1750   0D8C CD C5 09            CALL    GETCHR          ; Get next character
1751   0D8F CA 97 0D            JP      Z,MORDT         ; End of line - More needed?
1752   0D92 FE 2C               CP      ','             ; Another value?
1753   0D94 C2 DD 0C            JP      NZ,BADINP       ; No - Bad input
1754   0D97 E3          MORDT:  EX      (SP),HL         ; Get code string address
1755   0D98 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
1756   0D99 CD C5 09            CALL    GETCHR          ; Get next character
1757   0D9C C2 2A 0D            JP      NZ,NEDMOR       ; More needed - Get it
1758   0D9F D1                  POP     DE              ; Restore DATA pointer
1759   0DA0 3A ED 21            LD      A,(READFG)      ; "READ" or "INPUT" ?
1760   0DA3 B7                  OR      A
1761   0DA4 EB                  EX      DE,HL           ; DATA pointer to HL
1762   0DA5 C2 EB 09            JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1763   0DA8 D5                  PUSH    DE              ; Save code string address
1764   0DA9 B6                  OR      (HL)            ; More input given?
1765   0DAA 21 B2 0D            LD      HL,EXTIG        ; "?Extra ignored" message
1766   0DAD C4 0B 13            CALL    NZ,PRS          ; Output string if extra given
1767   0DB0 E1                  POP     HL              ; Restore code string address
1768   0DB1 C9                  RET
1769   0DB2             
1770   0DB2 3F4578747261EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
1770   0DB8 2069676E6F7265640D0A00
1771   0DC3             
1772   0DC3 CD 5C 0B    FDTLP:  CALL    DATA            ; Get next statement
1773   0DC6 B7                  OR      A               ; End of line?
1774   0DC7 C2 DC 0D            JP      NZ,FANDT        ; No - See if DATA statement
1775   0DCA 23                  INC     HL
1776   0DCB 7E                  LD      A,(HL)          ; End of program?
1777   0DCC 23                  INC     HL
1778   0DCD B6                  OR      (HL)            ; 00 00 Ends program
1779   0DCE 1E 06               LD      E,OD            ; ?OD Error
1780   0DD0 CA 81 05            JP      Z,ERROR         ; Yes - Out of DATA
1781   0DD3 23                  INC     HL
1782   0DD4 5E                  LD      E,(HL)          ; LSB of line number
1783   0DD5 23                  INC     HL
1784   0DD6 56                  LD      D,(HL)          ; MSB of line number
1785   0DD7 EB                  EX      DE,HL
1786   0DD8 22 E9 21            LD      (DATLIN),HL     ; Set line of current DATA item
1787   0DDB EB                  EX      DE,HL
1788   0DDC CD C5 09    FANDT:  CALL    GETCHR          ; Get next character
1789   0DDF FE 83               CP      ZDATA           ; "DATA" token
1790   0DE1 C2 C3 0D            JP      NZ,FDTLP        ; No "DATA" - Keep looking
1791   0DE4 C3 56 0D            JP      ANTVLU          ; Found - Convert input
1792   0DE7             
1793   0DE7 11 00 00    NEXT:   LD      DE,0            ; In case no index given
1794   0DEA C4 28 10    NEXT1:  CALL    NZ,GETVAR       ; Get index address
1795   0DED 22 EE 21            LD      (BRKLIN),HL     ; Save code string address
1796   0DF0 CD 16 05            CALL    BAKSTK          ; Look for "FOR" block
1797   0DF3 C2 73 05            JP      NZ,NFERR        ; No "FOR" - ?NF Error
1798   0DF6 F9                  LD      SP,HL           ; Clear nested loops
1799   0DF7 D5                  PUSH    DE              ; Save index address
1800   0DF8 7E                  LD      A,(HL)          ; Get sign of STEP
1801   0DF9 23                  INC     HL
1802   0DFA F5                  PUSH    AF              ; Save sign of STEP
1803   0DFB D5                  PUSH    DE              ; Save index address
1804   0DFC CD 52 18            CALL    PHLTFP          ; Move index value to FPREG
1805   0DFF E3                  EX      (SP),HL         ; Save address of TO value
1806   0E00 E5                  PUSH    HL              ; Save address of index
1807   0E01 CD BF 15            CALL    ADDPHL          ; Add STEP to index value
1808   0E04 E1                  POP     HL              ; Restore address of index
1809   0E05 CD 6C 18            CALL    FPTHL           ; Move value to index variable
1810   0E08 E1                  POP     HL              ; Restore address of TO value
1811   0E09 CD 63 18            CALL    LOADFP          ; Move TO value to BCDE
1812   0E0C E5                  PUSH    HL              ; Save address of line of FOR
1813   0E0D CD 8F 18            CALL    CMPNUM          ; Compare index with TO value
1814   0E10 E1                  POP     HL              ; Restore address of line num
1815   0E11 C1                  POP     BC              ; Address of sign of STEP
1816   0E12 90                  SUB     B               ; Compare with expected sign
1817   0E13 CD 63 18            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1818   0E16 CA 22 0E            JP      Z,KILFOR        ; Loop finished - Terminate it
1819   0E19 EB                  EX      DE,HL           ; Loop statement line number
1820   0E1A 22 7C 21            LD      (LINEAT),HL     ; Set loop line number
1821   0E1D 69                  LD      L,C             ; Set code string to loop
1822   0E1E 60                  LD      H,B
1823   0E1F C3 81 09            JP      PUTFID          ; Put back "FOR" and continue
1824   0E22             
1825   0E22 F9          KILFOR: LD      SP,HL           ; Remove "FOR" block
1826   0E23 2A EE 21            LD      HL,(BRKLIN)     ; Code string after "NEXT"
1827   0E26 7E                  LD      A,(HL)          ; Get next byte in code string
1828   0E27 FE 2C               CP      ','             ; More NEXTs ?
1829   0E29 C2 85 09            JP      NZ,RUNCNT       ; No - Do next statement
1830   0E2C CD C5 09            CALL    GETCHR          ; Position to index name
1831   0E2F CD EA 0D            CALL    NEXT1           ; Re-enter NEXT routine
1832   0E32             ; < will not RETurn to here , Exit to RUNCNT or Loop >
1833   0E32             
1834   0E32 CD 44 0E    GETNUM: CALL    EVAL            ; Get a numeric expression
1835   0E35 F6          TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
1836   0E36 37          TSTSTR: SCF                     ; Set carry (string)
1837   0E37 3A CD 21    CHKTYP: LD      A,(TYPE)        ; Check types match
1838   0E3A 8F                  ADC     A,A             ; Expected + actual
1839   0E3B B7                  OR      A               ; Clear carry , set parity
1840   0E3C E8                  RET     PE              ; Even parity - Types match
1841   0E3D C3 7F 05            JP      TMERR           ; Different types - Error
1842   0E40             
1843   0E40 CD 3B 08    OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1844   0E43 28                  .BYTE   "("
1845   0E44 2B          EVAL:   DEC     HL              ; Evaluate expression & save
1846   0E45 16 00               LD      D,0             ; Precedence value
1847   0E47 D5          EVAL1:  PUSH    DE              ; Save precedence
1848   0E48 0E 01               LD      C,1
1849   0E4A CD 4A 05            CALL    CHKSTK          ; Check for 1 level of stack
1850   0E4D CD BB 0E            CALL    OPRND           ; Get next expression value
1851   0E50 22 F0 21    EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1852   0E53 2A F0 21    EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1853   0E56 C1                  POP     BC              ; Precedence value and operator
1854   0E57 78                  LD      A,B             ; Get precedence value
1855   0E58 FE 78               CP      78H             ; "AND" or "OR" ?
1856   0E5A D4 35 0E            CALL    NC,TSTNUM       ; No - Make sure it's a number
1857   0E5D 7E                  LD      A,(HL)          ; Get next operator / function
1858   0E5E 16 00               LD      D,0             ; Clear Last relation
1859   0E60 D6 B3       RLTLP:  SUB     ZGTR            ; ">" Token
1860   0E62 DA 7C 0E            JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1861   0E65 FE 03               CP      ZLTH+1-ZGTR     ; < = >
1862   0E67 D2 7C 0E            JP      NC,FOPRND       ; Function - Call it
1863   0E6A FE 01               CP      ZEQUAL-ZGTR     ; "="
1864   0E6C 17                  RLA                     ; <- Test for legal
1865   0E6D AA                  XOR     D               ; <- combinations of < = >
1866   0E6E BA                  CP      D               ; <- by combining last token
1867   0E6F 57                  LD      D,A             ; <- with current one
1868   0E70 DA 6D 05            JP      C,SNERR         ; Error if "<<' '==" or ">>"
1869   0E73 22 E5 21            LD      (CUROPR),HL     ; Save address of current token
1870   0E76 CD C5 09            CALL    GETCHR          ; Get next character
1871   0E79 C3 60 0E            JP      RLTLP           ; Treat the two as one
1872   0E7C             
1873   0E7C 7A          FOPRND: LD      A,D             ; < = > found ?
1874   0E7D B7                  OR      A
1875   0E7E C2 A3 0F            JP      NZ,TSTRED       ; Yes - Test for reduction
1876   0E81 7E                  LD      A,(HL)          ; Get operator token
1877   0E82 22 E5 21            LD      (CUROPR),HL     ; Save operator address
1878   0E85 D6 AC               SUB     ZPLUS           ; Operator or function?
1879   0E87 D8                  RET     C               ; Neither - Exit
1880   0E88 FE 07               CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1881   0E8A D0                  RET     NC              ; No - Exit
1882   0E8B 5F                  LD      E,A             ; Coded operator
1883   0E8C 3A CD 21            LD      A,(TYPE)        ; Get data type
1884   0E8F 3D                  DEC     A               ; FF = numeric , 00 = string
1885   0E90 B3                  OR      E               ; Combine with coded operator
1886   0E91 7B                  LD      A,E             ; Get coded operator
1887   0E92 CA 01 14            JP      Z,CONCAT        ; String concatenation
1888   0E95 07                  RLCA                    ; Times 2
1889   0E96 83                  ADD     A,E             ; Times 3
1890   0E97 5F                  LD      E,A             ; To DE (D is 0)
1891   0E98 21 5F 04            LD      HL,PRITAB       ; Precedence table
1892   0E9B 19                  ADD     HL,DE           ; To the operator concerned
1893   0E9C 78                  LD      A,B             ; Last operator precedence
1894   0E9D 56                  LD      D,(HL)          ; Get evaluation precedence
1895   0E9E BA                  CP      D               ; Compare with eval precedence
1896   0E9F D0                  RET     NC              ; Exit if higher precedence
1897   0EA0 23                  INC     HL              ; Point to routine address
1898   0EA1 CD 35 0E            CALL    TSTNUM          ; Make sure it's a number
1899   0EA4             
1900   0EA4 C5          STKTHS: PUSH    BC              ; Save last precedence & token
1901   0EA5 01 53 0E            LD      BC,EVAL3        ; Where to go on prec' break
1902   0EA8 C5                  PUSH    BC              ; Save on stack for return
1903   0EA9 43                  LD      B,E             ; Save operator
1904   0EAA 4A                  LD      C,D             ; Save precedence
1905   0EAB CD 45 18            CALL    STAKFP          ; Move value to stack
1906   0EAE 58                  LD      E,B             ; Restore operator
1907   0EAF 51                  LD      D,C             ; Restore precedence
1908   0EB0 4E                  LD      C,(HL)          ; Get LSB of routine address
1909   0EB1 23                  INC     HL
1910   0EB2 46                  LD      B,(HL)          ; Get MSB of routine address
1911   0EB3 23                  INC     HL
1912   0EB4 C5                  PUSH    BC              ; Save routine address
1913   0EB5 2A E5 21            LD      HL,(CUROPR)     ; Address of current operator
1914   0EB8 C3 47 0E            JP      EVAL1           ; Loop until prec' break
1915   0EBB             
1916   0EBB AF          OPRND:  XOR     A               ; Get operand routine
1917   0EBC 32 CD 21            LD      (TYPE),A        ; Set numeric expected
1918   0EBF CD C5 09            CALL    GETCHR          ; Get next character
1919   0EC2 1E 24               LD      E,MO            ; ?MO Error
1920   0EC4 CA 81 05            JP      Z,ERROR         ; No operand - Error
1921   0EC7 DA 1B 19            JP      C,ASCTFP        ; Number - Get value
1922   0ECA CD 63 0A            CALL    CHKLTR          ; See if a letter
1923   0ECD D2 22 0F            JP      NC,CONVAR       ; Letter - Find variable
1924   0ED0 FE 26               CP	'&'		; &H = HEX, &B = BINARY
1925   0ED2 20 12               JR	NZ, NOTAMP
1926   0ED4 CD C5 09            CALL    GETCHR          ; Get next character
1927   0ED7 FE 48               CP      'H'             ; Hex number indicated? [function added]
1928   0ED9 CA 5F 1D            JP      Z,HEXTFP        ; Convert Hex to FPREG
1929   0EDC FE 42               CP      'B'             ; Binary number indicated? [function added]
1930   0EDE CA CF 1D            JP      Z,BINTFP        ; Convert Bin to FPREG
1931   0EE1 1E 02               LD      E,SN            ; If neither then a ?SN Error
1932   0EE3 CA 81 05            JP      Z,ERROR         ; 
1933   0EE6 FE AC       NOTAMP: CP      ZPLUS           ; '+' Token ?
1934   0EE8 CA BB 0E            JP      Z,OPRND         ; Yes - Look for operand
1935   0EEB FE 2E               CP      '.'             ; '.' ?
1936   0EED CA 1B 19            JP      Z,ASCTFP        ; Yes - Create FP number
1937   0EF0 FE AD               CP      ZMINUS          ; '-' Token ?
1938   0EF2 CA 11 0F            JP      Z,MINUS         ; Yes - Do minus
1939   0EF5 FE 22               CP      '"'             ; Literal string ?
1940   0EF7 CA CA 12            JP      Z,QTSTR         ; Get string terminated by '"'
1941   0EFA FE AA               CP      ZNOT            ; "NOT" Token ?
1942   0EFC CA 03 10            JP      Z,EVNOT         ; Yes - Eval NOT expression
1943   0EFF FE A7               CP      ZFN             ; "FN" Token ?
1944   0F01 CA 2E 12            JP      Z,DOFN          ; Yes - Do FN routine
1945   0F04 D6 B6               SUB     ZSGN            ; Is it a function?
1946   0F06 D2 33 0F            JP      NC,FNOFST       ; Yes - Evaluate function
1947   0F09 CD 40 0E    EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1948   0F0C CD 3B 08            CALL    CHKSYN          ; Make sure ")" follows
1949   0F0F 29                  .BYTE   ")"
1950   0F10 C9                  RET
1951   0F11             
1952   0F11 16 7D       MINUS:  LD      D,7DH           ; '-' precedence
1953   0F13 CD 47 0E            CALL    EVAL1           ; Evaluate until prec' break
1954   0F16 2A F0 21            LD      HL,(NXTOPR)     ; Get next operator address
1955   0F19 E5                  PUSH    HL              ; Save next operator address
1956   0F1A CD 3D 18            CALL    INVSGN          ; Negate value
1957   0F1D CD 35 0E    RETNUM: CALL    TSTNUM          ; Make sure it's a number
1958   0F20 E1                  POP     HL              ; Restore next operator address
1959   0F21 C9                  RET
1960   0F22             
1961   0F22 CD 28 10    CONVAR: CALL    GETVAR          ; Get variable address to DE
1962   0F25 E5          FRMEVL: PUSH    HL              ; Save code string address
1963   0F26 EB                  EX      DE,HL           ; Variable address to HL
1964   0F27 22 04 22            LD      (FPREG),HL      ; Save address of variable
1965   0F2A 3A CD 21            LD      A,(TYPE)        ; Get type
1966   0F2D B7                  OR      A               ; Numeric?
1967   0F2E CC 52 18            CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1968   0F31 E1                  POP     HL              ; Restore code string address
1969   0F32 C9                  RET
1970   0F33             
1971   0F33 06 00       FNOFST: LD      B,0             ; Get address of function
1972   0F35 07                  RLCA                    ; Double function offset
1973   0F36 4F                  LD      C,A             ; BC = Offset in function table
1974   0F37 C5                  PUSH    BC              ; Save adjusted token value
1975   0F38 CD C5 09            CALL    GETCHR          ; Get next character
1976   0F3B 79                  LD      A,C             ; Get adjusted token value
1977   0F3C FE 31               CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1978   0F3E DA 5A 0F            JP      C,FNVAL         ; No - Do function
1979   0F41 CD 40 0E            CALL    OPNPAR          ; Evaluate expression  (X,...
1980   0F44 CD 3B 08            CALL    CHKSYN          ; Make sure ',' follows
1981   0F47 2C                  .BYTE      ','
1982   0F48 CD 36 0E            CALL    TSTSTR          ; Make sure it's a string
1983   0F4B EB                  EX      DE,HL           ; Save code string address
1984   0F4C 2A 04 22            LD      HL,(FPREG)      ; Get address of string
1985   0F4F E3                  EX      (SP),HL         ; Save address of string
1986   0F50 E5                  PUSH    HL              ; Save adjusted token value
1987   0F51 EB                  EX      DE,HL           ; Restore code string address
1988   0F52 CD 93 15            CALL    GETINT          ; Get integer 0-255
1989   0F55 EB                  EX      DE,HL           ; Save code string address
1990   0F56 E3                  EX      (SP),HL         ; Save integer,HL = adj' token
1991   0F57 C3 62 0F            JP      GOFUNC          ; Jump to string function
1992   0F5A             
1993   0F5A CD 09 0F    FNVAL:  CALL    EVLPAR          ; Evaluate expression
1994   0F5D E3                  EX      (SP),HL         ; HL = Adjusted token value
1995   0F5E 11 1D 0F            LD      DE,RETNUM       ; Return number from function
1996   0F61 D5                  PUSH    DE              ; Save on stack
1997   0F62 01 BE 02    GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
1998   0F65 09                  ADD     HL,BC           ; Point to right address
1999   0F66 4E                  LD      C,(HL)          ; Get LSB of address
2000   0F67 23                  INC     HL              ;
2001   0F68 66                  LD      H,(HL)          ; Get MSB of address
2002   0F69 69                  LD      L,C             ; Address to HL
2003   0F6A E9                  JP      (HL)            ; Jump to function
2004   0F6B             
2005   0F6B 15          SGNEXP: DEC     D               ; Dee to flag negative exponent
2006   0F6C FE AD               CP      ZMINUS          ; '-' token ?
2007   0F6E C8                  RET     Z               ; Yes - Return
2008   0F6F FE 2D               CP      '-'             ; '-' ASCII ?
2009   0F71 C8                  RET     Z               ; Yes - Return
2010   0F72 14                  INC     D               ; Inc to flag positive exponent
2011   0F73 FE 2B               CP      '+'             ; '+' ASCII ?
2012   0F75 C8                  RET     Z               ; Yes - Return
2013   0F76 FE AC               CP      ZPLUS           ; '+' token ?
2014   0F78 C8                  RET     Z               ; Yes - Return
2015   0F79 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2016   0F7A C9                  RET                     ; Return "NZ"
2017   0F7B             
2018   0F7B F6          POR:    .BYTE      0F6H            ; Flag "OR"
2019   0F7C AF          PAND:   XOR     A               ; Flag "AND"
2020   0F7D F5                  PUSH    AF              ; Save "AND" / "OR" flag
2021   0F7E CD 35 0E            CALL    TSTNUM          ; Make sure it's a number
2022   0F81 CD 77 0A            CALL    DEINT           ; Get integer -32768 to 32767
2023   0F84 F1                  POP     AF              ; Restore "AND" / "OR" flag
2024   0F85 EB                  EX      DE,HL           ; <- Get last
2025   0F86 C1                  POP     BC              ; <-  value
2026   0F87 E3                  EX      (SP),HL         ; <-  from
2027   0F88 EB                  EX      DE,HL           ; <-  stack
2028   0F89 CD 55 18            CALL    FPBCDE          ; Move last value to FPREG
2029   0F8C F5                  PUSH    AF              ; Save "AND" / "OR" flag
2030   0F8D CD 77 0A            CALL    DEINT           ; Get integer -32768 to 32767
2031   0F90 F1                  POP     AF              ; Restore "AND" / "OR" flag
2032   0F91 C1                  POP     BC              ; Get value
2033   0F92 79                  LD      A,C             ; Get LSB
2034   0F93 21 EC 11            LD      HL,ACPASS       ; Address of save AC as current
2035   0F96 C2 9E 0F            JP      NZ,POR1         ; Jump if OR
2036   0F99 A3                  AND     E               ; "AND" LSBs
2037   0F9A 4F                  LD      C,A             ; Save LSB
2038   0F9B 78                  LD      A,B             ; Get MBS
2039   0F9C A2                  AND     D               ; "AND" MSBs
2040   0F9D E9                  JP      (HL)            ; Save AC as current (ACPASS)
2041   0F9E             
2042   0F9E B3          POR1:   OR      E               ; "OR" LSBs
2043   0F9F 4F                  LD      C,A             ; Save LSB
2044   0FA0 78                  LD      A,B             ; Get MSB
2045   0FA1 B2                  OR      D               ; "OR" MSBs
2046   0FA2 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2047   0FA3             
2048   0FA3 21 B5 0F    TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2049   0FA6 3A CD 21            LD      A,(TYPE)        ; Get data type
2050   0FA9 1F                  RRA                     ; Carry set = string
2051   0FAA 7A                  LD      A,D             ; Get last precedence value
2052   0FAB 17                  RLA                     ; Times 2 plus carry
2053   0FAC 5F                  LD      E,A             ; To E
2054   0FAD 16 64               LD      D,64H           ; Relational precedence
2055   0FAF 78                  LD      A,B             ; Get current precedence
2056   0FB0 BA                  CP      D               ; Compare with last
2057   0FB1 D0                  RET     NC              ; Eval if last was rel' or log'
2058   0FB2 C3 A4 0E            JP      STKTHS          ; Stack this one and get next
2059   0FB5             
2060   0FB5 B7 0F       CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2061   0FB7 79          CMPLG1: LD      A,C             ; Get data type
2062   0FB8 B7                  OR      A
2063   0FB9 1F                  RRA
2064   0FBA C1                  POP     BC              ; Get last expression to BCDE
2065   0FBB D1                  POP     DE
2066   0FBC F5                  PUSH    AF              ; Save status
2067   0FBD CD 37 0E            CALL    CHKTYP          ; Check that types match
2068   0FC0 21 F9 0F            LD      HL,CMPRES       ; Result to comparison
2069   0FC3 E5                  PUSH    HL              ; Save for RETurn
2070   0FC4 CA 8F 18            JP      Z,CMPNUM        ; Compare values if numeric
2071   0FC7 AF                  XOR     A               ; Compare two strings
2072   0FC8 32 CD 21            LD      (TYPE),A        ; Set type to numeric
2073   0FCB D5                  PUSH    DE              ; Save string name
2074   0FCC CD 4E 14            CALL    GSTRCU          ; Get current string
2075   0FCF 7E                  LD      A,(HL)          ; Get length of string
2076   0FD0 23                  INC     HL
2077   0FD1 23                  INC     HL
2078   0FD2 4E                  LD      C,(HL)          ; Get LSB of address
2079   0FD3 23                  INC     HL
2080   0FD4 46                  LD      B,(HL)          ; Get MSB of address
2081   0FD5 D1                  POP     DE              ; Restore string name
2082   0FD6 C5                  PUSH    BC              ; Save address of string
2083   0FD7 F5                  PUSH    AF              ; Save length of string
2084   0FD8 CD 52 14            CALL    GSTRDE          ; Get second string
2085   0FDB CD 63 18            CALL    LOADFP          ; Get address of second string
2086   0FDE F1                  POP     AF              ; Restore length of string 1
2087   0FDF 57                  LD      D,A             ; Length to D
2088   0FE0 E1                  POP     HL              ; Restore address of string 1
2089   0FE1 7B          CMPSTR: LD      A,E             ; Bytes of string 2 to do
2090   0FE2 B2                  OR      D               ; Bytes of string 1 to do
2091   0FE3 C8                  RET     Z               ; Exit if all bytes compared
2092   0FE4 7A                  LD      A,D             ; Get bytes of string 1 to do
2093   0FE5 D6 01               SUB     1
2094   0FE7 D8                  RET     C               ; Exit if end of string 1
2095   0FE8 AF                  XOR     A
2096   0FE9 BB                  CP      E               ; Bytes of string 2 to do
2097   0FEA 3C                  INC     A
2098   0FEB D0                  RET     NC              ; Exit if end of string 2
2099   0FEC 15                  DEC     D               ; Count bytes in string 1
2100   0FED 1D                  DEC     E               ; Count bytes in string 2
2101   0FEE 0A                  LD      A,(BC)          ; Byte in string 2
2102   0FEF BE                  CP      (HL)            ; Compare to byte in string 1
2103   0FF0 23                  INC     HL              ; Move up string 1
2104   0FF1 03                  INC     BC              ; Move up string 2
2105   0FF2 CA E1 0F            JP      Z,CMPSTR        ; Same - Try next bytes
2106   0FF5 3F                  CCF                     ; Flag difference (">" or "<")
2107   0FF6 C3 1F 18            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2108   0FF9             
2109   0FF9 3C          CMPRES: INC     A               ; Increment current value
2110   0FFA 8F                  ADC     A,A             ; Double plus carry
2111   0FFB C1                  POP     BC              ; Get other value
2112   0FFC A0                  AND     B               ; Combine them
2113   0FFD C6 FF               ADD     A,-1            ; Carry set if different
2114   0FFF 9F                  SBC     A,A             ; 00 - Equal , FF - Different
2115   1000 C3 26 18            JP      FLGREL          ; Set current value & continue
2116   1003             
2117   1003 16 5A       EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2118   1005 CD 47 0E            CALL    EVAL1           ; Eval until precedence break
2119   1008 CD 35 0E            CALL    TSTNUM          ; Make sure it's a number
2120   100B CD 77 0A            CALL    DEINT           ; Get integer -32768 - 32767
2121   100E 7B                  LD      A,E             ; Get LSB
2122   100F 2F                  CPL                     ; Invert LSB
2123   1010 4F                  LD      C,A             ; Save "NOT" of LSB
2124   1011 7A                  LD      A,D             ; Get MSB
2125   1012 2F                  CPL                     ; Invert MSB
2126   1013 CD EC 11            CALL    ACPASS          ; Save AC as current
2127   1016 C1                  POP     BC              ; Clean up stack
2128   1017 C3 53 0E            JP      EVAL3           ; Continue evaluation
2129   101A             
2130   101A 2B          DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2131   101B CD C5 09            CALL    GETCHR          ; Get next character
2132   101E C8                  RET     Z               ; End of DIM statement
2133   101F CD 3B 08            CALL    CHKSYN          ; Make sure ',' follows
2134   1022 2C                  .BYTE      ','
2135   1023 01 1A 10    DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2136   1026 C5                  PUSH    BC              ; Save on stack
2137   1027 F6                  .BYTE      0F6H            ; Flag "Create" variable
2138   1028 AF          GETVAR: XOR     A               ; Find variable address,to DE
2139   1029 32 CC 21            LD      (LCRFLG),A      ; Set locate / create flag
2140   102C 46                  LD      B,(HL)          ; Get First byte of name
2141   102D CD 63 0A    GTFNAM: CALL    CHKLTR          ; See if a letter
2142   1030 DA 6D 05            JP      C,SNERR         ; ?SN Error if not a letter
2143   1033 AF                  XOR     A
2144   1034 4F                  LD      C,A             ; Clear second byte of name
2145   1035 32 CD 21            LD      (TYPE),A        ; Set type to numeric
2146   1038 CD C5 09            CALL    GETCHR          ; Get next character
2147   103B DA 44 10            JP      C,SVNAM2        ; Numeric - Save in name
2148   103E CD 63 0A            CALL    CHKLTR          ; See if a letter
2149   1041 DA 51 10            JP      C,CHARTY        ; Not a letter - Check type
2150   1044 4F          SVNAM2: LD      C,A             ; Save second byte of name
2151   1045 CD C5 09    ENDNAM: CALL    GETCHR          ; Get next character
2152   1048 DA 45 10            JP      C,ENDNAM        ; Numeric - Get another
2153   104B CD 63 0A            CALL    CHKLTR          ; See if a letter
2154   104E D2 45 10            JP      NC,ENDNAM       ; Letter - Get another
2155   1051 D6 24       CHARTY: SUB     '$'             ; String variable?
2156   1053 C2 60 10            JP      NZ,NOTSTR       ; No - Numeric variable
2157   1056 3C                  INC     A               ; A = 1 (string type)
2158   1057 32 CD 21            LD      (TYPE),A        ; Set type to string
2159   105A 0F                  RRCA                    ; A = 80H , Flag for string
2160   105B 81                  ADD     A,C             ; 2nd byte of name has bit 7 on
2161   105C 4F                  LD      C,A             ; Resave second byte on name
2162   105D CD C5 09            CALL    GETCHR          ; Get next character
2163   1060 3A EB 21    NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2164   1063 3D                  DEC     A
2165   1064 CA 0D 11            JP      Z,ARLDSV        ; Yes - Get array name
2166   1067 F2 70 10            JP      P,NSCFOR        ; No array with "FOR" or "FN"
2167   106A 7E                  LD      A,(HL)          ; Get byte again
2168   106B D6 28               SUB     '('             ; Subscripted variable?
2169   106D CA E5 10            JP      Z,SBSCPT        ; Yes - Sort out subscript
2170   1070             
2171   1070 AF          NSCFOR: XOR     A               ; Simple variable
2172   1071 32 EB 21            LD      (FORFLG),A      ; Clear "FOR" flag
2173   1074 E5                  PUSH    HL              ; Save code string address
2174   1075 50                  LD      D,B             ; DE = Variable name to find
2175   1076 59                  LD      E,C
2176   1077 2A FE 21            LD      HL,(FNRGNM)     ; FN argument name
2177   107A CD 35 08            CALL    CPDEHL          ; Is it the FN argument?
2178   107D 11 00 22            LD      DE,FNARG        ; Point to argument value
2179   1080 CA 55 17            JP      Z,POPHRT        ; Yes - Return FN argument value
2180   1083 2A F8 21            LD      HL,(VAREND)     ; End of variables
2181   1086 EB                  EX      DE,HL           ; Address of end of search
2182   1087 2A F6 21            LD      HL,(PROGND)     ; Start of variables address
2183   108A CD 35 08    FNDVAR: CALL    CPDEHL          ; End of variable list table?
2184   108D CA A3 10            JP      Z,CFEVAL        ; Yes - Called from EVAL?
2185   1090 79                  LD      A,C             ; Get second byte of name
2186   1091 96                  SUB     (HL)            ; Compare with name in list
2187   1092 23                  INC     HL              ; Move on to first byte
2188   1093 C2 98 10            JP      NZ,FNTHR        ; Different - Find another
2189   1096 78                  LD      A,B             ; Get first byte of name
2190   1097 96                  SUB     (HL)            ; Compare with name in list
2191   1098 23          FNTHR:  INC     HL              ; Move on to LSB of value
2192   1099 CA D7 10            JP      Z,RETADR        ; Found - Return address
2193   109C 23                  INC     HL              ; <- Skip
2194   109D 23                  INC     HL              ; <- over
2195   109E 23                  INC     HL              ; <- F.P.
2196   109F 23                  INC     HL              ; <- value
2197   10A0 C3 8A 10            JP      FNDVAR          ; Keep looking
2198   10A3             
2199   10A3 E1          CFEVAL: POP     HL              ; Restore code string address
2200   10A4 E3                  EX      (SP),HL         ; Get return address
2201   10A5 D5                  PUSH    DE              ; Save address of variable
2202   10A6 11 25 0F            LD      DE,FRMEVL       ; Return address in EVAL
2203   10A9 CD 35 08            CALL    CPDEHL          ; Called from EVAL ?
2204   10AC D1                  POP     DE              ; Restore address of variable
2205   10AD CA DA 10            JP      Z,RETNUL        ; Yes - Return null variable
2206   10B0 E3                  EX      (SP),HL         ; Put back return
2207   10B1 E5                  PUSH    HL              ; Save code string address
2208   10B2 C5                  PUSH    BC              ; Save variable name
2209   10B3 01 06 00            LD      BC,6            ; 2 byte name plus 4 byte data
2210   10B6 2A FA 21            LD      HL,(ARREND)     ; End of arrays
2211   10B9 E5                  PUSH    HL              ; Save end of arrays
2212   10BA 09                  ADD     HL,BC           ; Move up 6 bytes
2213   10BB C1                  POP     BC              ; Source address in BC
2214   10BC E5                  PUSH    HL              ; Save new end address
2215   10BD CD 39 05            CALL    MOVUP           ; Move arrays up
2216   10C0 E1                  POP     HL              ; Restore new end address
2217   10C1 22 FA 21            LD      (ARREND),HL     ; Set new end address
2218   10C4 60                  LD      H,B             ; End of variables to HL
2219   10C5 69                  LD      L,C
2220   10C6 22 F8 21            LD      (VAREND),HL     ; Set new end address
2221   10C9             
2222   10C9 2B          ZEROLP: DEC     HL              ; Back through to zero variable
2223   10CA 36 00               LD      (HL),0          ; Zero byte in variable
2224   10CC CD 35 08            CALL    CPDEHL          ; Done them all?
2225   10CF C2 C9 10            JP      NZ,ZEROLP       ; No - Keep on going
2226   10D2 D1                  POP     DE              ; Get variable name
2227   10D3 73                  LD      (HL),E          ; Store second character
2228   10D4 23                  INC     HL
2229   10D5 72                  LD      (HL),D          ; Store first character
2230   10D6 23                  INC     HL
2231   10D7 EB          RETADR: EX      DE,HL           ; Address of variable in DE
2232   10D8 E1                  POP     HL              ; Restore code string address
2233   10D9 C9                  RET
2234   10DA             
2235   10DA 32 07 22    RETNUL: LD      (FPEXP),A       ; Set result to zero
2236   10DD 21 09 05            LD      HL,ZERBYT       ; Also set a null string
2237   10E0 22 04 22            LD      (FPREG),HL      ; Save for EVAL
2238   10E3 E1                  POP     HL              ; Restore code string address
2239   10E4 C9                  RET
2240   10E5             
2241   10E5 E5          SBSCPT: PUSH    HL              ; Save code string address
2242   10E6 2A CC 21            LD      HL,(LCRFLG)     ; Locate/Create and Type
2243   10E9 E3                  EX      (SP),HL         ; Save and get code string
2244   10EA 57                  LD      D,A             ; Zero number of dimensions
2245   10EB D5          SCPTLP: PUSH    DE              ; Save number of dimensions
2246   10EC C5                  PUSH    BC              ; Save array name
2247   10ED CD 6B 0A            CALL    FPSINT          ; Get subscript (0-32767)
2248   10F0 C1                  POP     BC              ; Restore array name
2249   10F1 F1                  POP     AF              ; Get number of dimensions
2250   10F2 EB                  EX      DE,HL
2251   10F3 E3                  EX      (SP),HL         ; Save subscript value
2252   10F4 E5                  PUSH    HL              ; Save LCRFLG and TYPE
2253   10F5 EB                  EX      DE,HL
2254   10F6 3C                  INC     A               ; Count dimensions
2255   10F7 57                  LD      D,A             ; Save in D
2256   10F8 7E                  LD      A,(HL)          ; Get next byte in code string
2257   10F9 FE 2C               CP      ','             ; Comma (more to come)?
2258   10FB CA EB 10            JP      Z,SCPTLP        ; Yes - More subscripts
2259   10FE CD 3B 08            CALL    CHKSYN          ; Make sure ")" follows
2260   1101 29                  .BYTE      ")"
2261   1102 22 F0 21            LD      (NXTOPR),HL     ; Save code string address
2262   1105 E1                  POP     HL              ; Get LCRFLG and TYPE
2263   1106 22 CC 21            LD      (LCRFLG),HL     ; Restore Locate/create & type
2264   1109 1E 00               LD      E,0             ; Flag not CSAVE* or CLOAD*
2265   110B D5                  PUSH    DE              ; Save number of dimensions (D)
2266   110C 11                  .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2267   110D             
2268   110D E5          ARLDSV: PUSH    HL              ; Save code string address
2269   110E F5                  PUSH    AF              ; A = 00 , Flags set = Z,N
2270   110F 2A F8 21            LD      HL,(VAREND)     ; Start of arrays
2271   1112 3E                  .BYTE      3EH             ; Skip "ADD HL,DE"
2272   1113 19          FNDARY: ADD     HL,DE           ; Move to next array start
2273   1114 EB                  EX      DE,HL
2274   1115 2A FA 21            LD      HL,(ARREND)     ; End of arrays
2275   1118 EB                  EX      DE,HL           ; Current array pointer
2276   1119 CD 35 08            CALL    CPDEHL          ; End of arrays found?
2277   111C CA 45 11            JP      Z,CREARY        ; Yes - Create array
2278   111F 7E                  LD      A,(HL)          ; Get second byte of name
2279   1120 B9                  CP      C               ; Compare with name given
2280   1121 23                  INC     HL              ; Move on
2281   1122 C2 27 11            JP      NZ,NXTARY       ; Different - Find next array
2282   1125 7E                  LD      A,(HL)          ; Get first byte of name
2283   1126 B8                  CP      B               ; Compare with name given
2284   1127 23          NXTARY: INC     HL              ; Move on
2285   1128 5E                  LD      E,(HL)          ; Get LSB of next array address
2286   1129 23                  INC     HL
2287   112A 56                  LD      D,(HL)          ; Get MSB of next array address
2288   112B 23                  INC     HL
2289   112C C2 13 11            JP      NZ,FNDARY       ; Not found - Keep looking
2290   112F 3A CC 21            LD      A,(LCRFLG)      ; Found Locate or Create it?
2291   1132 B7                  OR      A
2292   1133 C2 76 05            JP      NZ,DDERR        ; Create - ?DD Error
2293   1136 F1                  POP     AF              ; Locate - Get number of dim'ns
2294   1137 44                  LD      B,H             ; BC Points to array dim'ns
2295   1138 4D                  LD      C,L
2296   1139 CA 55 17            JP      Z,POPHRT        ; Jump if array load/save
2297   113C 96                  SUB     (HL)            ; Same number of dimensions?
2298   113D CA A3 11            JP      Z,FINDEL        ; Yes - Find element
2299   1140 1E 10       BSERR:  LD      E,BS            ; ?BS Error
2300   1142 C3 81 05            JP      ERROR           ; Output error
2301   1145             
2302   1145 11 04 00    CREARY: LD      DE,4            ; 4 Bytes per entry
2303   1148 F1                  POP     AF              ; Array to save or 0 dim'ns?
2304   1149 CA 8C 0A            JP      Z,FCERR         ; Yes - ?FC Error
2305   114C 71                  LD      (HL),C          ; Save second byte of name
2306   114D 23                  INC     HL
2307   114E 70                  LD      (HL),B          ; Save first byte of name
2308   114F 23                  INC     HL
2309   1150 4F                  LD      C,A             ; Number of dimensions to C
2310   1151 CD 4A 05            CALL    CHKSTK          ; Check if enough memory
2311   1154 23                  INC     HL              ; Point to number of dimensions
2312   1155 23                  INC     HL
2313   1156 22 E5 21            LD      (CUROPR),HL     ; Save address of pointer
2314   1159 71                  LD      (HL),C          ; Set number of dimensions
2315   115A 23                  INC     HL
2316   115B 3A CC 21            LD      A,(LCRFLG)      ; Locate of Create?
2317   115E 17                  RLA                     ; Carry set = Create
2318   115F 79                  LD      A,C             ; Get number of dimensions
2319   1160 01 0B 00    CRARLP: LD      BC,10+1         ; Default dimension size 10
2320   1163 D2 68 11            JP      NC,DEFSIZ       ; Locate - Set default size
2321   1166 C1                  POP     BC              ; Get specified dimension size
2322   1167 03                  INC     BC              ; Include zero element
2323   1168 71          DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2324   1169 23                  INC     HL
2325   116A 70                  LD      (HL),B          ; Save MSB of dimension size
2326   116B 23                  INC     HL
2327   116C F5                  PUSH    AF              ; Save num' of dim'ns an status
2328   116D E5                  PUSH    HL              ; Save address of dim'n size
2329   116E CD 00 19            CALL    MLDEBC          ; Multiply DE by BC to find
2330   1171 EB                  EX      DE,HL           ; amount of mem needed (to DE)
2331   1172 E1                  POP     HL              ; Restore address of dimension
2332   1173 F1                  POP     AF              ; Restore number of dimensions
2333   1174 3D                  DEC     A               ; Count them
2334   1175 C2 60 11            JP      NZ,CRARLP       ; Do next dimension if more
2335   1178 F5                  PUSH    AF              ; Save locate/create flag
2336   1179 42                  LD      B,D             ; MSB of memory needed
2337   117A 4B                  LD      C,E             ; LSB of memory needed
2338   117B EB                  EX      DE,HL
2339   117C 19                  ADD     HL,DE           ; Add bytes to array start
2340   117D DA 62 05            JP      C,OMERR         ; Too big - Error
2341   1180 CD 53 05            CALL    ENFMEM          ; See if enough memory
2342   1183 22 FA 21            LD      (ARREND),HL     ; Save new end of array
2343   1186             
2344   1186 2B          ZERARY: DEC     HL              ; Back through array data
2345   1187 36 00               LD      (HL),0          ; Set array element to zero
2346   1189 CD 35 08            CALL    CPDEHL          ; All elements zeroed?
2347   118C C2 86 11            JP      NZ,ZERARY       ; No - Keep on going
2348   118F 03                  INC     BC              ; Number of bytes + 1
2349   1190 57                  LD      D,A             ; A=0
2350   1191 2A E5 21            LD      HL,(CUROPR)     ; Get address of array
2351   1194 5E                  LD      E,(HL)          ; Number of dimensions
2352   1195 EB                  EX      DE,HL           ; To HL
2353   1196 29                  ADD     HL,HL           ; Two bytes per dimension size
2354   1197 09                  ADD     HL,BC           ; Add number of bytes
2355   1198 EB                  EX      DE,HL           ; Bytes needed to DE
2356   1199 2B                  DEC     HL
2357   119A 2B                  DEC     HL
2358   119B 73                  LD      (HL),E          ; Save LSB of bytes needed
2359   119C 23                  INC     HL
2360   119D 72                  LD      (HL),D          ; Save MSB of bytes needed
2361   119E 23                  INC     HL
2362   119F F1                  POP     AF              ; Locate / Create?
2363   11A0 DA C7 11            JP      C,ENDDIM        ; A is 0 , End if create
2364   11A3 47          FINDEL: LD      B,A             ; Find array element
2365   11A4 4F                  LD      C,A
2366   11A5 7E                  LD      A,(HL)          ; Number of dimensions
2367   11A6 23                  INC     HL
2368   11A7 16                  .BYTE      16H             ; Skip "POP HL"
2369   11A8 E1          FNDELP: POP     HL              ; Address of next dim' size
2370   11A9 5E                  LD      E,(HL)          ; Get LSB of dim'n size
2371   11AA 23                  INC     HL
2372   11AB 56                  LD      D,(HL)          ; Get MSB of dim'n size
2373   11AC 23                  INC     HL
2374   11AD E3                  EX      (SP),HL         ; Save address - Get index
2375   11AE F5                  PUSH    AF              ; Save number of dim'ns
2376   11AF CD 35 08            CALL    CPDEHL          ; Dimension too large?
2377   11B2 D2 40 11            JP      NC,BSERR        ; Yes - ?BS Error
2378   11B5 E5                  PUSH    HL              ; Save index
2379   11B6 CD 00 19            CALL    MLDEBC          ; Multiply previous by size
2380   11B9 D1                  POP     DE              ; Index supplied to DE
2381   11BA 19                  ADD     HL,DE           ; Add index to pointer
2382   11BB F1                  POP     AF              ; Number of dimensions
2383   11BC 3D                  DEC     A               ; Count them
2384   11BD 44                  LD      B,H             ; MSB of pointer
2385   11BE 4D                  LD      C,L             ; LSB of pointer
2386   11BF C2 A8 11            JP      NZ,FNDELP       ; More - Keep going
2387   11C2 29                  ADD     HL,HL           ; 4 Bytes per element
2388   11C3 29                  ADD     HL,HL
2389   11C4 C1                  POP     BC              ; Start of array
2390   11C5 09                  ADD     HL,BC           ; Point to element
2391   11C6 EB                  EX      DE,HL           ; Address of element to DE
2392   11C7 2A F0 21    ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2393   11CA C9                  RET
2394   11CB             
2395   11CB 2A FA 21    FRE:    LD      HL,(ARREND)     ; Start of free memory
2396   11CE EB                  EX      DE,HL           ; To DE
2397   11CF 21 00 00            LD      HL,0            ; End of free memory
2398   11D2 39                  ADD     HL,SP           ; Current stack value
2399   11D3 3A CD 21            LD      A,(TYPE)        ; Dummy argument type
2400   11D6 B7                  OR      A
2401   11D7 CA E7 11            JP      Z,FRENUM        ; Numeric - Free variable space
2402   11DA CD 4E 14            CALL    GSTRCU          ; Current string to pool
2403   11DD CD 4E 13            CALL    GARBGE          ; Garbage collection
2404   11E0 2A 7A 21            LD      HL,(STRSPC)     ; Bottom of string space in use
2405   11E3 EB                  EX      DE,HL           ; To DE
2406   11E4 2A E3 21            LD      HL,(STRBOT)     ; Bottom of string space
2407   11E7 7D          FRENUM: LD      A,L             ; Get LSB of end
2408   11E8 93                  SUB     E               ; Subtract LSB of beginning
2409   11E9 4F                  LD      C,A             ; Save difference if C
2410   11EA 7C                  LD      A,H             ; Get MSB of end
2411   11EB 9A                  SBC     A,D             ; Subtract MSB of beginning
2412   11EC 41          ACPASS: LD      B,C             ; Return integer AC
2413   11ED 50          ABPASS: LD      D,B             ; Return integer AB
2414   11EE 1E 00               LD      E,0
2415   11F0 21 CD 21            LD      HL,TYPE         ; Point to type
2416   11F3 73                  LD      (HL),E          ; Set type to numeric
2417   11F4 06 90               LD      B,80H+16        ; 16 bit integer
2418   11F6 C3 2B 18            JP      RETINT          ; Return the integr
2419   11F9             
2420   11F9 3A CB 21    POS:    LD      A,(CURPOS)      ; Get cursor position
2421   11FC 47          PASSA:  LD      B,A             ; Put A into AB
2422   11FD AF                  XOR     A               ; Zero A
2423   11FE C3 ED 11            JP      ABPASS          ; Return integer AB
2424   1201             
2425   1201 CD 84 12    DEF:    CALL    CHEKFN          ; Get "FN" and name
2426   1204 CD 76 12            CALL    IDTEST          ; Test for illegal direct
2427   1207 01 5C 0B            LD      BC,DATA         ; To get next statement
2428   120A C5                  PUSH    BC              ; Save address for RETurn
2429   120B D5                  PUSH    DE              ; Save address of function ptr
2430   120C CD 3B 08            CALL    CHKSYN          ; Make sure "(" follows
2431   120F 28                  .BYTE      "("
2432   1210 CD 28 10            CALL    GETVAR          ; Get argument variable name
2433   1213 E5                  PUSH    HL              ; Save code string address
2434   1214 EB                  EX      DE,HL           ; Argument address to HL
2435   1215 2B                  DEC     HL
2436   1216 56                  LD      D,(HL)          ; Get first byte of arg name
2437   1217 2B                  DEC     HL
2438   1218 5E                  LD      E,(HL)          ; Get second byte of arg name
2439   1219 E1                  POP     HL              ; Restore code string address
2440   121A CD 35 0E            CALL    TSTNUM          ; Make sure numeric argument
2441   121D CD 3B 08            CALL    CHKSYN          ; Make sure ")" follows
2442   1220 29                  .BYTE      ")"
2443   1221 CD 3B 08            CALL    CHKSYN          ; Make sure "=" follows
2444   1224 B4                  .BYTE      ZEQUAL          ; "=" token
2445   1225 44                  LD      B,H             ; Code string address to BC
2446   1226 4D                  LD      C,L
2447   1227 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2448   1228 71                  LD      (HL),C          ; Save LSB of FN code string
2449   1229 23                  INC     HL
2450   122A 70                  LD      (HL),B          ; Save MSB of FN code string
2451   122B C3 C3 12            JP      SVSTAD          ; Save address and do function
2452   122E             
2453   122E CD 84 12    DOFN:   CALL    CHEKFN          ; Make sure FN follows
2454   1231 D5                  PUSH    DE              ; Save function pointer address
2455   1232 CD 09 0F            CALL    EVLPAR          ; Evaluate expression in "()"
2456   1235 CD 35 0E            CALL    TSTNUM          ; Make sure numeric result
2457   1238 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2458   1239 5E                  LD      E,(HL)          ; Get LSB of FN code string
2459   123A 23                  INC     HL
2460   123B 56                  LD      D,(HL)          ; Get MSB of FN code string
2461   123C 23                  INC     HL
2462   123D 7A                  LD      A,D             ; And function DEFined?
2463   123E B3                  OR      E
2464   123F CA 79 05            JP      Z,UFERR         ; No - ?UF Error
2465   1242 7E                  LD      A,(HL)          ; Get LSB of argument address
2466   1243 23                  INC     HL
2467   1244 66                  LD      H,(HL)          ; Get MSB of argument address
2468   1245 6F                  LD      L,A             ; HL = Arg variable address
2469   1246 E5                  PUSH    HL              ; Save it
2470   1247 2A FE 21            LD      HL,(FNRGNM)     ; Get old argument name
2471   124A E3                  EX      (SP),HL ;       ; Save old , Get new
2472   124B 22 FE 21            LD      (FNRGNM),HL     ; Set new argument name
2473   124E 2A 02 22            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2474   1251 E5                  PUSH    HL              ; Save it
2475   1252 2A 00 22            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2476   1255 E5                  PUSH    HL              ; Save it
2477   1256 21 00 22            LD      HL,FNARG        ; HL = Value of argument
2478   1259 D5                  PUSH    DE              ; Save FN code string address
2479   125A CD 6C 18            CALL    FPTHL           ; Move FPREG to argument
2480   125D E1                  POP     HL              ; Get FN code string address
2481   125E CD 32 0E            CALL    GETNUM          ; Get value from function
2482   1261 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2483   1262 CD C5 09            CALL    GETCHR          ; Get next character
2484   1265 C2 6D 05            JP      NZ,SNERR        ; Bad character in FN - Error
2485   1268 E1                  POP     HL              ; Get MSB,EXP of old arg
2486   1269 22 00 22            LD      (FNARG),HL      ; Restore it
2487   126C E1                  POP     HL              ; Get LSB,NLSB of old arg
2488   126D 22 02 22            LD      (FNARG+2),HL    ; Restore it
2489   1270 E1                  POP     HL              ; Get name of old arg
2490   1271 22 FE 21            LD      (FNRGNM),HL     ; Restore it
2491   1274 E1                  POP     HL              ; Restore code string address
2492   1275 C9                  RET
2493   1276             
2494   1276 E5          IDTEST: PUSH    HL              ; Save code string address
2495   1277 2A 7C 21            LD      HL,(LINEAT)     ; Get current line number
2496   127A 23                  INC     HL              ; -1 means direct statement
2497   127B 7C                  LD      A,H
2498   127C B5                  OR      L
2499   127D E1                  POP     HL              ; Restore code string address
2500   127E C0                  RET     NZ              ; Return if in program
2501   127F 1E 16               LD      E,ID            ; ?ID Error
2502   1281 C3 81 05            JP      ERROR
2503   1284             
2504   1284 CD 3B 08    CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2505   1287 A7                  .BYTE      ZFN             ; "FN" token
2506   1288 3E 80               LD      A,80H
2507   128A 32 EB 21            LD      (FORFLG),A      ; Flag FN name to find
2508   128D B6                  OR      (HL)            ; FN name has bit 7 set
2509   128E 47                  LD      B,A             ; in first byte of name
2510   128F CD 2D 10            CALL    GTFNAM          ; Get FN name
2511   1292 C3 35 0E            JP      TSTNUM          ; Make sure numeric function
2512   1295             
2513   1295 CD 35 0E    STR:    CALL    TSTNUM          ; Make sure it's a number
2514   1298 CD B9 19            CALL    NUMASC          ; Turn number into text
2515   129B CD C9 12    STR1:   CALL    CRTST           ; Create string entry for it
2516   129E CD 4E 14            CALL    GSTRCU          ; Current string to pool
2517   12A1 01 A9 14            LD      BC,TOPOOL       ; Save in string pool
2518   12A4 C5                  PUSH    BC              ; Save address on stack
2519   12A5             
2520   12A5 7E          SAVSTR: LD      A,(HL)          ; Get string length
2521   12A6 23                  INC     HL
2522   12A7 23                  INC     HL
2523   12A8 E5                  PUSH    HL              ; Save pointer to string
2524   12A9 CD 24 13            CALL    TESTR           ; See if enough string space
2525   12AC E1                  POP     HL              ; Restore pointer to string
2526   12AD 4E                  LD      C,(HL)          ; Get LSB of address
2527   12AE 23                  INC     HL
2528   12AF 46                  LD      B,(HL)          ; Get MSB of address
2529   12B0 CD BD 12            CALL    CRTMST          ; Create string entry
2530   12B3 E5                  PUSH    HL              ; Save pointer to MSB of addr
2531   12B4 6F                  LD      L,A             ; Length of string
2532   12B5 CD 41 14            CALL    TOSTRA          ; Move to string area
2533   12B8 D1                  POP     DE              ; Restore pointer to MSB
2534   12B9 C9                  RET
2535   12BA             
2536   12BA CD 24 13    MKTMST: CALL    TESTR           ; See if enough string space
2537   12BD 21 DF 21    CRTMST: LD      HL,TMPSTR       ; Temporary string
2538   12C0 E5                  PUSH    HL              ; Save it
2539   12C1 77                  LD      (HL),A          ; Save length of string
2540   12C2 23                  INC     HL
2541   12C3 23          SVSTAD: INC     HL
2542   12C4 73                  LD      (HL),E          ; Save LSB of address
2543   12C5 23                  INC     HL
2544   12C6 72                  LD      (HL),D          ; Save MSB of address
2545   12C7 E1                  POP     HL              ; Restore pointer
2546   12C8 C9                  RET
2547   12C9             
2548   12C9 2B          CRTST:  DEC     HL              ; DEC - INCed after
2549   12CA 06 22       QTSTR:  LD      B,'"'           ; Terminating quote
2550   12CC 50                  LD      D,B             ; Quote to D
2551   12CD E5          DTSTR:  PUSH    HL              ; Save start
2552   12CE 0E FF               LD      C,-1            ; Set counter to -1
2553   12D0 23          QTSTLP: INC     HL              ; Move on
2554   12D1 7E                  LD      A,(HL)          ; Get byte
2555   12D2 0C                  INC     C               ; Count bytes
2556   12D3 B7                  OR      A               ; End of line?
2557   12D4 CA DF 12            JP      Z,CRTSTE        ; Yes - Create string entry
2558   12D7 BA                  CP      D               ; Terminator D found?
2559   12D8 CA DF 12            JP      Z,CRTSTE        ; Yes - Create string entry
2560   12DB B8                  CP      B               ; Terminator B found?
2561   12DC C2 D0 12            JP      NZ,QTSTLP       ; No - Keep looking
2562   12DF FE 22       CRTSTE: CP      '"'             ; End with '"'?
2563   12E1 CC C5 09            CALL    Z,GETCHR        ; Yes - Get next character
2564   12E4 E3                  EX      (SP),HL         ; Starting quote
2565   12E5 23                  INC     HL              ; First byte of string
2566   12E6 EB                  EX      DE,HL           ; To DE
2567   12E7 79                  LD      A,C             ; Get length
2568   12E8 CD BD 12            CALL    CRTMST          ; Create string entry
2569   12EB 11 DF 21    TSTOPL: LD      DE,TMPSTR       ; Temporary string
2570   12EE 2A D1 21            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2571   12F1 22 04 22            LD      (FPREG),HL      ; Save address of string ptr
2572   12F4 3E 01               LD      A,1
2573   12F6 32 CD 21            LD      (TYPE),A        ; Set type to string
2574   12F9 CD 6F 18            CALL    DETHL4          ; Move string to pool
2575   12FC CD 35 08            CALL    CPDEHL          ; Out of string pool?
2576   12FF 22 D1 21            LD      (TMSTPT),HL     ; Save new pointer
2577   1302 E1                  POP     HL              ; Restore code string address
2578   1303 7E                  LD      A,(HL)          ; Get next code byte
2579   1304 C0                  RET     NZ              ; Return if pool OK
2580   1305 1E 1E               LD      E,ST            ; ?ST Error
2581   1307 C3 81 05            JP      ERROR           ; String pool overflow
2582   130A             
2583   130A 23          PRNUMS: INC     HL              ; Skip leading space
2584   130B CD C9 12    PRS:    CALL    CRTST           ; Create string entry for it
2585   130E CD 4E 14    PRS1:   CALL    GSTRCU          ; Current string to pool
2586   1311 CD 63 18            CALL    LOADFP          ; Move string block to BCDE
2587   1314 1C                  INC     E               ; Length + 1
2588   1315 1D          PRSLP:  DEC     E               ; Count characters
2589   1316 C8                  RET     Z               ; End of string
2590   1317 0A                  LD      A,(BC)          ; Get byte to output
2591   1318 CD 46 08            CALL    OUTC            ; Output character in A
2592   131B FE 0D               CP      CR              ; Return?
2593   131D CC 77 0C            CALL    Z,DONULL        ; Yes - Do nulls
2594   1320 03                  INC     BC              ; Next byte in string
2595   1321 C3 15 13            JP      PRSLP           ; More characters to output
2596   1324             
2597   1324 B7          TESTR:  OR      A               ; Test if enough room
2598   1325 0E                  .BYTE      0EH             ; No garbage collection done
2599   1326 F1          GRBDON: POP     AF              ; Garbage collection done
2600   1327 F5                  PUSH    AF              ; Save status
2601   1328 2A 7A 21            LD      HL,(STRSPC)     ; Bottom of string space in use
2602   132B EB                  EX      DE,HL           ; To DE
2603   132C 2A E3 21            LD      HL,(STRBOT)     ; Bottom of string area
2604   132F 2F                  CPL                     ; Negate length (Top down)
2605   1330 4F                  LD      C,A             ; -Length to BC
2606   1331 06 FF               LD      B,-1            ; BC = -ve length of string
2607   1333 09                  ADD     HL,BC           ; Add to bottom of space in use
2608   1334 23                  INC     HL              ; Plus one for 2's complement
2609   1335 CD 35 08            CALL    CPDEHL          ; Below string RAM area?
2610   1338 DA 42 13            JP      C,TESTOS        ; Tidy up if not done else err
2611   133B 22 E3 21            LD      (STRBOT),HL     ; Save new bottom of area
2612   133E 23                  INC     HL              ; Point to first byte of string
2613   133F EB                  EX      DE,HL           ; Address to DE
2614   1340 F1          POPAF:  POP     AF              ; Throw away status push
2615   1341 C9                  RET
2616   1342             
2617   1342 F1          TESTOS: POP     AF              ; Garbage collect been done?
2618   1343 1E 1A               LD      E,OS            ; ?OS Error
2619   1345 CA 81 05            JP      Z,ERROR         ; Yes - Not enough string apace
2620   1348 BF                  CP      A               ; Flag garbage collect done
2621   1349 F5                  PUSH    AF              ; Save status
2622   134A 01 26 13            LD      BC,GRBDON       ; Garbage collection done
2623   134D C5                  PUSH    BC              ; Save for RETurn
2624   134E 2A CF 21    GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2625   1351 22 E3 21    GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2626   1354 21 00 00            LD      HL,0
2627   1357 E5                  PUSH    HL              ; Flag no string found
2628   1358 2A 7A 21            LD      HL,(STRSPC)     ; Get bottom of string space
2629   135B E5                  PUSH    HL              ; Save bottom of string space
2630   135C 21 D3 21            LD      HL,TMSTPL       ; Temporary string pool
2631   135F EB          GRBLP:  EX      DE,HL
2632   1360 2A D1 21            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2633   1363 EB                  EX      DE,HL
2634   1364 CD 35 08            CALL    CPDEHL          ; Temporary string pool done?
2635   1367 01 5F 13            LD      BC,GRBLP        ; Loop until string pool done
2636   136A C2 B3 13            JP      NZ,STPOOL       ; No - See if in string area
2637   136D 2A F6 21            LD      HL,(PROGND)     ; Start of simple variables
2638   1370 EB          SMPVAR: EX      DE,HL
2639   1371 2A F8 21            LD      HL,(VAREND)     ; End of simple variables
2640   1374 EB                  EX      DE,HL
2641   1375 CD 35 08            CALL    CPDEHL          ; All simple strings done?
2642   1378 CA 86 13            JP      Z,ARRLP         ; Yes - Do string arrays
2643   137B 7E                  LD      A,(HL)          ; Get type of variable
2644   137C 23                  INC     HL
2645   137D 23                  INC     HL
2646   137E B7                  OR      A               ; "S" flag set if string
2647   137F CD B6 13            CALL    STRADD          ; See if string in string area
2648   1382 C3 70 13            JP      SMPVAR          ; Loop until simple ones done
2649   1385             
2650   1385 C1          GNXARY: POP     BC              ; Scrap address of this array
2651   1386 EB          ARRLP:  EX      DE,HL
2652   1387 2A FA 21            LD      HL,(ARREND)     ; End of string arrays
2653   138A EB                  EX      DE,HL
2654   138B CD 35 08            CALL    CPDEHL          ; All string arrays done?
2655   138E CA DC 13            JP      Z,SCNEND        ; Yes - Move string if found
2656   1391 CD 63 18            CALL    LOADFP          ; Get array name to BCDE
2657   1394 7B                  LD      A,E             ; Get type of array     
2658   1395 E5                  PUSH    HL              ; Save address of num of dim'ns
2659   1396 09                  ADD     HL,BC           ; Start of next array
2660   1397 B7                  OR      A               ; Test type of array
2661   1398 F2 85 13            JP      P,GNXARY        ; Numeric array - Ignore it
2662   139B 22 E5 21            LD      (CUROPR),HL     ; Save address of next array
2663   139E E1                  POP     HL              ; Get address of num of dim'ns
2664   139F 4E                  LD      C,(HL)          ; BC = Number of dimensions
2665   13A0 06 00               LD      B,0
2666   13A2 09                  ADD     HL,BC           ; Two bytes per dimension size
2667   13A3 09                  ADD     HL,BC
2668   13A4 23                  INC     HL              ; Plus one for number of dim'ns
2669   13A5 EB          GRBARY: EX      DE,HL
2670   13A6 2A E5 21            LD      HL,(CUROPR)     ; Get address of next array
2671   13A9 EB                  EX      DE,HL
2672   13AA CD 35 08            CALL    CPDEHL          ; Is this array finished?
2673   13AD CA 86 13            JP      Z,ARRLP         ; Yes - Get next one
2674   13B0 01 A5 13            LD      BC,GRBARY       ; Loop until array all done
2675   13B3 C5          STPOOL: PUSH    BC              ; Save return address
2676   13B4 F6 80               OR      80H             ; Flag string type
2677   13B6 7E          STRADD: LD      A,(HL)          ; Get string length
2678   13B7 23                  INC     HL
2679   13B8 23                  INC     HL
2680   13B9 5E                  LD      E,(HL)          ; Get LSB of string address
2681   13BA 23                  INC     HL
2682   13BB 56                  LD      D,(HL)          ; Get MSB of string address
2683   13BC 23                  INC     HL
2684   13BD F0                  RET     P               ; Not a string - Return
2685   13BE B7                  OR      A               ; Set flags on string length
2686   13BF C8                  RET     Z               ; Null string - Return
2687   13C0 44                  LD      B,H             ; Save variable pointer
2688   13C1 4D                  LD      C,L
2689   13C2 2A E3 21            LD      HL,(STRBOT)     ; Bottom of new area
2690   13C5 CD 35 08            CALL    CPDEHL          ; String been done?
2691   13C8 60                  LD      H,B             ; Restore variable pointer
2692   13C9 69                  LD      L,C
2693   13CA D8                  RET     C               ; String done - Ignore
2694   13CB E1                  POP     HL              ; Return address
2695   13CC E3                  EX      (SP),HL         ; Lowest available string area
2696   13CD CD 35 08            CALL    CPDEHL          ; String within string area?
2697   13D0 E3                  EX      (SP),HL         ; Lowest available string area
2698   13D1 E5                  PUSH    HL              ; Re-save return address
2699   13D2 60                  LD      H,B             ; Restore variable pointer
2700   13D3 69                  LD      L,C
2701   13D4 D0                  RET     NC              ; Outside string area - Ignore
2702   13D5 C1                  POP     BC              ; Get return , Throw 2 away
2703   13D6 F1                  POP     AF              ; 
2704   13D7 F1                  POP     AF              ; 
2705   13D8 E5                  PUSH    HL              ; Save variable pointer
2706   13D9 D5                  PUSH    DE              ; Save address of current
2707   13DA C5                  PUSH    BC              ; Put back return address
2708   13DB C9                  RET                     ; Go to it
2709   13DC             
2710   13DC D1          SCNEND: POP     DE              ; Addresses of strings
2711   13DD E1                  POP     HL              ; 
2712   13DE 7D                  LD      A,L             ; HL = 0 if no more to do
2713   13DF B4                  OR      H
2714   13E0 C8                  RET     Z               ; No more to do - Return
2715   13E1 2B                  DEC     HL
2716   13E2 46                  LD      B,(HL)          ; MSB of address of string
2717   13E3 2B                  DEC     HL
2718   13E4 4E                  LD      C,(HL)          ; LSB of address of string
2719   13E5 E5                  PUSH    HL              ; Save variable address
2720   13E6 2B                  DEC     HL
2721   13E7 2B                  DEC     HL
2722   13E8 6E                  LD      L,(HL)          ; HL = Length of string
2723   13E9 26 00               LD      H,0
2724   13EB 09                  ADD     HL,BC           ; Address of end of string+1
2725   13EC 50                  LD      D,B             ; String address to DE
2726   13ED 59                  LD      E,C
2727   13EE 2B                  DEC     HL              ; Last byte in string
2728   13EF 44                  LD      B,H             ; Address to BC
2729   13F0 4D                  LD      C,L
2730   13F1 2A E3 21            LD      HL,(STRBOT)     ; Current bottom of string area
2731   13F4 CD 3C 05            CALL    MOVSTR          ; Move string to new address
2732   13F7 E1                  POP     HL              ; Restore variable address
2733   13F8 71                  LD      (HL),C          ; Save new LSB of address
2734   13F9 23                  INC     HL
2735   13FA 70                  LD      (HL),B          ; Save new MSB of address
2736   13FB 69                  LD      L,C             ; Next string area+1 to HL
2737   13FC 60                  LD      H,B
2738   13FD 2B                  DEC     HL              ; Next string area address
2739   13FE C3 51 13            JP      GARBLP          ; Look for more strings
2740   1401             
2741   1401 C5          CONCAT: PUSH    BC              ; Save prec' opr & code string
2742   1402 E5                  PUSH    HL              ; 
2743   1403 2A 04 22            LD      HL,(FPREG)      ; Get first string
2744   1406 E3                  EX      (SP),HL         ; Save first string
2745   1407 CD BB 0E            CALL    OPRND           ; Get second string
2746   140A E3                  EX      (SP),HL         ; Restore first string
2747   140B CD 36 0E            CALL    TSTSTR          ; Make sure it's a string
2748   140E 7E                  LD      A,(HL)          ; Get length of second string
2749   140F E5                  PUSH    HL              ; Save first string
2750   1410 2A 04 22            LD      HL,(FPREG)      ; Get second string
2751   1413 E5                  PUSH    HL              ; Save second string
2752   1414 86                  ADD     A,(HL)          ; Add length of second string
2753   1415 1E 1C               LD      E,LS            ; ?LS Error
2754   1417 DA 81 05            JP      C,ERROR         ; String too long - Error
2755   141A CD BA 12            CALL    MKTMST          ; Make temporary string
2756   141D D1                  POP     DE              ; Get second string to DE
2757   141E CD 52 14            CALL    GSTRDE          ; Move to string pool if needed
2758   1421 E3                  EX      (SP),HL         ; Get first string
2759   1422 CD 51 14            CALL    GSTRHL          ; Move to string pool if needed
2760   1425 E5                  PUSH    HL              ; Save first string
2761   1426 2A E1 21            LD      HL,(TMPSTR+2)   ; Temporary string address
2762   1429 EB                  EX      DE,HL           ; To DE
2763   142A CD 38 14            CALL    SSTSA           ; First string to string area
2764   142D CD 38 14            CALL    SSTSA           ; Second string to string area
2765   1430 21 50 0E            LD      HL,EVAL2        ; Return to evaluation loop
2766   1433 E3                  EX      (SP),HL         ; Save return,get code string
2767   1434 E5                  PUSH    HL              ; Save code string address
2768   1435 C3 EB 12            JP      TSTOPL          ; To temporary string to pool
2769   1438             
2770   1438 E1          SSTSA:  POP     HL              ; Return address
2771   1439 E3                  EX      (SP),HL         ; Get string block,save return
2772   143A 7E                  LD      A,(HL)          ; Get length of string
2773   143B 23                  INC     HL
2774   143C 23                  INC     HL
2775   143D 4E                  LD      C,(HL)          ; Get LSB of string address
2776   143E 23                  INC     HL
2777   143F 46                  LD      B,(HL)          ; Get MSB of string address
2778   1440 6F                  LD      L,A             ; Length to L
2779   1441 2C          TOSTRA: INC     L               ; INC - DECed after
2780   1442 2D          TSALP:  DEC     L               ; Count bytes moved
2781   1443 C8                  RET     Z               ; End of string - Return
2782   1444 0A                  LD      A,(BC)          ; Get source
2783   1445 12                  LD      (DE),A          ; Save destination
2784   1446 03                  INC     BC              ; Next source
2785   1447 13                  INC     DE              ; Next destination
2786   1448 C3 42 14            JP      TSALP           ; Loop until string moved
2787   144B             
2788   144B CD 36 0E    GETSTR: CALL    TSTSTR          ; Make sure it's a string
2789   144E 2A 04 22    GSTRCU: LD      HL,(FPREG)      ; Get current string
2790   1451 EB          GSTRHL: EX      DE,HL           ; Save DE
2791   1452 CD 6C 14    GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2792   1455 EB                  EX      DE,HL           ; Restore DE
2793   1456 C0                  RET     NZ              ; No - Return
2794   1457 D5                  PUSH    DE              ; Save string
2795   1458 50                  LD      D,B             ; String block address to DE
2796   1459 59                  LD      E,C
2797   145A 1B                  DEC     DE              ; Point to length
2798   145B 4E                  LD      C,(HL)          ; Get string length
2799   145C 2A E3 21            LD      HL,(STRBOT)     ; Current bottom of string area
2800   145F CD 35 08            CALL    CPDEHL          ; Last one in string area?
2801   1462 C2 6A 14            JP      NZ,POPHL        ; No - Return
2802   1465 47                  LD      B,A             ; Clear B (A=0)
2803   1466 09                  ADD     HL,BC           ; Remove string from str' area
2804   1467 22 E3 21            LD      (STRBOT),HL     ; Save new bottom of str' area
2805   146A E1          POPHL:  POP     HL              ; Restore string
2806   146B C9                  RET
2807   146C             
2808   146C 2A D1 21    BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2809   146F 2B                  DEC     HL              ; Back
2810   1470 46                  LD      B,(HL)          ; Get MSB of address
2811   1471 2B                  DEC     HL              ; Back
2812   1472 4E                  LD      C,(HL)          ; Get LSB of address
2813   1473 2B                  DEC     HL              ; Back
2814   1474 2B                  DEC     HL              ; Back
2815   1475 CD 35 08            CALL    CPDEHL          ; String last in string pool?
2816   1478 C0                  RET     NZ              ; Yes - Leave it
2817   1479 22 D1 21            LD      (TMSTPT),HL     ; Save new string pool top
2818   147C C9                  RET
2819   147D             
2820   147D 01 FC 11    LEN:    LD      BC,PASSA        ; To return integer A
2821   1480 C5                  PUSH    BC              ; Save address
2822   1481 CD 4B 14    GETLEN: CALL    GETSTR          ; Get string and its length
2823   1484 AF                  XOR     A
2824   1485 57                  LD      D,A             ; Clear D
2825   1486 32 CD 21            LD      (TYPE),A        ; Set type to numeric
2826   1489 7E                  LD      A,(HL)          ; Get length of string
2827   148A B7                  OR      A               ; Set status flags
2828   148B C9                  RET
2829   148C             
2830   148C 01 FC 11    ASC:    LD      BC,PASSA        ; To return integer A
2831   148F C5                  PUSH    BC              ; Save address
2832   1490 CD 81 14    GTFLNM: CALL    GETLEN          ; Get length of string
2833   1493 CA 8C 0A            JP      Z,FCERR         ; Null string - Error
2834   1496 23                  INC     HL
2835   1497 23                  INC     HL
2836   1498 5E                  LD      E,(HL)          ; Get LSB of address
2837   1499 23                  INC     HL
2838   149A 56                  LD      D,(HL)          ; Get MSB of address
2839   149B 1A                  LD      A,(DE)          ; Get first byte of string
2840   149C C9                  RET
2841   149D             
2842   149D 3E 01       CHR:    LD      A,1             ; One character string
2843   149F CD BA 12            CALL    MKTMST          ; Make a temporary string
2844   14A2 CD 96 15            CALL    MAKINT          ; Make it integer A
2845   14A5 2A E1 21            LD      HL,(TMPSTR+2)   ; Get address of string
2846   14A8 73                  LD      (HL),E          ; Save character
2847   14A9 C1          TOPOOL: POP     BC              ; Clean up stack
2848   14AA C3 EB 12            JP      TSTOPL          ; Temporary string to pool
2849   14AD             
2850   14AD CD 46 15    LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2851   14B0 AF                  XOR     A               ; Start at first byte in string
2852   14B1 E3          RIGHT1: EX      (SP),HL         ; Save code string,Get string
2853   14B2 4F                  LD      C,A             ; Starting position in string
2854   14B3 E5          MID1:   PUSH    HL              ; Save string block address
2855   14B4 7E                  LD      A,(HL)          ; Get length of string
2856   14B5 B8                  CP      B               ; Compare with number given
2857   14B6 DA BB 14            JP      C,ALLFOL        ; All following bytes required
2858   14B9 78                  LD      A,B             ; Get new length
2859   14BA 11                  .BYTE      11H             ; Skip "LD C,0"
2860   14BB 0E 00       ALLFOL: LD      C,0             ; First byte of string
2861   14BD C5                  PUSH    BC              ; Save position in string
2862   14BE CD 24 13            CALL    TESTR           ; See if enough string space
2863   14C1 C1                  POP     BC              ; Get position in string
2864   14C2 E1                  POP     HL              ; Restore string block address
2865   14C3 E5                  PUSH    HL              ; And re-save it
2866   14C4 23                  INC     HL
2867   14C5 23                  INC     HL
2868   14C6 46                  LD      B,(HL)          ; Get LSB of address
2869   14C7 23                  INC     HL
2870   14C8 66                  LD      H,(HL)          ; Get MSB of address
2871   14C9 68                  LD      L,B             ; HL = address of string
2872   14CA 06 00               LD      B,0             ; BC = starting address
2873   14CC 09                  ADD     HL,BC           ; Point to that byte
2874   14CD 44                  LD      B,H             ; BC = source string
2875   14CE 4D                  LD      C,L
2876   14CF CD BD 12            CALL    CRTMST          ; Create a string entry
2877   14D2 6F                  LD      L,A             ; Length of new string
2878   14D3 CD 41 14            CALL    TOSTRA          ; Move string to string area
2879   14D6 D1                  POP     DE              ; Clear stack
2880   14D7 CD 52 14            CALL    GSTRDE          ; Move to string pool if needed
2881   14DA C3 EB 12            JP      TSTOPL          ; Temporary string to pool
2882   14DD             
2883   14DD CD 46 15    RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2884   14E0 D1                  POP     DE              ; Get string length
2885   14E1 D5                  PUSH    DE              ; And re-save
2886   14E2 1A                  LD      A,(DE)          ; Get length
2887   14E3 90                  SUB     B               ; Move back N bytes
2888   14E4 C3 B1 14            JP      RIGHT1          ; Go and get sub-string
2889   14E7             
2890   14E7 EB          MID:    EX      DE,HL           ; Get code string address
2891   14E8 7E                  LD      A,(HL)          ; Get next byte ',' or ")"
2892   14E9 CD 4B 15            CALL    MIDNUM          ; Get number supplied
2893   14EC 04                  INC     B               ; Is it character zero?
2894   14ED 05                  DEC     B
2895   14EE CA 8C 0A            JP      Z,FCERR         ; Yes - Error
2896   14F1 C5                  PUSH    BC              ; Save starting position
2897   14F2 1E FF               LD      E,255           ; All of string
2898   14F4 FE 29               CP      ')'             ; Any length given?
2899   14F6 CA 00 15            JP      Z,RSTSTR        ; No - Rest of string
2900   14F9 CD 3B 08            CALL    CHKSYN          ; Make sure ',' follows
2901   14FC 2C                  .BYTE      ','
2902   14FD CD 93 15            CALL    GETINT          ; Get integer 0-255
2903   1500 CD 3B 08    RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2904   1503 29                  .BYTE      ")"
2905   1504 F1                  POP     AF              ; Restore starting position
2906   1505 E3                  EX      (SP),HL         ; Get string,8ave code string
2907   1506 01 B3 14            LD      BC,MID1         ; Continuation of MID$ routine
2908   1509 C5                  PUSH    BC              ; Save for return
2909   150A 3D                  DEC     A               ; Starting position-1
2910   150B BE                  CP      (HL)            ; Compare with length
2911   150C 06 00               LD      B,0             ; Zero bytes length
2912   150E D0                  RET     NC              ; Null string if start past end
2913   150F 4F                  LD      C,A             ; Save starting position-1
2914   1510 7E                  LD      A,(HL)          ; Get length of string
2915   1511 91                  SUB     C               ; Subtract start
2916   1512 BB                  CP      E               ; Enough string for it?
2917   1513 47                  LD      B,A             ; Save maximum length available
2918   1514 D8                  RET     C               ; Truncate string if needed
2919   1515 43                  LD      B,E             ; Set specified length
2920   1516 C9                  RET                     ; Go and create string
2921   1517             
2922   1517 CD 81 14    VAL:    CALL    GETLEN          ; Get length of string
2923   151A CA 34 16            JP      Z,RESZER        ; Result zero
2924   151D 5F                  LD      E,A             ; Save length
2925   151E 23                  INC     HL
2926   151F 23                  INC     HL
2927   1520 7E                  LD      A,(HL)          ; Get LSB of address
2928   1521 23                  INC     HL
2929   1522 66                  LD      H,(HL)          ; Get MSB of address
2930   1523 6F                  LD      L,A             ; HL = String address
2931   1524 E5                  PUSH    HL              ; Save string address
2932   1525 19                  ADD     HL,DE
2933   1526 46                  LD      B,(HL)          ; Get end of string+1 byte
2934   1527 72                  LD      (HL),D          ; Zero it to terminate
2935   1528 E3                  EX      (SP),HL         ; Save string end,get start
2936   1529 C5                  PUSH    BC              ; Save end+1 byte
2937   152A 7E                  LD      A,(HL)          ; Get starting byte
2938   152B FE 24           CP	'$'		; Hex number indicated? [function added]
2939   152D C2 35 15        JP	NZ,VAL1
2940   1530 CD 5F 1D        CALL	HEXTFP		; Convert Hex to FPREG
2941   1533 18 0D           JR	VAL3
2942   1535 FE 25       VAL1:	CP	'%'		; Binary number indicated? [function added]
2943   1537 C2 3F 15        JP	NZ,VAL2
2944   153A CD CF 1D        CALL	BINTFP		; Convert Bin to FPREG
2945   153D 18 03           JR	VAL3
2946   153F CD 1B 19    VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2947   1542 C1          VAL3:   POP     BC              ; Restore end+1 byte
2948   1543 E1                  POP     HL              ; Restore end+1 address
2949   1544 70                  LD      (HL),B          ; Put back original byte
2950   1545 C9                  RET
2951   1546             
2952   1546 EB          LFRGNM: EX      DE,HL           ; Code string address to HL
2953   1547 CD 3B 08            CALL    CHKSYN          ; Make sure ")" follows
2954   154A 29                  .BYTE      ")"
2955   154B C1          MIDNUM: POP     BC              ; Get return address
2956   154C D1                  POP     DE              ; Get number supplied
2957   154D C5                  PUSH    BC              ; Re-save return address
2958   154E 43                  LD      B,E             ; Number to B
2959   154F C9                  RET
2960   1550             
2961   1550 CD 96 15    INP:    CALL    MAKINT          ; Make it integer A
2962   1553 32 5F 21            LD      (INPORT),A      ; Set input port
2963   1556 CD 5E 21            CALL    INPSUB          ; Get input from port
2964   1559 C3 FC 11            JP      PASSA           ; Return integer A
2965   155C             
2966   155C CD 80 15    POUT:   CALL    SETIO           ; Set up port number
2967   155F C3 26 21            JP      OUTSUB          ; Output data and return
2968   1562             
2969   1562 CD 80 15    WAIT:   CALL    SETIO           ; Set up port number
2970   1565 F5                  PUSH    AF              ; Save AND mask
2971   1566 1E 00               LD      E,0             ; Assume zero if none given
2972   1568 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2973   1569 CD C5 09            CALL    GETCHR          ; Get next character
2974   156C CA 76 15            JP      Z,NOXOR         ; No XOR byte given
2975   156F CD 3B 08            CALL    CHKSYN          ; Make sure ',' follows
2976   1572 2C                  .BYTE      ','
2977   1573 CD 93 15            CALL    GETINT          ; Get integer 0-255 to XOR with
2978   1576 C1          NOXOR:  POP     BC              ; Restore AND mask
2979   1577 CD 5E 21    WAITLP: CALL    INPSUB          ; Get input
2980   157A AB                  XOR     E               ; Flip selected bits
2981   157B A0                  AND     B               ; Result non-zero?
2982   157C CA 77 15            JP      Z,WAITLP        ; No = keep waiting
2983   157F C9                  RET
2984   1580             
2985   1580 CD 93 15    SETIO:  CALL    GETINT          ; Get integer 0-255
2986   1583 32 5F 21            LD      (INPORT),A      ; Set input port
2987   1586 32 27 21            LD      (OTPORT),A      ; Set output port
2988   1589 CD 3B 08            CALL    CHKSYN          ; Make sure ',' follows
2989   158C 2C                  .BYTE      ','
2990   158D C3 93 15            JP      GETINT          ; Get integer 0-255 and return
2991   1590             
2992   1590 CD C5 09    FNDNUM: CALL    GETCHR          ; Get next character
2993   1593 CD 32 0E    GETINT: CALL    GETNUM          ; Get a number from 0 to 255
2994   1596 CD 71 0A    MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
2995   1599 7A                  LD      A,D             ; Get MSB of number
2996   159A B7                  OR      A               ; Zero?
2997   159B C2 8C 0A            JP      NZ,FCERR        ; No - Error
2998   159E 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2999   159F CD C5 09            CALL    GETCHR          ; Get next character
3000   15A2 7B                  LD      A,E             ; Get number to A
3001   15A3 C9                  RET
3002   15A4             
3003   15A4 CD 77 0A    PEEK:   CALL    DEINT           ; Get memory address
3004   15A7 1A                  LD      A,(DE)          ; Get byte in memory
3005   15A8 C3 FC 11            JP      PASSA           ; Return integer A
3006   15AB             
3007   15AB CD 32 0E    POKE:   CALL    GETNUM          ; Get memory address
3008   15AE CD 77 0A            CALL    DEINT           ; Get integer -32768 to 3276
3009   15B1 D5                  PUSH    DE              ; Save memory address
3010   15B2 CD 3B 08            CALL    CHKSYN          ; Make sure ',' follows
3011   15B5 2C                  .BYTE      ','
3012   15B6 CD 93 15            CALL    GETINT          ; Get integer 0-255
3013   15B9 D1                  POP     DE              ; Restore memory address
3014   15BA 12                  LD      (DE),A          ; Load it into memory
3015   15BB C9                  RET
3016   15BC             
3017   15BC 21 92 1A    ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3018   15BF CD 63 18    ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3019   15C2 C3 CE 15            JP      FPADD           ; Add BCDE to FPREG
3020   15C5             
3021   15C5 CD 63 18    SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3022   15C8 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3023   15C9 C1          PSUB:   POP     BC              ; Get FP number from stack
3024   15CA D1                  POP     DE
3025   15CB CD 3D 18    SUBCDE: CALL    INVSGN          ; Negate FPREG
3026   15CE 78          FPADD:  LD      A,B             ; Get FP exponent
3027   15CF B7                  OR      A               ; Is number zero?
3028   15D0 C8                  RET     Z               ; Yes - Nothing to add
3029   15D1 3A 07 22            LD      A,(FPEXP)       ; Get FPREG exponent
3030   15D4 B7                  OR      A               ; Is this number zero?
3031   15D5 CA 55 18            JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3032   15D8 90                  SUB     B               ; BCDE number larger?
3033   15D9 D2 E8 15            JP      NC,NOSWAP       ; No - Don't swap them
3034   15DC 2F                  CPL                     ; Two's complement
3035   15DD 3C                  INC     A               ;  FP exponent
3036   15DE EB                  EX      DE,HL
3037   15DF CD 45 18            CALL    STAKFP          ; Put FPREG on stack
3038   15E2 EB                  EX      DE,HL
3039   15E3 CD 55 18            CALL    FPBCDE          ; Move BCDE to FPREG
3040   15E6 C1                  POP     BC              ; Restore number from stack
3041   15E7 D1                  POP     DE
3042   15E8 FE 19       NOSWAP: CP      24+1            ; Second number insignificant?
3043   15EA D0                  RET     NC              ; Yes - First number is result
3044   15EB F5                  PUSH    AF              ; Save number of bits to scale
3045   15EC CD 7A 18            CALL    SIGNS           ; Set MSBs & sign of result
3046   15EF 67                  LD      H,A             ; Save sign of result
3047   15F0 F1                  POP     AF              ; Restore scaling factor
3048   15F1 CD 93 16            CALL    SCALE           ; Scale BCDE to same exponent
3049   15F4 B4                  OR      H               ; Result to be positive?
3050   15F5 21 04 22            LD      HL,FPREG        ; Point to FPREG
3051   15F8 F2 0E 16            JP      P,MINCDE        ; No - Subtract FPREG from CDE
3052   15FB CD 73 16            CALL    PLUCDE          ; Add FPREG to CDE
3053   15FE D2 54 16            JP      NC,RONDUP       ; No overflow - Round it up
3054   1601 23                  INC     HL              ; Point to exponent
3055   1602 34                  INC     (HL)            ; Increment it
3056   1603 CA 7C 05            JP      Z,OVERR         ; Number overflowed - Error
3057   1606 2E 01               LD      L,1             ; 1 bit to shift right
3058   1608 CD A9 16            CALL    SHRT1           ; Shift result right
3059   160B C3 54 16            JP      RONDUP          ; Round it up
3060   160E             
3061   160E AF          MINCDE: XOR     A               ; Clear A and carry
3062   160F 90                  SUB     B               ; Negate exponent
3063   1610 47                  LD      B,A             ; Re-save exponent
3064   1611 7E                  LD      A,(HL)          ; Get LSB of FPREG
3065   1612 9B                  SBC     A, E            ; Subtract LSB of BCDE
3066   1613 5F                  LD      E,A             ; Save LSB of BCDE
3067   1614 23                  INC     HL
3068   1615 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3069   1616 9A                  SBC     A,D             ; Subtract NMSB of BCDE
3070   1617 57                  LD      D,A             ; Save NMSB of BCDE
3071   1618 23                  INC     HL
3072   1619 7E                  LD      A,(HL)          ; Get MSB of FPREG
3073   161A 99                  SBC     A,C             ; Subtract MSB of BCDE
3074   161B 4F                  LD      C,A             ; Save MSB of BCDE
3075   161C DC 7F 16    CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3076   161F             
3077   161F 68          BNORM:  LD      L,B             ; L = Exponent
3078   1620 63                  LD      H,E             ; H = LSB
3079   1621 AF                  XOR     A
3080   1622 47          BNRMLP: LD      B,A             ; Save bit count
3081   1623 79                  LD      A,C             ; Get MSB
3082   1624 B7                  OR      A               ; Is it zero?
3083   1625 C2 41 16            JP      NZ,PNORM        ; No - Do it bit at a time
3084   1628 4A                  LD      C,D             ; MSB = NMSB
3085   1629 54                  LD      D,H             ; NMSB= LSB
3086   162A 65                  LD      H,L             ; LSB = VLSB
3087   162B 6F                  LD      L,A             ; VLSB= 0
3088   162C 78                  LD      A,B             ; Get exponent
3089   162D D6 08               SUB     8               ; Count 8 bits
3090   162F FE E0               CP      -24-8           ; Was number zero?
3091   1631 C2 22 16            JP      NZ,BNRMLP       ; No - Keep normalising
3092   1634 AF          RESZER: XOR     A               ; Result is zero
3093   1635 32 07 22    SAVEXP: LD      (FPEXP),A       ; Save result as zero
3094   1638 C9                  RET
3095   1639             
3096   1639 05          NORMAL: DEC     B               ; Count bits
3097   163A 29                  ADD     HL,HL           ; Shift HL left
3098   163B 7A                  LD      A,D             ; Get NMSB
3099   163C 17                  RLA                     ; Shift left with last bit
3100   163D 57                  LD      D,A             ; Save NMSB
3101   163E 79                  LD      A,C             ; Get MSB
3102   163F 8F                  ADC     A,A             ; Shift left with last bit
3103   1640 4F                  LD      C,A             ; Save MSB
3104   1641 F2 39 16    PNORM:  JP      P,NORMAL        ; Not done - Keep going
3105   1644 78                  LD      A,B             ; Number of bits shifted
3106   1645 5C                  LD      E,H             ; Save HL in EB
3107   1646 45                  LD      B,L
3108   1647 B7                  OR      A               ; Any shifting done?
3109   1648 CA 54 16            JP      Z,RONDUP        ; No - Round it up
3110   164B 21 07 22            LD      HL,FPEXP        ; Point to exponent
3111   164E 86                  ADD     A,(HL)          ; Add shifted bits
3112   164F 77                  LD      (HL),A          ; Re-save exponent
3113   1650 D2 34 16            JP      NC,RESZER       ; Underflow - Result is zero
3114   1653 C8                  RET     Z               ; Result is zero
3115   1654 78          RONDUP: LD      A,B             ; Get VLSB of number
3116   1655 21 07 22    RONDB:  LD      HL,FPEXP        ; Point to exponent
3117   1658 B7                  OR      A               ; Any rounding?
3118   1659 FC 66 16            CALL    M,FPROND        ; Yes - Round number up
3119   165C 46                  LD      B,(HL)          ; B = Exponent
3120   165D 23                  INC     HL
3121   165E 7E                  LD      A,(HL)          ; Get sign of result
3122   165F E6 80               AND     10000000B       ; Only bit 7 needed
3123   1661 A9                  XOR     C               ; Set correct sign
3124   1662 4F                  LD      C,A             ; Save correct sign in number
3125   1663 C3 55 18            JP      FPBCDE          ; Move BCDE to FPREG
3126   1666             
3127   1666 1C          FPROND: INC     E               ; Round LSB
3128   1667 C0                  RET     NZ              ; Return if ok
3129   1668 14                  INC     D               ; Round NMSB
3130   1669 C0                  RET     NZ              ; Return if ok
3131   166A 0C                  INC     C               ; Round MSB
3132   166B C0                  RET     NZ              ; Return if ok
3133   166C 0E 80               LD      C,80H           ; Set normal value
3134   166E 34                  INC     (HL)            ; Increment exponent
3135   166F C0                  RET     NZ              ; Return if ok
3136   1670 C3 7C 05            JP      OVERR           ; Overflow error
3137   1673             
3138   1673 7E          PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3139   1674 83                  ADD     A,E             ; Add LSB of BCDE
3140   1675 5F                  LD      E,A             ; Save LSB of BCDE
3141   1676 23                  INC     HL
3142   1677 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3143   1678 8A                  ADC     A,D             ; Add NMSB of BCDE
3144   1679 57                  LD      D,A             ; Save NMSB of BCDE
3145   167A 23                  INC     HL
3146   167B 7E                  LD      A,(HL)          ; Get MSB of FPREG
3147   167C 89                  ADC     A,C             ; Add MSB of BCDE
3148   167D 4F                  LD      C,A             ; Save MSB of BCDE
3149   167E C9                  RET
3150   167F             
3151   167F 21 08 22    COMPL:  LD      HL,SGNRES       ; Sign of result
3152   1682 7E                  LD      A,(HL)          ; Get sign of result
3153   1683 2F                  CPL                     ; Negate it
3154   1684 77                  LD      (HL),A          ; Put it back
3155   1685 AF                  XOR     A
3156   1686 6F                  LD      L,A             ; Set L to zero
3157   1687 90                  SUB     B               ; Negate exponent,set carry
3158   1688 47                  LD      B,A             ; Re-save exponent
3159   1689 7D                  LD      A,L             ; Load zero
3160   168A 9B                  SBC     A,E             ; Negate LSB
3161   168B 5F                  LD      E,A             ; Re-save LSB
3162   168C 7D                  LD      A,L             ; Load zero
3163   168D 9A                  SBC     A,D             ; Negate NMSB
3164   168E 57                  LD      D,A             ; Re-save NMSB
3165   168F 7D                  LD      A,L             ; Load zero
3166   1690 99                  SBC     A,C             ; Negate MSB
3167   1691 4F                  LD      C,A             ; Re-save MSB
3168   1692 C9                  RET
3169   1693             
3170   1693 06 00       SCALE:  LD      B,0             ; Clear underflow
3171   1695 D6 08       SCALLP: SUB     8               ; 8 bits (a whole byte)?
3172   1697 DA A2 16            JP      C,SHRITE        ; No - Shift right A bits
3173   169A 43                  LD      B,E             ; <- Shift
3174   169B 5A                  LD      E,D             ; <- right
3175   169C 51                  LD      D,C             ; <- eight
3176   169D 0E 00               LD      C,0             ; <- bits
3177   169F C3 95 16            JP      SCALLP          ; More bits to shift
3178   16A2             
3179   16A2 C6 09       SHRITE: ADD     A,8+1           ; Adjust count
3180   16A4 6F                  LD      L,A             ; Save bits to shift
3181   16A5 AF          SHRLP:  XOR     A               ; Flag for all done
3182   16A6 2D                  DEC     L               ; All shifting done?
3183   16A7 C8                  RET     Z               ; Yes - Return
3184   16A8 79                  LD      A,C             ; Get MSB
3185   16A9 1F          SHRT1:  RRA                     ; Shift it right
3186   16AA 4F                  LD      C,A             ; Re-save
3187   16AB 7A                  LD      A,D             ; Get NMSB
3188   16AC 1F                  RRA                     ; Shift right with last bit
3189   16AD 57                  LD      D,A             ; Re-save it
3190   16AE 7B                  LD      A,E             ; Get LSB
3191   16AF 1F                  RRA                     ; Shift right with last bit
3192   16B0 5F                  LD      E,A             ; Re-save it
3193   16B1 78                  LD      A,B             ; Get underflow
3194   16B2 1F                  RRA                     ; Shift right with last bit
3195   16B3 47                  LD      B,A             ; Re-save underflow
3196   16B4 C3 A5 16            JP      SHRLP           ; More bits to do
3197   16B7             
3198   16B7 00 00 00 81 UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3199   16BB             
3200   16BB 03          LOGTAB: .BYTE      3                       ; Table used by LOG
3201   16BC AA 56 19 80         .BYTE      0AAH,056H,019H,080H     ; 0.59898
3202   16C0 F1 22 76 80         .BYTE      0F1H,022H,076H,080H     ; 0.96147
3203   16C4 45 AA 38 82         .BYTE      045H,0AAH,038H,082H     ; 2.88539
3204   16C8             
3205   16C8 CD 14 18    LOG:    CALL    TSTSGN          ; Test sign of value
3206   16CB B7                  OR      A
3207   16CC EA 8C 0A            JP      PE,FCERR        ; ?FC Error if <= zero
3208   16CF 21 07 22            LD      HL,FPEXP        ; Point to exponent
3209   16D2 7E                  LD      A,(HL)          ; Get exponent
3210   16D3 01 35 80            LD      BC,8035H        ; BCDE = SQR(1/2)
3211   16D6 11 F3 04            LD      DE,04F3H
3212   16D9 90                  SUB     B               ; Scale value to be < 1
3213   16DA F5                  PUSH    AF              ; Save scale factor
3214   16DB 70                  LD      (HL),B          ; Save new exponent
3215   16DC D5                  PUSH    DE              ; Save SQR(1/2)
3216   16DD C5                  PUSH    BC
3217   16DE CD CE 15            CALL    FPADD           ; Add SQR(1/2) to value
3218   16E1 C1                  POP     BC              ; Restore SQR(1/2)
3219   16E2 D1                  POP     DE
3220   16E3 04                  INC     B               ; Make it SQR(2)
3221   16E4 CD 6A 17            CALL    DVBCDE          ; Divide by SQR(2)
3222   16E7 21 B7 16            LD      HL,UNITY        ; Point to 1.
3223   16EA CD C5 15            CALL    SUBPHL          ; Subtract FPREG from 1
3224   16ED 21 BB 16            LD      HL,LOGTAB       ; Coefficient table
3225   16F0 CD 5C 1B            CALL    SUMSER          ; Evaluate sum of series
3226   16F3 01 80 80            LD      BC,8080H        ; BCDE = -0.5
3227   16F6 11 00 00            LD      DE,0000H
3228   16F9 CD CE 15            CALL    FPADD           ; Subtract 0.5 from FPREG
3229   16FC F1                  POP     AF              ; Restore scale factor
3230   16FD CD 8F 19            CALL    RSCALE          ; Re-scale number
3231   1700 01 31 80    MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3232   1703 11 18 72            LD      DE,7218H
3233   1706 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3234   1707             
3235   1707 C1          MULT:   POP     BC              ; Get number from stack
3236   1708 D1                  POP     DE
3237   1709 CD 14 18    FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3238   170C C8                  RET     Z               ; Return zero if zero
3239   170D 2E 00               LD      L,0             ; Flag add exponents
3240   170F CD D2 17            CALL    ADDEXP          ; Add exponents
3241   1712 79                  LD      A,C             ; Get MSB of multiplier
3242   1713 32 16 22            LD      (MULVAL),A      ; Save MSB of multiplier
3243   1716 EB                  EX      DE,HL
3244   1717 22 17 22            LD      (MULVAL+1),HL   ; Save rest of multiplier
3245   171A 01 00 00            LD      BC,0            ; Partial product (BCDE) = zero
3246   171D 50                  LD      D,B
3247   171E 58                  LD      E,B
3248   171F 21 1F 16            LD      HL,BNORM        ; Address of normalise
3249   1722 E5                  PUSH    HL              ; Save for return
3250   1723 21 2B 17            LD      HL,MULT8        ; Address of 8 bit multiply
3251   1726 E5                  PUSH    HL              ; Save for NMSB,MSB
3252   1727 E5                  PUSH    HL              ; 
3253   1728 21 04 22            LD      HL,FPREG        ; Point to number
3254   172B 7E          MULT8:  LD      A,(HL)          ; Get LSB of number
3255   172C 23                  INC     HL              ; Point to NMSB
3256   172D B7                  OR      A               ; Test LSB
3257   172E CA 57 17            JP      Z,BYTSFT        ; Zero - shift to next byte
3258   1731 E5                  PUSH    HL              ; Save address of number
3259   1732 2E 08               LD      L,8             ; 8 bits to multiply by
3260   1734 1F          MUL8LP: RRA                     ; Shift LSB right
3261   1735 67                  LD      H,A             ; Save LSB
3262   1736 79                  LD      A,C             ; Get MSB
3263   1737 D2 45 17            JP      NC,NOMADD       ; Bit was zero - Don't add
3264   173A E5                  PUSH    HL              ; Save LSB and count
3265   173B 2A 17 22            LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3266   173E 19                  ADD     HL,DE           ; Add NMSB and LSB
3267   173F EB                  EX      DE,HL           ; Leave sum in DE
3268   1740 E1                  POP     HL              ; Restore MSB and count
3269   1741 3A 16 22            LD      A,(MULVAL)      ; Get MSB of multiplier
3270   1744 89                  ADC     A,C             ; Add MSB
3271   1745 1F          NOMADD: RRA                     ; Shift MSB right
3272   1746 4F                  LD      C,A             ; Re-save MSB
3273   1747 7A                  LD      A,D             ; Get NMSB
3274   1748 1F                  RRA                     ; Shift NMSB right
3275   1749 57                  LD      D,A             ; Re-save NMSB
3276   174A 7B                  LD      A,E             ; Get LSB
3277   174B 1F                  RRA                     ; Shift LSB right
3278   174C 5F                  LD      E,A             ; Re-save LSB
3279   174D 78                  LD      A,B             ; Get VLSB
3280   174E 1F                  RRA                     ; Shift VLSB right
3281   174F 47                  LD      B,A             ; Re-save VLSB
3282   1750 2D                  DEC     L               ; Count bits multiplied
3283   1751 7C                  LD      A,H             ; Get LSB of multiplier
3284   1752 C2 34 17            JP      NZ,MUL8LP       ; More - Do it
3285   1755 E1          POPHRT: POP     HL              ; Restore address of number
3286   1756 C9                  RET
3287   1757             
3288   1757 43          BYTSFT: LD      B,E             ; Shift partial product left
3289   1758 5A                  LD      E,D
3290   1759 51                  LD      D,C
3291   175A 4F                  LD      C,A
3292   175B C9                  RET
3293   175C             
3294   175C CD 45 18    DIV10:  CALL    STAKFP          ; Save FPREG on stack
3295   175F 01 20 84            LD      BC,8420H        ; BCDE = 10.
3296   1762 11 00 00            LD      DE,0000H
3297   1765 CD 55 18            CALL    FPBCDE          ; Move 10 to FPREG
3298   1768             
3299   1768 C1          DIV:    POP     BC              ; Get number from stack
3300   1769 D1                  POP     DE
3301   176A CD 14 18    DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3302   176D CA 70 05            JP      Z,DZERR         ; Error if division by zero
3303   1770 2E FF               LD      L,-1            ; Flag subtract exponents
3304   1772 CD D2 17            CALL    ADDEXP          ; Subtract exponents
3305   1775 34                  INC     (HL)            ; Add 2 to exponent to adjust
3306   1776 34                  INC     (HL)
3307   1777 2B                  DEC     HL              ; Point to MSB
3308   1778 7E                  LD      A,(HL)          ; Get MSB of dividend
3309   1779 32 32 21            LD      (DIV3),A        ; Save for subtraction
3310   177C 2B                  DEC     HL
3311   177D 7E                  LD      A,(HL)          ; Get NMSB of dividend
3312   177E 32 2E 21            LD      (DIV2),A        ; Save for subtraction
3313   1781 2B                  DEC     HL
3314   1782 7E                  LD      A,(HL)          ; Get MSB of dividend
3315   1783 32 2A 21            LD      (DIV1),A        ; Save for subtraction
3316   1786 41                  LD      B,C             ; Get MSB
3317   1787 EB                  EX      DE,HL           ; NMSB,LSB to HL
3318   1788 AF                  XOR     A
3319   1789 4F                  LD      C,A             ; Clear MSB of quotient
3320   178A 57                  LD      D,A             ; Clear NMSB of quotient
3321   178B 5F                  LD      E,A             ; Clear LSB of quotient
3322   178C 32 35 21            LD      (DIV4),A        ; Clear overflow count
3323   178F E5          DIVLP:  PUSH    HL              ; Save divisor
3324   1790 C5                  PUSH    BC
3325   1791 7D                  LD      A,L             ; Get LSB of number
3326   1792 CD 29 21            CALL    DIVSUP          ; Subt' divisor from dividend
3327   1795 DE 00               SBC     A,0             ; Count for overflows
3328   1797 3F                  CCF
3329   1798 D2 A2 17            JP      NC,RESDIV       ; Restore divisor if borrow
3330   179B 32 35 21            LD      (DIV4),A        ; Re-save overflow count
3331   179E F1                  POP     AF              ; Scrap divisor
3332   179F F1                  POP     AF
3333   17A0 37                  SCF                     ; Set carry to
3334   17A1 D2                  .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3335   17A2             
3336   17A2 C1          RESDIV: POP     BC              ; Restore divisor
3337   17A3 E1                  POP     HL
3338   17A4 79                  LD      A,C             ; Get MSB of quotient
3339   17A5 3C                  INC     A
3340   17A6 3D                  DEC     A
3341   17A7 1F                  RRA                     ; Bit 0 to bit 7
3342   17A8 FA 55 16            JP      M,RONDB         ; Done - Normalise result
3343   17AB 17                  RLA                     ; Restore carry
3344   17AC 7B                  LD      A,E             ; Get LSB of quotient
3345   17AD 17                  RLA                     ; Double it
3346   17AE 5F                  LD      E,A             ; Put it back
3347   17AF 7A                  LD      A,D             ; Get NMSB of quotient
3348   17B0 17                  RLA                     ; Double it
3349   17B1 57                  LD      D,A             ; Put it back
3350   17B2 79                  LD      A,C             ; Get MSB of quotient
3351   17B3 17                  RLA                     ; Double it
3352   17B4 4F                  LD      C,A             ; Put it back
3353   17B5 29                  ADD     HL,HL           ; Double NMSB,LSB of divisor
3354   17B6 78                  LD      A,B             ; Get MSB of divisor
3355   17B7 17                  RLA                     ; Double it
3356   17B8 47                  LD      B,A             ; Put it back
3357   17B9 3A 35 21            LD      A,(DIV4)        ; Get VLSB of quotient
3358   17BC 17                  RLA                     ; Double it
3359   17BD 32 35 21            LD      (DIV4),A        ; Put it back
3360   17C0 79                  LD      A,C             ; Get MSB of quotient
3361   17C1 B2                  OR      D               ; Merge NMSB
3362   17C2 B3                  OR      E               ; Merge LSB
3363   17C3 C2 8F 17            JP      NZ,DIVLP        ; Not done - Keep dividing
3364   17C6 E5                  PUSH    HL              ; Save divisor
3365   17C7 21 07 22            LD      HL,FPEXP        ; Point to exponent
3366   17CA 35                  DEC     (HL)            ; Divide by 2
3367   17CB E1                  POP     HL              ; Restore divisor
3368   17CC C2 8F 17            JP      NZ,DIVLP        ; Ok - Keep going
3369   17CF C3 7C 05            JP      OVERR           ; Overflow error
3370   17D2             
3371   17D2 78          ADDEXP: LD      A,B             ; Get exponent of dividend
3372   17D3 B7                  OR      A               ; Test it
3373   17D4 CA F6 17            JP      Z,OVTST3        ; Zero - Result zero
3374   17D7 7D                  LD      A,L             ; Get add/subtract flag
3375   17D8 21 07 22            LD      HL,FPEXP        ; Point to exponent
3376   17DB AE                  XOR     (HL)            ; Add or subtract it
3377   17DC 80                  ADD     A,B             ; Add the other exponent
3378   17DD 47                  LD      B,A             ; Save new exponent
3379   17DE 1F                  RRA                     ; Test exponent for overflow
3380   17DF A8                  XOR     B
3381   17E0 78                  LD      A,B             ; Get exponent
3382   17E1 F2 F5 17            JP      P,OVTST2        ; Positive - Test for overflow
3383   17E4 C6 80               ADD     A,80H           ; Add excess 128
3384   17E6 77                  LD      (HL),A          ; Save new exponent
3385   17E7 CA 55 17            JP      Z,POPHRT        ; Zero - Result zero
3386   17EA CD 7A 18            CALL    SIGNS           ; Set MSBs and sign of result
3387   17ED 77                  LD      (HL),A          ; Save new exponent
3388   17EE 2B                  DEC     HL              ; Point to MSB
3389   17EF C9                  RET
3390   17F0             
3391   17F0 CD 14 18    OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3392   17F3 2F                  CPL                     ; Invert sign
3393   17F4 E1                  POP     HL              ; Clean up stack
3394   17F5 B7          OVTST2: OR      A               ; Test if new exponent zero
3395   17F6 E1          OVTST3: POP     HL              ; Clear off return address
3396   17F7 F2 34 16            JP      P,RESZER        ; Result zero
3397   17FA C3 7C 05            JP      OVERR           ; Overflow error
3398   17FD             
3399   17FD CD 60 18    MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3400   1800 78                  LD      A,B             ; Get exponent
3401   1801 B7                  OR      A               ; Is it zero?
3402   1802 C8                  RET     Z               ; Yes - Result is zero
3403   1803 C6 02               ADD     A,2             ; Multiply by 4
3404   1805 DA 7C 05            JP      C,OVERR         ; Overflow - ?OV Error
3405   1808 47                  LD      B,A             ; Re-save exponent
3406   1809 CD CE 15            CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3407   180C 21 07 22            LD      HL,FPEXP        ; Point to exponent
3408   180F 34                  INC     (HL)            ; Double number (Times 10)
3409   1810 C0                  RET     NZ              ; Ok - Return
3410   1811 C3 7C 05            JP      OVERR           ; Overflow error
3411   1814             
3412   1814 3A 07 22    TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3413   1817 B7                  OR      A
3414   1818 C8                  RET     Z               ; RETurn if number is zero
3415   1819 3A 06 22            LD      A,(FPREG+2)     ; Get MSB of FPREG
3416   181C FE                  .BYTE      0FEH            ; Test sign
3417   181D 2F          RETREL: CPL                     ; Invert sign
3418   181E 17                  RLA                     ; Sign bit to carry
3419   181F 9F          FLGDIF: SBC     A,A             ; Carry to all bits of A
3420   1820 C0                  RET     NZ              ; Return -1 if negative
3421   1821 3C                  INC     A               ; Bump to +1
3422   1822 C9                  RET                     ; Positive - Return +1
3423   1823             
3424   1823 CD 14 18    SGN:    CALL    TSTSGN          ; Test sign of FPREG
3425   1826 06 88       FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3426   1828 11 00 00            LD      DE,0            ; Zero NMSB and LSB
3427   182B 21 07 22    RETINT: LD      HL,FPEXP        ; Point to exponent
3428   182E 4F                  LD      C,A             ; CDE = MSB,NMSB and LSB
3429   182F 70                  LD      (HL),B          ; Save exponent
3430   1830 06 00               LD      B,0             ; CDE = integer to normalise
3431   1832 23                  INC     HL              ; Point to sign of result
3432   1833 36 80               LD      (HL),80H        ; Set sign of result
3433   1835 17                  RLA                     ; Carry = sign of integer
3434   1836 C3 1C 16            JP      CONPOS          ; Set sign of result
3435   1839             
3436   1839 CD 14 18    ABS:    CALL    TSTSGN          ; Test sign of FPREG
3437   183C F0                  RET     P               ; Return if positive
3438   183D 21 06 22    INVSGN: LD      HL,FPREG+2      ; Point to MSB
3439   1840 7E                  LD      A,(HL)          ; Get sign of mantissa
3440   1841 EE 80               XOR     80H             ; Invert sign of mantissa
3441   1843 77                  LD      (HL),A          ; Re-save sign of mantissa
3442   1844 C9                  RET
3443   1845             
3444   1845 EB          STAKFP: EX      DE,HL           ; Save code string address
3445   1846 2A 04 22            LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3446   1849 E3                  EX      (SP),HL         ; Stack them,get return
3447   184A E5                  PUSH    HL              ; Re-save return
3448   184B 2A 06 22            LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3449   184E E3                  EX      (SP),HL         ; Stack them,get return
3450   184F E5                  PUSH    HL              ; Re-save return
3451   1850 EB                  EX      DE,HL           ; Restore code string address
3452   1851 C9                  RET
3453   1852             
3454   1852 CD 63 18    PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3455   1855 EB          FPBCDE: EX      DE,HL           ; Save code string address
3456   1856 22 04 22            LD      (FPREG),HL      ; Save LSB,NLSB of number
3457   1859 60                  LD      H,B             ; Exponent of number
3458   185A 69                  LD      L,C             ; MSB of number
3459   185B 22 06 22            LD      (FPREG+2),HL    ; Save MSB and exponent
3460   185E EB                  EX      DE,HL           ; Restore code string address
3461   185F C9                  RET
3462   1860             
3463   1860 21 04 22    BCDEFP: LD      HL,FPREG        ; Point to FPREG
3464   1863 5E          LOADFP: LD      E,(HL)          ; Get LSB of number
3465   1864 23                  INC     HL
3466   1865 56                  LD      D,(HL)          ; Get NMSB of number
3467   1866 23                  INC     HL
3468   1867 4E                  LD      C,(HL)          ; Get MSB of number
3469   1868 23                  INC     HL
3470   1869 46                  LD      B,(HL)          ; Get exponent of number
3471   186A 23          INCHL:  INC     HL              ; Used for conditional "INC HL"
3472   186B C9                  RET
3473   186C             
3474   186C 11 04 22    FPTHL:  LD      DE,FPREG        ; Point to FPREG
3475   186F 06 04       DETHL4: LD      B,4             ; 4 bytes to move
3476   1871 1A          DETHLB: LD      A,(DE)          ; Get source
3477   1872 77                  LD      (HL),A          ; Save destination
3478   1873 13                  INC     DE              ; Next source
3479   1874 23                  INC     HL              ; Next destination
3480   1875 05                  DEC     B               ; Count bytes
3481   1876 C2 71 18            JP      NZ,DETHLB       ; Loop if more
3482   1879 C9                  RET
3483   187A             
3484   187A 21 06 22    SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3485   187D 7E                  LD      A,(HL)          ; Get MSB
3486   187E 07                  RLCA                    ; Old sign to carry
3487   187F 37                  SCF                     ; Set MSBit
3488   1880 1F                  RRA                     ; Set MSBit of MSB
3489   1881 77                  LD      (HL),A          ; Save new MSB
3490   1882 3F                  CCF                     ; Complement sign
3491   1883 1F                  RRA                     ; Old sign to carry
3492   1884 23                  INC     HL
3493   1885 23                  INC     HL
3494   1886 77                  LD      (HL),A          ; Set sign of result
3495   1887 79                  LD      A,C             ; Get MSB
3496   1888 07                  RLCA                    ; Old sign to carry
3497   1889 37                  SCF                     ; Set MSBit
3498   188A 1F                  RRA                     ; Set MSBit of MSB
3499   188B 4F                  LD      C,A             ; Save MSB
3500   188C 1F                  RRA
3501   188D AE                  XOR     (HL)            ; New sign of result
3502   188E C9                  RET
3503   188F             
3504   188F 78          CMPNUM: LD      A,B             ; Get exponent of number
3505   1890 B7                  OR      A
3506   1891 CA 14 18            JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3507   1894 21 1D 18            LD      HL,RETREL       ; Return relation routine
3508   1897 E5                  PUSH    HL              ; Save for return
3509   1898 CD 14 18            CALL    TSTSGN          ; Test sign of FPREG
3510   189B 79                  LD      A,C             ; Get MSB of number
3511   189C C8                  RET     Z               ; FPREG zero - Number's MSB
3512   189D 21 06 22            LD      HL,FPREG+2      ; MSB of FPREG
3513   18A0 AE                  XOR     (HL)            ; Combine signs
3514   18A1 79                  LD      A,C             ; Get MSB of number
3515   18A2 F8                  RET     M               ; Exit if signs different
3516   18A3 CD A9 18            CALL    CMPFP           ; Compare FP numbers
3517   18A6 1F                  RRA                     ; Get carry to sign
3518   18A7 A9                  XOR     C               ; Combine with MSB of number
3519   18A8 C9                  RET
3520   18A9             
3521   18A9 23          CMPFP:  INC     HL              ; Point to exponent
3522   18AA 78                  LD      A,B             ; Get exponent
3523   18AB BE                  CP      (HL)            ; Compare exponents
3524   18AC C0                  RET     NZ              ; Different
3525   18AD 2B                  DEC     HL              ; Point to MBS
3526   18AE 79                  LD      A,C             ; Get MSB
3527   18AF BE                  CP      (HL)            ; Compare MSBs
3528   18B0 C0                  RET     NZ              ; Different
3529   18B1 2B                  DEC     HL              ; Point to NMSB
3530   18B2 7A                  LD      A,D             ; Get NMSB
3531   18B3 BE                  CP      (HL)            ; Compare NMSBs
3532   18B4 C0                  RET     NZ              ; Different
3533   18B5 2B                  DEC     HL              ; Point to LSB
3534   18B6 7B                  LD      A,E             ; Get LSB
3535   18B7 96                  SUB     (HL)            ; Compare LSBs
3536   18B8 C0                  RET     NZ              ; Different
3537   18B9 E1                  POP     HL              ; Drop RETurn
3538   18BA E1                  POP     HL              ; Drop another RETurn
3539   18BB C9                  RET
3540   18BC             
3541   18BC 47          FPINT:  LD      B,A             ; <- Move
3542   18BD 4F                  LD      C,A             ; <- exponent
3543   18BE 57                  LD      D,A             ; <- to all
3544   18BF 5F                  LD      E,A             ; <- bits
3545   18C0 B7                  OR      A               ; Test exponent
3546   18C1 C8                  RET     Z               ; Zero - Return zero
3547   18C2 E5                  PUSH    HL              ; Save pointer to number
3548   18C3 CD 60 18            CALL    BCDEFP          ; Move FPREG to BCDE
3549   18C6 CD 7A 18            CALL    SIGNS           ; Set MSBs & sign of result
3550   18C9 AE                  XOR     (HL)            ; Combine with sign of FPREG
3551   18CA 67                  LD      H,A             ; Save combined signs
3552   18CB FC E0 18            CALL    M,DCBCDE        ; Negative - Decrement BCDE
3553   18CE 3E 98               LD      A,80H+24        ; 24 bits
3554   18D0 90                  SUB     B               ; Bits to shift
3555   18D1 CD 93 16            CALL    SCALE           ; Shift BCDE
3556   18D4 7C                  LD      A,H             ; Get combined sign
3557   18D5 17                  RLA                     ; Sign to carry
3558   18D6 DC 66 16            CALL    C,FPROND        ; Negative - Round number up
3559   18D9 06 00               LD      B,0             ; Zero exponent
3560   18DB DC 7F 16            CALL    C,COMPL         ; If negative make positive
3561   18DE E1                  POP     HL              ; Restore pointer to number
3562   18DF C9                  RET
3563   18E0             
3564   18E0 1B          DCBCDE: DEC     DE              ; Decrement BCDE
3565   18E1 7A                  LD      A,D             ; Test LSBs
3566   18E2 A3                  AND     E
3567   18E3 3C                  INC     A
3568   18E4 C0                  RET     NZ              ; Exit if LSBs not FFFF
3569   18E5 0B                  DEC     BC              ; Decrement MSBs
3570   18E6 C9                  RET
3571   18E7             
3572   18E7 21 07 22    INT:    LD      HL,FPEXP        ; Point to exponent
3573   18EA 7E                  LD      A,(HL)          ; Get exponent
3574   18EB FE 98               CP      80H+24          ; Integer accuracy only?
3575   18ED 3A 04 22            LD      A,(FPREG)       ; Get LSB
3576   18F0 D0                  RET     NC              ; Yes - Already integer
3577   18F1 7E                  LD      A,(HL)          ; Get exponent
3578   18F2 CD BC 18            CALL    FPINT           ; F.P to integer
3579   18F5 36 98               LD      (HL),80H+24     ; Save 24 bit integer
3580   18F7 7B                  LD      A,E             ; Get LSB of number
3581   18F8 F5                  PUSH    AF              ; Save LSB
3582   18F9 79                  LD      A,C             ; Get MSB of number
3583   18FA 17                  RLA                     ; Sign to carry
3584   18FB CD 1C 16            CALL    CONPOS          ; Set sign of result
3585   18FE F1                  POP     AF              ; Restore LSB of number
3586   18FF C9                  RET
3587   1900             
3588   1900 21 00 00    MLDEBC: LD      HL,0            ; Clear partial product
3589   1903 78                  LD      A,B             ; Test multiplier
3590   1904 B1                  OR      C
3591   1905 C8                  RET     Z               ; Return zero if zero
3592   1906 3E 10               LD      A,16            ; 16 bits
3593   1908 29          MLDBLP: ADD     HL,HL           ; Shift P.P left
3594   1909 DA 40 11            JP      C,BSERR         ; ?BS Error if overflow
3595   190C EB                  EX      DE,HL
3596   190D 29                  ADD     HL,HL           ; Shift multiplier left
3597   190E EB                  EX      DE,HL
3598   190F D2 16 19            JP      NC,NOMLAD       ; Bit was zero - No add
3599   1912 09                  ADD     HL,BC           ; Add multiplicand
3600   1913 DA 40 11            JP      C,BSERR         ; ?BS Error if overflow
3601   1916 3D          NOMLAD: DEC     A               ; Count bits
3602   1917 C2 08 19            JP      NZ,MLDBLP       ; More
3603   191A C9                  RET
3604   191B             
3605   191B FE 2D       ASCTFP: CP      '-'             ; Negative?
3606   191D F5                  PUSH    AF              ; Save it and flags
3607   191E CA 27 19            JP      Z,CNVNUM        ; Yes - Convert number
3608   1921 FE 2B               CP      '+'             ; Positive?
3609   1923 CA 27 19            JP      Z,CNVNUM        ; Yes - Convert number
3610   1926 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3611   1927 CD 34 16    CNVNUM: CALL    RESZER          ; Set result to zero
3612   192A 47                  LD      B,A             ; Digits after point counter
3613   192B 57                  LD      D,A             ; Sign of exponent
3614   192C 5F                  LD      E,A             ; Exponent of ten
3615   192D 2F                  CPL
3616   192E 4F                  LD      C,A             ; Before or after point flag
3617   192F CD C5 09    MANLP:  CALL    GETCHR          ; Get next character
3618   1932 DA 78 19            JP      C,ADDIG         ; Digit - Add to number
3619   1935 FE 2E               CP      '.'
3620   1937 CA 53 19            JP      Z,DPOINT        ; '.' - Flag point
3621   193A FE 45               CP      'E'
3622   193C C2 57 19            JP      NZ,CONEXP       ; Not 'E' - Scale number
3623   193F CD C5 09            CALL    GETCHR          ; Get next character
3624   1942 CD 6B 0F            CALL    SGNEXP          ; Get sign of exponent
3625   1945 CD C5 09    EXPLP:  CALL    GETCHR          ; Get next character
3626   1948 DA 9A 19            JP      C,EDIGIT        ; Digit - Add to exponent
3627   194B 14                  INC     D               ; Is sign negative?
3628   194C C2 57 19            JP      NZ,CONEXP       ; No - Scale number
3629   194F AF                  XOR     A
3630   1950 93                  SUB     E               ; Negate exponent
3631   1951 5F                  LD      E,A             ; And re-save it
3632   1952 0C                  INC     C               ; Flag end of number
3633   1953 0C          DPOINT: INC     C               ; Flag point passed
3634   1954 CA 2F 19            JP      Z,MANLP         ; Zero - Get another digit
3635   1957 E5          CONEXP: PUSH    HL              ; Save code string address
3636   1958 7B                  LD      A,E             ; Get exponent
3637   1959 90                  SUB     B               ; Subtract digits after point
3638   195A F4 70 19    SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3639   195D F2 66 19            JP      P,ENDCON        ; Positive - All done
3640   1960 F5                  PUSH    AF              ; Save number of times to /10
3641   1961 CD 5C 17            CALL    DIV10           ; Divide by 10
3642   1964 F1                  POP     AF              ; Restore count
3643   1965 3C                  INC     A               ; Count divides
3644   1966             
3645   1966 C2 5A 19    ENDCON: JP      NZ,SCALMI       ; More to do
3646   1969 D1                  POP     DE              ; Restore code string address
3647   196A F1                  POP     AF              ; Restore sign of number
3648   196B CC 3D 18            CALL    Z,INVSGN        ; Negative - Negate number
3649   196E EB                  EX      DE,HL           ; Code string address to HL
3650   196F C9                  RET
3651   1970             
3652   1970 C8          SCALPL: RET     Z               ; Exit if no scaling needed
3653   1971 F5          MULTEN: PUSH    AF              ; Save count
3654   1972 CD FD 17            CALL    MLSP10          ; Multiply number by 10
3655   1975 F1                  POP     AF              ; Restore count
3656   1976 3D                  DEC     A               ; Count multiplies
3657   1977 C9                  RET
3658   1978             
3659   1978 D5          ADDIG:  PUSH    DE              ; Save sign of exponent
3660   1979 57                  LD      D,A             ; Save digit
3661   197A 78                  LD      A,B             ; Get digits after point
3662   197B 89                  ADC     A,C             ; Add one if after point
3663   197C 47                  LD      B,A             ; Re-save counter
3664   197D C5                  PUSH    BC              ; Save point flags
3665   197E E5                  PUSH    HL              ; Save code string address
3666   197F D5                  PUSH    DE              ; Save digit
3667   1980 CD FD 17            CALL    MLSP10          ; Multiply number by 10
3668   1983 F1                  POP     AF              ; Restore digit
3669   1984 D6 30               SUB     '0'             ; Make it absolute
3670   1986 CD 8F 19            CALL    RSCALE          ; Re-scale number
3671   1989 E1                  POP     HL              ; Restore code string address
3672   198A C1                  POP     BC              ; Restore point flags
3673   198B D1                  POP     DE              ; Restore sign of exponent
3674   198C C3 2F 19            JP      MANLP           ; Get another digit
3675   198F             
3676   198F CD 45 18    RSCALE: CALL    STAKFP          ; Put number on stack
3677   1992 CD 26 18            CALL    FLGREL          ; Digit to add to FPREG
3678   1995 C1          PADD:   POP     BC              ; Restore number
3679   1996 D1                  POP     DE
3680   1997 C3 CE 15            JP      FPADD           ; Add BCDE to FPREG and return
3681   199A             
3682   199A 7B          EDIGIT: LD      A,E             ; Get digit
3683   199B 07                  RLCA                    ; Times 2
3684   199C 07                  RLCA                    ; Times 4
3685   199D 83                  ADD     A,E             ; Times 5
3686   199E 07                  RLCA                    ; Times 10
3687   199F 86                  ADD     A,(HL)          ; Add next digit
3688   19A0 D6 30               SUB     '0'             ; Make it absolute
3689   19A2 5F                  LD      E,A             ; Save new digit
3690   19A3 C3 45 19            JP      EXPLP           ; Look for another digit
3691   19A6             
3692   19A6 E5          LINEIN: PUSH    HL              ; Save code string address
3693   19A7 21 05 05            LD      HL,INMSG        ; Output " in "
3694   19AA CD 0B 13            CALL    PRS             ; Output string at HL
3695   19AD E1                  POP     HL              ; Restore code string address
3696   19AE EB          PRNTHL: EX      DE,HL           ; Code string address to DE
3697   19AF AF                  XOR     A
3698   19B0 06 98               LD      B,80H+24        ; 24 bits
3699   19B2 CD 2B 18            CALL    RETINT          ; Return the integer
3700   19B5 21 0A 13            LD      HL,PRNUMS       ; Print number string
3701   19B8 E5                  PUSH    HL              ; Save for return
3702   19B9 21 09 22    NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3703   19BC E5                  PUSH    HL              ; Save for return
3704   19BD CD 14 18            CALL    TSTSGN          ; Test sign of FPREG
3705   19C0 36 20               LD      (HL),' '        ; Space at start
3706   19C2 F2 C7 19            JP      P,SPCFST        ; Positive - Space to start
3707   19C5 36 2D               LD      (HL),'-'        ; '-' sign at start
3708   19C7 23          SPCFST: INC     HL              ; First byte of number
3709   19C8 36 30               LD      (HL),'0'        ; '0' if zero
3710   19CA CA 7D 1A            JP      Z,JSTZER        ; Return '0' if zero
3711   19CD E5                  PUSH    HL              ; Save buffer address
3712   19CE FC 3D 18            CALL    M,INVSGN        ; Negate FPREG if negative
3713   19D1 AF                  XOR     A               ; Zero A
3714   19D2 F5                  PUSH    AF              ; Save it
3715   19D3 CD 83 1A            CALL    RNGTST          ; Test number is in range
3716   19D6 01 43 91    SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3717   19D9 11 F8 4F            LD      DE,4FF8H
3718   19DC CD 8F 18            CALL    CMPNUM          ; Compare numbers
3719   19DF B7                  OR      A
3720   19E0 E2 F4 19            JP      PO,INRNG        ; > 99999.9 - Sort it out
3721   19E3 F1                  POP     AF              ; Restore count
3722   19E4 CD 71 19            CALL    MULTEN          ; Multiply by ten
3723   19E7 F5                  PUSH    AF              ; Re-save count
3724   19E8 C3 D6 19            JP      SIXDIG          ; Test it again
3725   19EB             
3726   19EB CD 5C 17    GTSIXD: CALL    DIV10           ; Divide by 10
3727   19EE F1                  POP     AF              ; Get count
3728   19EF 3C                  INC     A               ; Count divides
3729   19F0 F5                  PUSH    AF              ; Re-save count
3730   19F1 CD 83 1A            CALL    RNGTST          ; Test number is in range
3731   19F4 CD BC 15    INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3732   19F7 3C                  INC     A
3733   19F8 CD BC 18            CALL    FPINT           ; F.P to integer
3734   19FB CD 55 18            CALL    FPBCDE          ; Move BCDE to FPREG
3735   19FE 01 06 03            LD      BC,0306H        ; 1E+06 to 1E-03 range
3736   1A01 F1                  POP     AF              ; Restore count
3737   1A02 81                  ADD     A,C             ; 6 digits before point
3738   1A03 3C                  INC     A               ; Add one
3739   1A04 FA 10 1A            JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3740   1A07 FE 08               CP      6+1+1           ; More than 999999 ?
3741   1A09 D2 10 1A            JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3742   1A0C 3C                  INC     A               ; Adjust for exponent
3743   1A0D 47                  LD      B,A             ; Exponent of number
3744   1A0E 3E 02               LD      A,2             ; Make it zero after
3745   1A10             
3746   1A10 3D          MAKNUM: DEC     A               ; Adjust for digits to do
3747   1A11 3D                  DEC     A
3748   1A12 E1                  POP     HL              ; Restore buffer address
3749   1A13 F5                  PUSH    AF              ; Save count
3750   1A14 11 96 1A            LD      DE,POWERS       ; Powers of ten
3751   1A17 05                  DEC     B               ; Count digits before point
3752   1A18 C2 21 1A            JP      NZ,DIGTXT       ; Not zero - Do number
3753   1A1B 36 2E               LD      (HL),'.'        ; Save point
3754   1A1D 23                  INC     HL              ; Move on
3755   1A1E 36 30               LD      (HL),'0'        ; Save zero
3756   1A20 23                  INC     HL              ; Move on
3757   1A21 05          DIGTXT: DEC     B               ; Count digits before point
3758   1A22 36 2E               LD      (HL),'.'        ; Save point in case
3759   1A24 CC 6A 18            CALL    Z,INCHL         ; Last digit - move on
3760   1A27 C5                  PUSH    BC              ; Save digits before point
3761   1A28 E5                  PUSH    HL              ; Save buffer address
3762   1A29 D5                  PUSH    DE              ; Save powers of ten
3763   1A2A CD 60 18            CALL    BCDEFP          ; Move FPREG to BCDE
3764   1A2D E1                  POP     HL              ; Powers of ten table
3765   1A2E 06 2F               LD      B, '0'-1        ; ASCII '0' - 1
3766   1A30 04          TRYAGN: INC     B               ; Count subtractions
3767   1A31 7B                  LD      A,E             ; Get LSB
3768   1A32 96                  SUB     (HL)            ; Subtract LSB
3769   1A33 5F                  LD      E,A             ; Save LSB
3770   1A34 23                  INC     HL
3771   1A35 7A                  LD      A,D             ; Get NMSB
3772   1A36 9E                  SBC     A,(HL)          ; Subtract NMSB
3773   1A37 57                  LD      D,A             ; Save NMSB
3774   1A38 23                  INC     HL
3775   1A39 79                  LD      A,C             ; Get MSB
3776   1A3A 9E                  SBC     A,(HL)          ; Subtract MSB
3777   1A3B 4F                  LD      C,A             ; Save MSB
3778   1A3C 2B                  DEC     HL              ; Point back to start
3779   1A3D 2B                  DEC     HL
3780   1A3E D2 30 1A            JP      NC,TRYAGN       ; No overflow - Try again
3781   1A41 CD 73 16            CALL    PLUCDE          ; Restore number
3782   1A44 23                  INC     HL              ; Start of next number
3783   1A45 CD 55 18            CALL    FPBCDE          ; Move BCDE to FPREG
3784   1A48 EB                  EX      DE,HL           ; Save point in table
3785   1A49 E1                  POP     HL              ; Restore buffer address
3786   1A4A 70                  LD      (HL),B          ; Save digit in buffer
3787   1A4B 23                  INC     HL              ; And move on
3788   1A4C C1                  POP     BC              ; Restore digit count
3789   1A4D 0D                  DEC     C               ; Count digits
3790   1A4E C2 21 1A            JP      NZ,DIGTXT       ; More - Do them
3791   1A51 05                  DEC     B               ; Any decimal part?
3792   1A52 CA 61 1A            JP      Z,DOEBIT        ; No - Do 'E' bit
3793   1A55 2B          SUPTLZ: DEC     HL              ; Move back through buffer
3794   1A56 7E                  LD      A,(HL)          ; Get character
3795   1A57 FE 30               CP      '0'             ; '0' character?
3796   1A59 CA 55 1A            JP      Z,SUPTLZ        ; Yes - Look back for more
3797   1A5C FE 2E               CP      '.'             ; A decimal point?
3798   1A5E C4 6A 18            CALL    NZ,INCHL        ; Move back over digit
3799   1A61             
3800   1A61 F1          DOEBIT: POP     AF              ; Get 'E' flag
3801   1A62 CA 80 1A            JP      Z,NOENED        ; No 'E' needed - End buffer
3802   1A65 36 45               LD      (HL),'E'        ; Put 'E' in buffer
3803   1A67 23                  INC     HL              ; And move on
3804   1A68 36 2B               LD      (HL),'+'        ; Put '+' in buffer
3805   1A6A F2 71 1A            JP      P,OUTEXP        ; Positive - Output exponent
3806   1A6D 36 2D               LD      (HL),'-'        ; Put '-' in buffer
3807   1A6F 2F                  CPL                     ; Negate exponent
3808   1A70 3C                  INC     A
3809   1A71 06 2F       OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3810   1A73 04          EXPTEN: INC     B               ; Count subtractions
3811   1A74 D6 0A               SUB     10              ; Tens digit
3812   1A76 D2 73 1A            JP      NC,EXPTEN       ; More to do
3813   1A79 C6 3A               ADD     A,'0'+10        ; Restore and make ASCII
3814   1A7B 23                  INC     HL              ; Move on
3815   1A7C 70                  LD      (HL),B          ; Save MSB of exponent
3816   1A7D 23          JSTZER: INC     HL              ;
3817   1A7E 77                  LD      (HL),A          ; Save LSB of exponent
3818   1A7F 23                  INC     HL
3819   1A80 71          NOENED: LD      (HL),C          ; Mark end of buffer
3820   1A81 E1                  POP     HL              ; Restore code string address
3821   1A82 C9                  RET
3822   1A83             
3823   1A83 01 74 94    RNGTST: LD      BC,9474H        ; BCDE = 999999.
3824   1A86 11 F7 23            LD      DE,23F7H
3825   1A89 CD 8F 18            CALL    CMPNUM          ; Compare numbers
3826   1A8C B7                  OR      A
3827   1A8D E1                  POP     HL              ; Return address to HL
3828   1A8E E2 EB 19            JP      PO,GTSIXD       ; Too big - Divide by ten
3829   1A91 E9                  JP      (HL)            ; Otherwise return to caller
3830   1A92             
3831   1A92 00 00 00 80 HALF:   .BYTE      00H,00H,00H,80H ; 0.5
3832   1A96             
3833   1A96 A0 86 01    POWERS: .BYTE      0A0H,086H,001H  ; 100000
3834   1A99 10 27 00            .BYTE      010H,027H,000H  ;  10000
3835   1A9C E8 03 00            .BYTE      0E8H,003H,000H  ;   1000
3836   1A9F 64 00 00            .BYTE      064H,000H,000H  ;    100
3837   1AA2 0A 00 00            .BYTE      00AH,000H,000H  ;     10
3838   1AA5 01 00 00            .BYTE      001H,000H,000H  ;      1
3839   1AA8             
3840   1AA8 21 3D 18    NEGAFT: LD  HL,INVSGN           ; Negate result
3841   1AAB E3                  EX      (SP),HL         ; To be done after caller
3842   1AAC E9                  JP      (HL)            ; Return to caller
3843   1AAD             
3844   1AAD CD 45 18    SQR:    CALL    STAKFP          ; Put value on stack
3845   1AB0 21 92 1A            LD      HL,HALF         ; Set power to 1/2
3846   1AB3 CD 52 18            CALL    PHLTFP          ; Move 1/2 to FPREG
3847   1AB6             
3848   1AB6 C1          POWER:  POP     BC              ; Get base
3849   1AB7 D1                  POP     DE
3850   1AB8 CD 14 18            CALL    TSTSGN          ; Test sign of power
3851   1ABB 78                  LD      A,B             ; Get exponent of base
3852   1ABC CA FB 1A            JP      Z,EXP           ; Make result 1 if zero
3853   1ABF F2 C6 1A            JP      P,POWER1        ; Positive base - Ok
3854   1AC2 B7                  OR      A               ; Zero to negative power?
3855   1AC3 CA 70 05            JP      Z,DZERR         ; Yes - ?/0 Error
3856   1AC6 B7          POWER1: OR      A               ; Base zero?
3857   1AC7 CA 35 16            JP      Z,SAVEXP        ; Yes - Return zero
3858   1ACA D5                  PUSH    DE              ; Save base
3859   1ACB C5                  PUSH    BC
3860   1ACC 79                  LD      A,C             ; Get MSB of base
3861   1ACD F6 7F               OR      01111111B       ; Get sign status
3862   1ACF CD 60 18            CALL    BCDEFP          ; Move power to BCDE
3863   1AD2 F2 E3 1A            JP      P,POWER2        ; Positive base - Ok
3864   1AD5 D5                  PUSH    DE              ; Save power
3865   1AD6 C5                  PUSH    BC
3866   1AD7 CD E7 18            CALL    INT             ; Get integer of power
3867   1ADA C1                  POP     BC              ; Restore power
3868   1ADB D1                  POP     DE
3869   1ADC F5                  PUSH    AF              ; MSB of base
3870   1ADD CD 8F 18            CALL    CMPNUM          ; Power an integer?
3871   1AE0 E1                  POP     HL              ; Restore MSB of base
3872   1AE1 7C                  LD      A,H             ; but don't affect flags
3873   1AE2 1F                  RRA                     ; Exponent odd or even?
3874   1AE3 E1          POWER2: POP     HL              ; Restore MSB and exponent
3875   1AE4 22 06 22            LD      (FPREG+2),HL    ; Save base in FPREG
3876   1AE7 E1                  POP     HL              ; LSBs of base
3877   1AE8 22 04 22            LD      (FPREG),HL      ; Save in FPREG
3878   1AEB DC A8 1A            CALL    C,NEGAFT        ; Odd power - Negate result
3879   1AEE CC 3D 18            CALL    Z,INVSGN        ; Negative base - Negate it
3880   1AF1 D5                  PUSH    DE              ; Save power
3881   1AF2 C5                  PUSH    BC
3882   1AF3 CD C8 16            CALL    LOG             ; Get LOG of base
3883   1AF6 C1                  POP     BC              ; Restore power
3884   1AF7 D1                  POP     DE
3885   1AF8 CD 09 17            CALL    FPMULT          ; Multiply LOG by power
3886   1AFB             
3887   1AFB CD 45 18    EXP:    CALL    STAKFP          ; Put value on stack
3888   1AFE 01 38 81            LD      BC,08138H       ; BCDE = 1/Ln(2)
3889   1B01 11 3B AA            LD      DE,0AA3BH
3890   1B04 CD 09 17            CALL    FPMULT          ; Multiply value by 1/LN(2)
3891   1B07 3A 07 22            LD      A,(FPEXP)       ; Get exponent
3892   1B0A FE 88               CP      80H+8           ; Is it in range?
3893   1B0C D2 F0 17            JP      NC,OVTST1       ; No - Test for overflow
3894   1B0F CD E7 18            CALL    INT             ; Get INT of FPREG
3895   1B12 C6 80               ADD     A,80H           ; For excess 128
3896   1B14 C6 02               ADD     A,2             ; Exponent > 126?
3897   1B16 DA F0 17            JP      C,OVTST1        ; Yes - Test for overflow
3898   1B19 F5                  PUSH    AF              ; Save scaling factor
3899   1B1A 21 B7 16            LD      HL,UNITY        ; Point to 1.
3900   1B1D CD BF 15            CALL    ADDPHL          ; Add 1 to FPREG
3901   1B20 CD 00 17            CALL    MULLN2          ; Multiply by LN(2)
3902   1B23 F1                  POP     AF              ; Restore scaling factor
3903   1B24 C1                  POP     BC              ; Restore exponent
3904   1B25 D1                  POP     DE
3905   1B26 F5                  PUSH    AF              ; Save scaling factor
3906   1B27 CD CB 15            CALL    SUBCDE          ; Subtract exponent from FPREG
3907   1B2A CD 3D 18            CALL    INVSGN          ; Negate result
3908   1B2D 21 3B 1B            LD      HL,EXPTAB       ; Coefficient table
3909   1B30 CD 6B 1B            CALL    SMSER1          ; Sum the series
3910   1B33 11 00 00            LD      DE,0            ; Zero LSBs
3911   1B36 C1                  POP     BC              ; Scaling factor
3912   1B37 4A                  LD      C,D             ; Zero MSB
3913   1B38 C3 09 17            JP      FPMULT          ; Scale result to correct value
3914   1B3B             
3915   1B3B 08          EXPTAB: .BYTE      8                       ; Table used by EXP
3916   1B3C 40 2E 94 74         .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3917   1B40 70 4F 2E 77         .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3918   1B44 6E 02 88 7A         .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
3919   1B48 E6 A0 2A 7C         .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3920   1B4C 50 AA AA 7E         .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3921   1B50 FF FF 7F 7F         .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3922   1B54 00 00 80 81         .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
3923   1B58 00 00 00 81         .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
3924   1B5C             
3925   1B5C CD 45 18    SUMSER: CALL    STAKFP          ; Put FPREG on stack
3926   1B5F 11 07 17            LD      DE,MULT         ; Multiply by "X"
3927   1B62 D5                  PUSH    DE              ; To be done after
3928   1B63 E5                  PUSH    HL              ; Save address of table
3929   1B64 CD 60 18            CALL    BCDEFP          ; Move FPREG to BCDE
3930   1B67 CD 09 17            CALL    FPMULT          ; Square the value
3931   1B6A E1                  POP     HL              ; Restore address of table
3932   1B6B CD 45 18    SMSER1: CALL    STAKFP          ; Put value on stack
3933   1B6E 7E                  LD      A,(HL)          ; Get number of coefficients
3934   1B6F 23                  INC     HL              ; Point to start of table
3935   1B70 CD 52 18            CALL    PHLTFP          ; Move coefficient to FPREG
3936   1B73 06                  .BYTE      06H             ; Skip "POP AF"
3937   1B74 F1          SUMLP:  POP     AF              ; Restore count
3938   1B75 C1                  POP     BC              ; Restore number
3939   1B76 D1                  POP     DE
3940   1B77 3D                  DEC     A               ; Cont coefficients
3941   1B78 C8                  RET     Z               ; All done
3942   1B79 D5                  PUSH    DE              ; Save number
3943   1B7A C5                  PUSH    BC
3944   1B7B F5                  PUSH    AF              ; Save count
3945   1B7C E5                  PUSH    HL              ; Save address in table
3946   1B7D CD 09 17            CALL    FPMULT          ; Multiply FPREG by BCDE
3947   1B80 E1                  POP     HL              ; Restore address in table
3948   1B81 CD 63 18            CALL    LOADFP          ; Number at HL to BCDE
3949   1B84 E5                  PUSH    HL              ; Save address in table
3950   1B85 CD CE 15            CALL    FPADD           ; Add coefficient to FPREG
3951   1B88 E1                  POP     HL              ; Restore address in table
3952   1B89 C3 74 1B            JP      SUMLP           ; More coefficients
3953   1B8C             
3954   1B8C CD 14 18    RND:    CALL    TSTSGN          ; Test sign of FPREG
3955   1B8F 21 39 21            LD      HL,SEED+2       ; Random number seed
3956   1B92 FA ED 1B            JP      M,RESEED        ; Negative - Re-seed
3957   1B95 21 5A 21            LD      HL,LSTRND       ; Last random number
3958   1B98 CD 52 18            CALL    PHLTFP          ; Move last RND to FPREG
3959   1B9B 21 39 21            LD      HL,SEED+2       ; Random number seed
3960   1B9E C8                  RET     Z               ; Return if RND(0)
3961   1B9F 86                  ADD     A,(HL)          ; Add (SEED)+2)
3962   1BA0 E6 07               AND     00000111B       ; 0 to 7
3963   1BA2 06 00               LD      B,0
3964   1BA4 77                  LD      (HL),A          ; Re-save seed
3965   1BA5 23                  INC     HL              ; Move to coefficient table
3966   1BA6 87                  ADD     A,A             ; 4 bytes
3967   1BA7 87                  ADD     A,A             ; per entry
3968   1BA8 4F                  LD      C,A             ; BC = Offset into table
3969   1BA9 09                  ADD     HL,BC           ; Point to coefficient
3970   1BAA CD 63 18            CALL    LOADFP          ; Coefficient to BCDE
3971   1BAD CD 09 17            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3972   1BB0 3A 38 21            LD      A,(SEED+1)      ; Get (SEED+1)
3973   1BB3 3C                  INC     A               ; Add 1
3974   1BB4 E6 03               AND     00000011B       ; 0 to 3
3975   1BB6 06 00               LD      B,0
3976   1BB8 FE 01               CP      1               ; Is it zero?
3977   1BBA 88                  ADC     A,B             ; Yes - Make it 1
3978   1BBB 32 38 21            LD      (SEED+1),A      ; Re-save seed
3979   1BBE 21 F1 1B            LD      HL,RNDTAB-4     ; Addition table
3980   1BC1 87                  ADD     A,A             ; 4 bytes
3981   1BC2 87                  ADD     A,A             ; per entry
3982   1BC3 4F                  LD      C,A             ; BC = Offset into table
3983   1BC4 09                  ADD     HL,BC           ; Point to value
3984   1BC5 CD BF 15            CALL    ADDPHL          ; Add value to FPREG
3985   1BC8 CD 60 18    RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3986   1BCB 7B                  LD      A,E             ; Get LSB
3987   1BCC 59                  LD      E,C             ; LSB = MSB
3988   1BCD EE 4F               XOR     01001111B       ; Fiddle around
3989   1BCF 4F                  LD      C,A             ; New MSB
3990   1BD0 36 80               LD      (HL),80H        ; Set exponent
3991   1BD2 2B                  DEC     HL              ; Point to MSB
3992   1BD3 46                  LD      B,(HL)          ; Get MSB
3993   1BD4 36 80               LD      (HL),80H        ; Make value -0.5
3994   1BD6 21 37 21            LD      HL,SEED         ; Random number seed
3995   1BD9 34                  INC     (HL)            ; Count seed
3996   1BDA 7E                  LD      A,(HL)          ; Get seed
3997   1BDB D6 AB               SUB     171             ; Do it modulo 171
3998   1BDD C2 E4 1B            JP      NZ,RND2         ; Non-zero - Ok
3999   1BE0 77                  LD      (HL),A          ; Zero seed
4000   1BE1 0C                  INC     C               ; Fillde about
4001   1BE2 15                  DEC     D               ; with the
4002   1BE3 1C                  INC     E               ; number
4003   1BE4 CD 1F 16    RND2:   CALL    BNORM           ; Normalise number
4004   1BE7 21 5A 21            LD      HL,LSTRND       ; Save random number
4005   1BEA C3 6C 18            JP      FPTHL           ; Move FPREG to last and return
4006   1BED             
4007   1BED 77          RESEED: LD      (HL),A          ; Re-seed random numbers
4008   1BEE 2B                  DEC     HL
4009   1BEF 77                  LD      (HL),A
4010   1BF0 2B                  DEC     HL
4011   1BF1 77                  LD      (HL),A
4012   1BF2 C3 C8 1B            JP      RND1            ; Return RND seed
4013   1BF5             
4014   1BF5 68 B1 46 68 RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
4015   1BF9 99 E9 92 69         .BYTE   099H,0E9H,092H,069H
4016   1BFD 10 D1 75 68         .BYTE   010H,0D1H,075H,068H
4017   1C01             
4018   1C01 21 4B 1C    COS:    LD      HL,HALFPI       ; Point to PI/2
4019   1C04 CD BF 15            CALL    ADDPHL          ; Add it to PPREG
4020   1C07 CD 45 18    SIN:    CALL    STAKFP          ; Put angle on stack
4021   1C0A 01 49 83            LD      BC,8349H        ; BCDE = 2 PI
4022   1C0D 11 DB 0F            LD      DE,0FDBH
4023   1C10 CD 55 18            CALL    FPBCDE          ; Move 2 PI to FPREG
4024   1C13 C1                  POP     BC              ; Restore angle
4025   1C14 D1                  POP     DE
4026   1C15 CD 6A 17            CALL    DVBCDE          ; Divide angle by 2 PI
4027   1C18 CD 45 18            CALL    STAKFP          ; Put it on stack
4028   1C1B CD E7 18            CALL    INT             ; Get INT of result
4029   1C1E C1                  POP     BC              ; Restore number
4030   1C1F D1                  POP     DE
4031   1C20 CD CB 15            CALL    SUBCDE          ; Make it 0 <= value < 1
4032   1C23 21 4F 1C            LD      HL,QUARTR       ; Point to 0.25
4033   1C26 CD C5 15            CALL    SUBPHL          ; Subtract value from 0.25
4034   1C29 CD 14 18            CALL    TSTSGN          ; Test sign of value
4035   1C2C 37                  SCF                     ; Flag positive
4036   1C2D F2 37 1C            JP      P,SIN1          ; Positive - Ok
4037   1C30 CD BC 15            CALL    ROUND           ; Add 0.5 to value
4038   1C33 CD 14 18            CALL    TSTSGN          ; Test sign of value
4039   1C36 B7                  OR      A               ; Flag negative
4040   1C37 F5          SIN1:   PUSH    AF              ; Save sign
4041   1C38 F4 3D 18            CALL    P,INVSGN        ; Negate value if positive
4042   1C3B 21 4F 1C            LD      HL,QUARTR       ; Point to 0.25
4043   1C3E CD BF 15            CALL    ADDPHL          ; Add 0.25 to value
4044   1C41 F1                  POP     AF              ; Restore sign
4045   1C42 D4 3D 18            CALL    NC,INVSGN       ; Negative - Make positive
4046   1C45 21 53 1C            LD      HL,SINTAB       ; Coefficient table
4047   1C48 C3 5C 1B            JP      SUMSER          ; Evaluate sum of series
4048   1C4B             
4049   1C4B DB 0F 49 81 HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4050   1C4F             
4051   1C4F 00 00 00 7F QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4052   1C53             
4053   1C53 05          SINTAB: .BYTE   5                       ; Table used by SIN
4054   1C54 BA D7 1E 86         .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4055   1C58 64 26 99 87         .BYTE   064H,026H,099H,087H     ;-76.575
4056   1C5C 58 34 23 87         .BYTE   058H,034H,023H,087H     ; 81.602
4057   1C60 E0 5D A5 86         .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4058   1C64 DA 0F 49 83         .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4059   1C68             
4060   1C68 CD 45 18    TAN:    CALL    STAKFP          ; Put angle on stack
4061   1C6B CD 07 1C            CALL    SIN             ; Get SIN of angle
4062   1C6E C1                  POP     BC              ; Restore angle
4063   1C6F E1                  POP     HL
4064   1C70 CD 45 18            CALL    STAKFP          ; Save SIN of angle
4065   1C73 EB                  EX      DE,HL           ; BCDE = Angle
4066   1C74 CD 55 18            CALL    FPBCDE          ; Angle to FPREG
4067   1C77 CD 01 1C            CALL    COS             ; Get COS of angle
4068   1C7A C3 68 17            JP      DIV             ; TAN = SIN / COS
4069   1C7D             
4070   1C7D CD 14 18    ATN:    CALL    TSTSGN          ; Test sign of value
4071   1C80 FC A8 1A            CALL    M,NEGAFT        ; Negate result after if -ve
4072   1C83 FC 3D 18            CALL    M,INVSGN        ; Negate value if -ve
4073   1C86 3A 07 22            LD      A,(FPEXP)       ; Get exponent
4074   1C89 FE 81               CP      81H             ; Number less than 1?
4075   1C8B DA 9A 1C            JP      C,ATN1          ; Yes - Get arc tangnt
4076   1C8E 01 00 81            LD      BC,8100H        ; BCDE = 1
4077   1C91 51                  LD      D,C
4078   1C92 59                  LD      E,C
4079   1C93 CD 6A 17            CALL    DVBCDE          ; Get reciprocal of number
4080   1C96 21 C5 15            LD      HL,SUBPHL       ; Sub angle from PI/2
4081   1C99 E5                  PUSH    HL              ; Save for angle > 1
4082   1C9A 21 A4 1C    ATN1:   LD      HL,ATNTAB       ; Coefficient table
4083   1C9D CD 5C 1B            CALL    SUMSER          ; Evaluate sum of series
4084   1CA0 21 4B 1C            LD      HL,HALFPI       ; PI/2 - angle in case > 1
4085   1CA3 C9                  RET                     ; Number > 1 - Sub from PI/2
4086   1CA4             
4087   1CA4 09          ATNTAB: .BYTE   9                       ; Table used by ATN
4088   1CA5 4A D7 3B 78         .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4089   1CA9 02 6E 84 7B         .BYTE   002H,06EH,084H,07BH     ;-1/15
4090   1CAD FE C1 2F 7C         .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4091   1CB1 74 31 9A 7D         .BYTE   074H,031H,09AH,07DH     ;-1/11
4092   1CB5 84 3D 5A 7D         .BYTE   084H,03DH,05AH,07DH     ; 1/9
4093   1CB9 C8 7F 91 7E         .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4094   1CBD E4 BB 4C 7E         .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4095   1CC1 6C AA AA 7F         .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4096   1CC5 00 00 00 81         .BYTE   000H,000H,000H,081H     ; 1/1
4097   1CC9             
4098   1CC9             
4099   1CC9 C9          ARET:   RET                     ; A RETurn instruction
4100   1CCA             
4101   1CCA D7          GETINP: RST	    10H             ;input a character
4102   1CCB C9                  RET
4103   1CCC             
4104   1CCC             CLS: 
4105   1CCC 3E 0C               LD      A,CS            ; ASCII Clear screen
4106   1CCE C3 06 1E            JP      MONOUT          ; Output character
4107   1CD1             
4108   1CD1 CD 93 15    WIDTH:  CALL    GETINT          ; Get integer 0-255
4109   1CD4 7B                  LD      A,E             ; Width to A
4110   1CD5 32 62 21            LD      (LWIDTH),A      ; Set width
4111   1CD8 C9                  RET
4112   1CD9             
4113   1CD9 CD 32 0E    LINES:  CALL    GETNUM          ; Get a number
4114   1CDC CD 77 0A            CALL    DEINT           ; Get integer -32768 to 32767
4115   1CDF ED 53 66 21         LD      (LINESC),DE     ; Set lines counter
4116   1CE3 ED 53 68 21         LD      (LINESN),DE     ; Set lines number
4117   1CE7 C9                  RET
4118   1CE8             
4119   1CE8 CD 77 0A    DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4120   1CEB D5                  PUSH    DE              ; Save number
4121   1CEC E1                  POP     HL              ; Number to HL
4122   1CED 46                  LD      B,(HL)          ; Get LSB of contents
4123   1CEE 23                  INC     HL
4124   1CEF 7E                  LD      A,(HL)          ; Get MSB of contents
4125   1CF0 C3 ED 11            JP      ABPASS          ; Return integer AB
4126   1CF3             
4127   1CF3 CD 32 0E    DOKE:   CALL    GETNUM          ; Get a number
4128   1CF6 CD 77 0A            CALL    DEINT           ; Get integer -32768 to 32767
4129   1CF9 D5                  PUSH    DE              ; Save address
4130   1CFA CD 3B 08            CALL    CHKSYN          ; Make sure ',' follows
4131   1CFD 2C                  .BYTE      ','
4132   1CFE CD 32 0E            CALL    GETNUM          ; Get a number
4133   1D01 CD 77 0A            CALL    DEINT           ; Get integer -32768 to 32767
4134   1D04 E3                  EX      (SP),HL         ; Save value,get address
4135   1D05 73                  LD      (HL),E          ; Save LSB of value
4136   1D06 23                  INC     HL
4137   1D07 72                  LD      (HL),D          ; Save MSB of value
4138   1D08 E1                  POP     HL              ; Restore code string address
4139   1D09 C9                  RET
4140   1D0A             
4141   1D0A             
4142   1D0A             ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4143   1D0A             
4144   1D0A CD 35 0E    HEX: 	CALL	TSTNUM          ; Verify it's a number
4145   1D0D CD 77 0A            CALL	DEINT           ; Get integer -32768 to 32767
4146   1D10 C5                  PUSH	BC              ; Save contents of BC
4147   1D11 21 09 22            LD	    HL,PBUFF
4148   1D14 7A                  LD	    A,D             ; Get high order into A
4149   1D15 FE 00               CP      $0
4150   1D17 28 0C       		JR      Z,HEX2          ; Skip output if both high digits are zero
4151   1D19 CD 42 1D            CALL    BYT2ASC         ; Convert D to ASCII
4152   1D1C 78          		LD      A,B
4153   1D1D FE 30       		CP      '0'
4154   1D1F 28 02       		JR      Z,HEX1          ; Don't store high digit if zero
4155   1D21 70                  LD	    (HL),B          ; Store it to PBUFF
4156   1D22 23                  INC	    HL              ; Next location
4157   1D23 71          HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4158   1D24 23                  INC     HL              ; Next location
4159   1D25 7B          HEX2:   LD	    A,E             ; Get lower byte
4160   1D26 CD 42 1D            CALL    BYT2ASC         ; Convert E to ASCII
4161   1D29 7A          		LD      A,D
4162   1D2A FE 00               CP      $0
4163   1D2C 20 05       		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4164   1D2E 78          		LD      A,B
4165   1D2F FE 30       		CP      '0'             ; If high digit of lower byte is zero then don't print
4166   1D31 28 02       		JR      Z,HEX4
4167   1D33 70          HEX3:   LD      (HL),B          ; to PBUFF+2
4168   1D34 23                  INC     HL              ; Next location
4169   1D35 71          HEX4:   LD      (HL),C          ; to PBUFF+3
4170   1D36 23                  INC     HL              ; PBUFF+4 to zero
4171   1D37 AF                  XOR     A               ; Terminating character
4172   1D38 77                  LD      (HL),A          ; Store zero to terminate
4173   1D39 23                  INC     HL              ; Make sure PBUFF is terminated
4174   1D3A 77                  LD      (HL),A          ; Store the double zero there
4175   1D3B C1                  POP     BC              ; Get BC back
4176   1D3C 21 09 22            LD      HL,PBUFF        ; Reset to start of PBUFF
4177   1D3F C3 9B 12            JP      STR1            ; Convert the PBUFF to a string and return it
4178   1D42             
4179   1D42 47          BYT2ASC	LD      B,A             ; Save original value
4180   1D43 E6 0F               AND     $0F             ; Strip off upper nybble
4181   1D45 FE 0A               CP      $0A             ; 0-9?
4182   1D47 38 02               JR      C,ADD30         ; If A-F, add 7 more
4183   1D49 C6 07               ADD     A,$07           ; Bring value up to ASCII A-F
4184   1D4B C6 30       ADD30	ADD     A,$30           ; And make ASCII
4185   1D4D 4F                  LD      C,A             ; Save converted char to C
4186   1D4E 78                  LD      A,B             ; Retrieve original value
4187   1D4F 0F                  RRCA                    ; and Rotate it right
4188   1D50 0F                  RRCA
4189   1D51 0F                  RRCA
4190   1D52 0F                  RRCA
4191   1D53 E6 0F               AND     $0F             ; Mask off upper nybble
4192   1D55 FE 0A               CP      $0A             ; 0-9? < A hex?
4193   1D57 38 02               JR      C,ADD301        ; Skip Add 7
4194   1D59 C6 07               ADD     A,$07           ; Bring it up to ASCII A-F
4195   1D5B C6 30       ADD301	ADD     A,$30           ; And make it full ASCII
4196   1D5D 47                  LD      B,A             ; Store high order byte
4197   1D5E C9                  RET	
4198   1D5F             
4199   1D5F             ; Convert "&Hnnnn" to FPREG
4200   1D5F             ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4201   1D5F             ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4202   1D5F EB          HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4203   1D60 21 00 00            LD      HL,$0000        ; Zero out the value
4204   1D63 CD 78 1D            CALL    GETHEX          ; Check the number for valid hex
4205   1D66 DA 98 1D            JP      C,HXERR         ; First value wasn't hex, HX error
4206   1D69 18 05               JR      HEXLP1          ; Convert first character
4207   1D6B CD 78 1D    HEXLP   CALL    GETHEX          ; Get second and addtional characters
4208   1D6E 38 1F               JR      C,HEXIT         ; Exit if not a hex character
4209   1D70 29          HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4210   1D71 29                  ADD     HL,HL
4211   1D72 29                  ADD     HL,HL
4212   1D73 29                  ADD     HL,HL
4213   1D74 B5                  OR      L               ; Add in D0-D3 into L
4214   1D75 6F                  LD      L,A             ; Save new value
4215   1D76 18 F3               JR      HEXLP           ; And continue until all hex characters are in
4216   1D78             
4217   1D78 13          GETHEX  INC     DE              ; Next location
4218   1D79 1A                  LD      A,(DE)          ; Load character at pointer
4219   1D7A FE 20               CP      ' '
4220   1D7C CA 78 1D            JP      Z,GETHEX        ; Skip spaces
4221   1D7F D6 30               SUB     $30             ; Get absolute value
4222   1D81 D8                  RET     C               ; < "0", error
4223   1D82 FE 0A               CP      $0A
4224   1D84 38 05               JR      C,NOSUB7        ; Is already in the range 0-9
4225   1D86 D6 07               SUB     $07             ; Reduce to A-F
4226   1D88 FE 0A               CP      $0A             ; Value should be $0A-$0F at this point
4227   1D8A D8                  RET     C               ; CY set if was :            ; < = > ? @
4228   1D8B FE 10       NOSUB7  CP      $10             ; > Greater than "F"?
4229   1D8D 3F                  CCF
4230   1D8E C9                  RET                     ; CY set if it wasn't valid hex
4231   1D8F                 
4232   1D8F EB          HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4233   1D90 7A                  LD      A,D             ; Load DE into AC
4234   1D91 4B                  LD      C,E             ; For prep to 
4235   1D92 E5                  PUSH    HL
4236   1D93 CD EC 11            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4237   1D96 E1                  POP     HL
4238   1D97 C9                  RET
4239   1D98             
4240   1D98 1E 26       HXERR:  LD      E,HX            ; ?HEX Error
4241   1D9A C3 81 05            JP      ERROR
4242   1D9D             
4243   1D9D             ; BIN$(NN) Convert integer to a 1-16 char binary string
4244   1D9D CD 35 0E    BIN:    CALL    TSTNUM          ; Verify it's a number
4245   1DA0 CD 77 0A            CALL    DEINT           ; Get integer -32768 to 32767
4246   1DA3 C5          BIN2:   PUSH    BC              ; Save contents of BC
4247   1DA4 21 09 22            LD      HL,PBUFF
4248   1DA7 06 11               LD      B,17            ; One higher than max char count
4249   1DA9             ZEROSUP:                        ; Suppress leading zeros
4250   1DA9 05                  DEC     B               ; Max 16 chars
4251   1DAA 78                  LD      A,B
4252   1DAB FE 01               CP      $01
4253   1DAD 28 08               JR      Z,BITOUT        ; Always output at least one character
4254   1DAF CB 13               RL      E
4255   1DB1 CB 12               RL      D
4256   1DB3 30 F4               JR      NC,ZEROSUP
4257   1DB5 18 04               JR      BITOUT2
4258   1DB7             BITOUT:      
4259   1DB7 CB 13               RL      E
4260   1DB9 CB 12               RL      D               ; Top bit now in carry
4261   1DBB             BITOUT2:
4262   1DBB 3E 30               LD      A,'0'           ; Char for '0'
4263   1DBD CE 00               ADC     A,0             ; If carry set then '0' --> '1'
4264   1DBF 77                  LD      (HL),A
4265   1DC0 23                  INC     HL
4266   1DC1 05                  DEC     B
4267   1DC2 20 F3               JR      NZ,BITOUT
4268   1DC4 AF                  XOR     A               ; Terminating character
4269   1DC5 77                  LD      (HL),A          ; Store zero to terminate
4270   1DC6 23                  INC     HL              ; Make sure PBUFF is terminated
4271   1DC7 77                  LD      (HL),A          ; Store the double zero there
4272   1DC8 C1                  POP     BC
4273   1DC9 21 09 22            LD      HL,PBUFF
4274   1DCC C3 9B 12            JP      STR1
4275   1DCF             
4276   1DCF             ; Convert "&Bnnnn" to FPREG
4277   1DCF             ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4278   1DCF EB          BINTFP: EX      DE,HL           ; Move code string pointer to DE
4279   1DD0 21 00 00            LD      HL,$0000        ; Zero out the value
4280   1DD3 CD EC 1D            CALL    CHKBIN          ; Check the number for valid bin
4281   1DD6 DA FA 1D            JP      C,BINERR        ; First value wasn't bin, HX error
4282   1DD9 D6 30       BINIT:  SUB     '0'
4283   1DDB 29                  ADD     HL,HL           ; Rotate HL left
4284   1DDC B5                  OR      L
4285   1DDD 6F                  LD      L,A
4286   1DDE CD EC 1D            CALL    CHKBIN          ; Get second and addtional characters
4287   1DE1 30 F6               JR      NC,BINIT        ; Process if a bin character
4288   1DE3 EB                  EX      DE,HL           ; Value into DE, Code string into HL
4289   1DE4 7A                  LD      A,D             ; Load DE into AC
4290   1DE5 4B                  LD      C,E             ; For prep to 
4291   1DE6 E5                  PUSH    HL
4292   1DE7 CD EC 11            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4293   1DEA E1                  POP     HL
4294   1DEB C9                  RET
4295   1DEC             
4296   1DEC             ; Char is in A, NC if char is 0 or 1
4297   1DEC 13          CHKBIN: INC     DE
4298   1DED 1A                  LD      A,(DE)
4299   1DEE FE 20               CP      ' '
4300   1DF0 CA EC 1D            JP      Z,CHKBIN        ; Skip spaces
4301   1DF3 FE 30               CP      '0'             ; Set C if < '0'
4302   1DF5 D8                  RET     C
4303   1DF6 FE 32               CP      '2'
4304   1DF8 3F                  CCF                     ; Set C if > '1'
4305   1DF9 C9                  RET
4306   1DFA             
4307   1DFA 1E 28       BINERR: LD      E,BN            ; ?BIN Error
4308   1DFC C3 81 05            JP      ERROR
4309   1DFF             
4310   1DFF             
4311   1DFF             JJUMP1: 
4312   1DFF DD 21 FF FF         LD      IX,-1           ; Flag cold start
4313   1E03 C3 D1 01            JP      CSTART          ; Go and initialise
4314   1E06             
4315   1E06             MONOUT: 
4316   1E06 C3 08 00            JP      $0008           ; output a char
4317   1E09             
4318   1E09             
4319   1E09             MONITR: 
4320   1E09 C3 00 00            JP      $0000           ; Restart (Normally Monitor Start)
4321   1E0C             
4322   1E0C             
4323   1E0C 3E 00       INITST: LD      A,0             ; Clear break flag
4324   1E0E 32 6D 21            LD      (BRKFLG),A
4325   1E11 C3 D8 01            JP      INIT
4326   1E14             
4327   1E14 ED 45       ARETN:  RETN                    ; Return from NMI
4328   1E16             
4329   1E16             
4330   1E16 F5          TSTBIT: PUSH    AF              ; Save bit mask
4331   1E17 A0                  AND     B               ; Get common bits
4332   1E18 C1                  POP     BC              ; Restore bit mask
4333   1E19 B8                  CP      B               ; Same bit set?
4334   1E1A 3E 00               LD      A,0             ; Return 0 in A
4335   1E1C C9                  RET
4336   1E1D             
4337   1E1D CD 46 08    OUTNCR: CALL    OUTC            ; Output character in A
4338   1E20 C3 6D 0C            JP      PRNTCRLF        ; Output CRLF
4339   1E23             
4340   1E23             .end
4341   1E23             



Label        Value      Label        Value      Label        Value
------------------      ------------------      ------------------
ARREND        21FA      ACCSUM        0A56      ATOH          0A91      
ASPCS         0CB8      ANTVLU        0D56      ARLDSV        110D      
ACPASS        11EC      ABPASS        11ED      ARRLP         1386      
ASC           148C      ALLFOL        14BB      ADDPHL        15BF      
ADDEXP        17D2      ABS           1839      ASCTFP        191B      
ADDIG         1978      ATN           1C7D      ATN1          1C9A      
ATNTAB        1CA4      ARET          1CC9      ADD30         1D4B      
ADD301        1D5B      ARETN         1E14      BKSP          0008      
BRKFLG        216D      BASTXT        217E      BUFFER        2181      
BRKLIN        21EE      BS            0010      BN            0028      
BRKRET        0267      BFREE         026D      BRKMSG        0510      
BAKSTK        0516      BRK           0A08      BADINP        0CDD      
BSERR         1140      BAKTMP        146C      BNORM         161F      
BNRMLP        1622      BYTSFT        1757      BCDEFP        1860      
BYT2ASC       1D42      BIN           1D9D      BIN2          1DA3      
BITOUT        1DB7      BITOUT2       1DBB      BINTFP        1DCF      
BINIT         1DD9      BINERR        1DFA      CTRLC         0003      
CTRLG         0007      CS            000C      CR            000D      
CTRLO         000F      CTRLQ         0011      CTRLR         0012      
CTRLS         0013      CTRLU         0015      COMMAN        2163      
CTLOFG        2165      CHKSUM        216A      CURPOS        21CB      
CUROPR        21E5      CONTAD        21F4      CN            0020      
COLD          01C0      CSTART        01D1      COPY          01E0      
CHKSTK        054A      CLRPTR        067A      CLREG         069F      
CRUNCH        06C9      CRNCLP        06D2      CPYLIT        0771      
CPDEHL        0835      CHKSYN        083B      CLOTST        0870      
COUNT         08E0      CONT          0A3B      CHKLTR        0A63      
CLEAR         0AB6      CRESTR        0BB5      CHKTYP        0E37      
CONVAR        0F22      CMPLOG        0FB5      CMPLG1        0FB7      
CMPSTR        0FE1      CMPRES        0FF9      CHARTY        1051      
CFEVAL        10A3      CREARY        1145      CRARLP        1160      
CHEKFN        1284      CRTMST        12BD      CRTST         12C9      
CRTSTE        12DF      CONCAT        1401      CHR           149D      
CONPOS        161C      COMPL         167F      CMPNUM        188F      
CMPFP         18A9      CNVNUM        1927      CONEXP        1957      
COS           1C01      CLS           1CCC      CHKBIN        1DEC      
DEL           007F      DIVSUP        2129      DIV1          212A      
DIV2          212E      DIV3          2132      DIV4          2135      
DATFLG        21CE      DATLIN        21E9      DD            0012      
DZ            0014      DATSNR        0567      DZERR         0570      
DDERR         0576      DOAGN         06B8      DODEL         0781      
DELCHR        07A1      DINPOS        086A      DEPINT        0A71      
DEINT         0A77      DATA          0B5C      DONULL        0C77      
DOCOM         0C89      DOTAB         0CA0      DOSPC         0CB3      
DIMRET        101A      DIM           1023      DEFSIZ        1168      
DEF           1201      DOFN          122E      DTSTR         12CD      
DIV10         175C      DIV           1768      DVBCDE        176A      
DIVLP         178F      DETHL4        186F      DETHLB        1871      
DCBCDE        18E0      DPOINT        1953      DIGTXT        1A21      
DOEBIT        1A61      DEEK          1CE8      DOKE          1CF3      
ESC           001B      ERRLIN        21F2      ERRORS        0474      
ERRMSG        04FE      ENFMEM        0553      ERROR         0581      
ERRIN         05A1      ENDBUF        0778      ECHDEL        0795      
EXCUTE        09A5      ENDPRG        0A17      ENDINP        0C68      
EXTIG         0DB2      EVAL          0E44      EVAL1         0E47      
EVAL2         0E50      EVAL3         0E53      EVLPAR        0F09      
EVNOT         1003      ENDNAM        1045      ENDDIM        11C7      
EXPLP         1945      ENDCON        1966      EDIGIT        199A      
EXPTEN        1A73      EXP           1AFB      EXPTAB        1B3B      
FORFLG        21EB      FNRGNM        21FE      FNARG         2200      
FPREG         2204      FPEXP         2207      FC            0008      
FNCTAB        02BE      FNDEND        064D      FNDWRD        06FC      
FNDTOK        08BF      FOR           090C      FORSLP        0920      
FORFND        093C      FPSINT        0A6B      FCERR         0A8C      
FDTLP         0DC3      FANDT         0DDC      FOPRND        0E7C      
FRMEVL        0F25      FNOFST        0F33      FNVAL         0F5A      
FNDVAR        108A      FNTHR         1098      FNDARY        1113      
FINDEL        11A3      FNDELP        11A8      FRE           11CB      
FRENUM        11E7      FNDNUM        1590      FPADD         15CE      
FPROND        1666      FPMULT        1709      FLGDIF        181F      
FLGREL        1826      FPBCDE        1855      FPTHL         186C      
FPINT         18BC      GETCMD        05C5      GETNXT        0717      
GETLIN        07B2      GETCHR        09C5      GETLN         0A92      
GTLNLP        0A95      GOSUB         0B08      GOTO          0B19      
GTVLUS        0D2E      GETNUM        0E32      GOFUNC        0F62      
GETVAR        1028      GTFNAM        102D      GRBDON        1326      
GARBGE        134E      GARBLP        1351      GRBLP         135F      
GNXARY        1385      GRBARY        13A5      GETSTR        144B      
GSTRCU        144E      GSTRHL        1451      GSTRDE        1452      
GETLEN        1481      GTFLNM        1490      GETINT        1593      
GTSIXD        19EB      GETINP        1CCA      GETHEX        1D78      
HX            0026      HALF          1A92      HALFPI        1C4B      
HEX           1D0A      HEX1          1D23      HEX2          1D25      
HEX3          1D33      HEX4          1D35      HEXTFP        1D5F      
HEXLP         1D6B      HEXLP1        1D70      HEXIT         1D8F      
HXERR         1D98      INPSUB        215E      INPORT        215F      
ID            0016      INIT          01D8      INITAB        049E      
INITBE        04FE      INMSG         0505      INDFND        0530      
INEWLN        0615      INTVAR        0689      INCLEN        0866      
IFJMP         09AC      INPBRK        0A14      IF            0BEB      
IFGO          0BF9      INPUT         0CEE      ITMSEP        0D71      
INPBIN        0D80      IDTEST        1276      INP           1550      
INVSGN        183D      INCHL         186A      INT           18E7      
INRNG         19F4      INITST        1E0C      JSTZER        1A7D      
JJUMP1        1DFF      KILIN         07AC      KILFOR        0E22      
LF            000A      LSTRND        215A      LWIDTH        2162      
LINESC        2166      LINESN        2168      LINEAT        217C      
LCRFLG        21CC      LSTRAM        21CF      LOOPST        21E7      
LSTBIN        21EC      LS            001C      LOKFOR        051A      
LINFND        05FE      LIST          0881      LISTLP        088D      
LSTLP2        08AD      LSTLP3        08B0      LET           0B73      
LETSTR        0B8E      LETNUM        0BC6      LTSTND        0D8B      
LEN           147D      LEFT          14AD      LFRGNM        1546      
LOGTAB        16BB      LOG           16C8      LOADFP        1863      
LINEIN        19A6      LINES         1CD9      MULVAL        2216      
MO            0024      MSIZE         01F5      MLOOP         0208      
MEMMSG        02B3      MOVUP         0539      MOVSTR        053C      
MOVLP         053F      MOVBUF        0634      MATCH         0749      
MOVDIR        0751      MORINP        07BB      MVSTPT        0BBD      
MRPRNT        0C0B      MORDT         0D97      MINUS         0F11      
MKTMST        12BA      MID1          14B3      MID           14E7      
MIDNUM        154B      MAKINT        1596      MINCDE        160E      
MULLN2        1700      MULT          1707      MULT8         172B      
MUL8LP        1734      MLSP10        17FD      MLDEBC        1900      
MLDBLP        1908      MANLP         192F      MULTEN        1971      
MAKNUM        1A10      MONOUT        1E06      MONITR        1E09      
NULLS         2161      NULFLG        2164      NMIFLG        216C      
NXTOPR        21F0      NXTDAT        21FC      NF            0000      
NFERR         0573      NEW           0679      NXTBYT        0727      
NOSPC         0738      NOCHNG        0741      NXTCHR        0768      
NOLIN         0A2A      NULL          0A4E      NXTDTA        0B5B      
NXTSTL        0B62      NXTSTT        0B65      NULLP         0C7E      
NEXITM        0CC3      NOPMPT        0D08      NXTITM        0D22      
NEDMOR        0D2A      NEXT          0DE7      NEXT1         0DEA      
NOTAMP        0EE6      NOTSTR        1060      NSCFOR        1070      
NXTARY        1127      NOXOR         1576      NOSWAP        15E8      
NORMAL        1639      NOMADD        1745      NOMLAD        1916      
NUMASC        19B9      NOENED        1A80      NEGAFT        1AA8      
NOSUB7        1D8B      OUTSUB        2126      OTPORT        2127      
OD            0006      OV            000A      OM            000C      
OS            001A      OKMSG         050A      OMERR         0562      
OVERR         057C      OTKLN         07A9      OUTIT         0827      
OUTNBS        082D      OUTC          0846      OUTWRD        08C9      
ONJMP         09AD      ON            0BCD      ONGO          0BDC      
ONGOLP        0BDD      OPNPAR        0E40      OPRND         0EBB      
OVTST1        17F0      OVTST2        17F5      OVTST3        17F6      
OUTEXP        1A71      OUTNCR        1E1D      POINT         2171      
PSET          2174      PROGND        21F6      PBUFF         2209      
PROGST        2219      PRITAB        045F      POPNOK        05B7      
PRNTOK        05B8      PTRLP         0641      PROMPT        06BC      
PROCES        07D4      PUTBUF        0813      PUTCTL        0818      
PUTFID        0981      PEND          0A0F      POSINT        0A6E      
PRINT         0C0F      PRNTLP        0C12      PRNTNB        0C55      
PRNTST        0C59      PRNTCRLF      0C6D      POR           0F7B      
PAND          0F7C      POR1          0F9E      POS           11F9      
PASSA         11FC      PRNUMS        130A      PRS           130B      
PRS1          130E      PRSLP         1315      POPAF         1340      
POPHL         146A      POUT          155C      PEEK          15A4      
POKE          15AB      PSUB          15C9      PNORM         1641      
PLUCDE        1673      POPHRT        1755      PHLTFP        1852      
PADD          1995      PRNTHL        19AE      POWERS        1A96      
POWER         1AB6      POWER1        1AC6      POWER2        1AE3      
QTSTR         12CA      QTSTLP        12D0      QUARTR        1C4F      
RINPUT        216E      RESET         2177      READFG        21ED      
RG            0004      RUNFST        0685      RETNAD        074D      
RSLNBK        0903      RUNCNT        0985      RESTOR        09D5      
RESTNL        09EA      RUN           0AFC      RUNLIN        0B18      
RETURN        0B37      RETLIN        0B56      REM           0B5E      
REDO          0CCA      READ          0D1D      RLTLP         0E60      
RETNUM        0F1D      RETADR        10D7      RETNUL        10DA      
RIGHT1        14B1      RIGHT         14DD      RSTSTR        1500      
ROUND         15BC      RESZER        1634      RONDUP        1654      
RONDB         1655      RESDIV        17A2      RETREL        181D      
RETINT        182B      RSCALE        198F      RNGTST        1A83      
RND           1B8C      RND1          1BC8      RND2          1BE4      
RESEED        1BED      RNDTAB        1BF5      SEED          2137      
STRSPC        217A      STACK         2186      STRBOT        21E3      
SGNRES        2208      STLOOK        227D      SN            0002      
ST            001E      STARTB        01C6      SETTOP        022C      
SIGNON        027C      SNERR         056D      SFTPRG        0606      
SETPTR        063C      SRCHLN        0659      SRCHLP        065C      
SEARCH        0715      SETLIT        075F      SETLIN        08D7      
SAVSTP        0978      STALL         09FE      STOP          0A0D      
STORED        0AD9      STTLIN        0C60      SPCLP         0CBC      
STRENT        0D74      STKTHS        0EA4      SGNEXP        0F6B      
SVNAM2        1044      SBSCPT        10E5      SCPTLP        10EB      
STR           1295      STR1          129B      SAVSTR        12A5      
SVSTAD        12C3      SMPVAR        1370      STPOOL        13B3      
STRADD        13B6      SCNEND        13DC      SSTSA         1438      
SETIO         1580      SUBPHL        15C5      SUBCDE        15CB      
SAVEXP        1635      SCALE         1693      SCALLP        1695      
SHRITE        16A2      SHRLP         16A5      SHRT1         16A9      
SGN           1823      STAKFP        1845      SIGNS         187A      
SCALMI        195A      SCALPL        1970      SPCFST        19C7      
SIXDIG        19D6      SUPTLZ        1A55      SQR           1AAD      
SUMSER        1B5C      SMSER1        1B6B      SUMLP         1B74      
SIN           1C07      SIN1          1C37      SINTAB        1C53      
TYPE          21CD      TMSTPT        21D1      TMSTPL        21D3      
TMPSTR        21DF      TM            0018      TSTMEM        021A      
TMERR         057F      TSTREM        0762      TTYLIN        07B2      
TSTBRK        09F0      TSTNUM        0E35      TSTSTR        0E36      
TSTRED        0FA3      TSTOPL        12EB      TESTR         1324      
TESTOS        1342      TOSTRA        1441      TSALP         1442      
TOPOOL        14A9      TSTSGN        1814      TRYAGN        1A30      
TAN           1C68      TSTBIT        1E16      USR           2123      
UL            000E      UF            0022      UFERR         0579      
UPDATA        09EB      ULERR         0B32      UNITY         16B7      
VAREND        21F8      VAL           1517      VAL1          1535      
VAL2          153F      VAL3          1542      WRKSPC        2120      
WARM          01C3      WARMST        0264      WORDS         02F6      
WORDTB        0415      WAIT          1562      WAITLP        1577      
WIDTH         1CD1      ZEND          0080      ZFOR          0081      
ZDATA         0083      ZGOTO         0088      ZGOSUB        008C      
ZREM          008E      ZPRINT        009E      ZNEW          00A4      
ZTAB          00A5      ZTO           00A6      ZFN           00A7      
ZSPC          00A8      ZTHEN         00A9      ZNOT          00AA      
ZSTEP         00AB      ZPLUS         00AC      ZMINUS        00AD      
ZTIMES        00AE      ZDIV          00AF      ZOR           00B2      
ZGTR          00B3      ZEQUAL        00B4      ZLTH          00B5      
ZSGN          00B6      ZPOINT        00C7      ZLEFT         00CF      
ZERBYT        0509      ZONELP        0C97      ZEROLP        10C9      
ZERARY        1186      ZEROSUP       1DA9      

tasm: Number of errors = 0
