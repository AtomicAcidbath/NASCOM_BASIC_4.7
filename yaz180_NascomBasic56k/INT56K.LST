0001   0000             ;==================================================================================
0002   0000             ; Contents of this file are copyright Phillip Stevens
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; Initialisation routines to suit Z8S180 CPU, with internal USART.
0008   0000             ;
0009   0000             ; Internal USART interrupt driven serial I/O to run modified NASCOM Basic 4.7.
0010   0000             
0011   0000             ; Full input and output buffering with incoming data hardware handshaking.
0012   0000             ; Handshake shows full before the buffer is totally filled to
0013   0000             ; allow run-on from the sender.
0014   0000             ;
0015   0000             ; https://github.com/feilipu/
0016   0000             ;
0017   0000             ; https://feilipu.me/
0018   0000             ;
0019   0000             ;==================================================================================
0020   0000             ;
0021   0000             ; Z180 Register Mnemonics
0022   0000             ;
0023   0000             
0024   0000             CNTLA0          .EQU    $00     ; ASCI Control Reg A Ch 0
0025   0000             CNTLA1          .EQU    $01     ; ASCI Control Reg A Ch 1
0026   0000             CNTLB0          .EQU    $02     ; ASCI Control Reg B Ch 0
0027   0000             CNTLB1          .EQU    $03     ; ASCI Control Reg B Ch 1
0028   0000             STAT0           .EQU    $04     ; ASCI Status  Reg   Ch 0
0029   0000             STAT1           .EQU    $05     ; ASCI Status  Reg   Ch 1
0030   0000             TDR0            .EQU    $06     ; ASCI Tx Data Reg   Ch 0
0031   0000             TDR1            .EQU    $07     ; ASCI Tx Data Reg   Ch 1
0032   0000             RDR0            .EQU    $08     ; ASCI Rx Data Reg   Ch 0
0033   0000             RDR1            .EQU    $09     ; ASCI Rx Data Reg   Ch 1
0034   0000             
0035   0000             ASEXT0          .EQU    $12     ; ASCI Extension Control Reg Ch 0 (Z8S180 & higher Only)
0036   0000             ASEXT1          .EQU    $13     ; ASCI Extension Control Reg Ch 1 (Z8S180 & higher Only)
0037   0000             
0038   0000             ASTC0L          .EQU    $1A     ; ASCI Time Constant Ch 0 Low (Z8S180 & higher Only)
0039   0000             ASTC0H          .EQU    $1B     ; ASCI Time Constant Ch 0 High (Z8S180 & higher Only)
0040   0000             ASTC1L          .EQU    $1C     ; ASCI Time Constant Ch 1 Low (Z8S180 & higher Only)
0041   0000             ASTC1H          .EQU    $1D     ; ASCI Time Constant Ch 1 High (Z8S180 & higher Only)
0042   0000             
0043   0000             CNTR            .EQU    $0A     ; CSI/O Control Reg
0044   0000             TRDR            .EQU    $0B     ; CSI/O Tx/Rx Data Reg
0045   0000             
0046   0000             TMDR0L          .EQU    $0C     ; Timer Data Reg Ch 0 Low
0047   0000             TMDR0H          .EQU    $0D     ; Timer Data Reg Ch 0 High
0048   0000             RLDR0L          .EQU    $0E     ; Timer Reload Reg Ch 0 Low
0049   0000             RLDR0H          .EQU    $0F     ; Timer Reload Reg Ch 0 High
0050   0000             TCR             .EQU    $10     ; Timer Control Reg
0051   0000             
0052   0000             TMDR1L          .EQU    $14     ; Timer Data Reg Ch 1 Low
0053   0000             TMDR1H          .EQU    $15     ; Timer Data Reg Ch 1 High
0054   0000             RLDR1L          .EQU    $16     ; Timer Reload Reg Ch 1 Low
0055   0000             RLDR1H          .EQU    $17     ; Timer Reload Reg Ch 1 High
0056   0000             
0057   0000             FRC             .EQU    $18     ; Free-Running Counter
0058   0000             
0059   0000             CMR             .EQU    $1E     ; CPU Clock Multiplier Reg (Z8S180 & higher Only)
0060   0000             CCR             .EQU    $1F     ; CPU Control Reg (Z8S180 & higher Only)
0061   0000             
0062   0000             SAR0L           .EQU    $20     ; DMA Source Addr Reg Ch0-Low
0063   0000             SAR0H           .EQU    $21     ; DMA Source Addr Reg Ch0-High
0064   0000             SAR0B           .EQU    $22     ; DMA Source Addr Reg Ch0-Bank
0065   0000             DAR0L           .EQU    $23     ; DMA Dest Addr Reg Ch0-Low
0066   0000             DAR0H           .EQU    $24     ; DMA Dest Addr Reg Ch0-High
0067   0000             DAR0B           .EQU    $25     ; DMA Dest ADDR REG CH0-Bank
0068   0000             BCR0L           .EQU    $26     ; DMA Byte Count Reg Ch0-Low
0069   0000             BCR0H           .EQU    $27     ; DMA Byte Count Reg Ch0-High
0070   0000             MAR1L           .EQU    $28     ; DMA Memory Addr Reg Ch1-Low
0071   0000             MAR1H           .EQU    $29     ; DMA Memory Addr Reg Ch1-High
0072   0000             MAR1B           .EQU    $2A     ; DMA Memory Addr Reg Ch1-Bank
0073   0000             IAR1L           .EQU    $2B     ; DMA I/O Addr Reg Ch1-Low
0074   0000             IAR1H           .EQU    $2C     ; DMA I/O Addr Reg Ch2-High
0075   0000             BCR1L           .EQU    $2E     ; DMA Byte Count Reg Ch1-Low
0076   0000             BCR1H           .EQU    $2F     ; DMA Byte Count Reg Ch1-High
0077   0000             DSTAT           .EQU    $30     ; DMA Status Reg
0078   0000             DMODE           .EQU    $31     ; DMA Mode Reg
0079   0000             DCNTL           .EQU    $32     ; DMA/Wait Control Reg
0080   0000             
0081   0000             IL              .EQU    $33     ; INT Vector Low Reg
0082   0000             ITC             .EQU    $34     ; INT/TRAP Control Reg
0083   0000             
0084   0000             RCR             .EQU    $36     ; Refresh Control Reg
0085   0000             
0086   0000             CBR             .EQU    $38     ; MMU Common Base Reg
0087   0000             BBR             .EQU    $39     ; MMU Bank Base Reg
0088   0000             CBAR            .EQU    $3A     ; MMU Common/Bank Area Reg
0089   0000             
0090   0000             OMCR            .EQU    $3E     ; Operation Mode Control Reg
0091   0000             ICR             .EQU    $3F     ; I/O Control Reg
0092   0000             
0093   0000             ;==================================================================================
0094   0000             ;
0095   0000             ; Some bit definitions used with the Z-180 on-chip peripherals:
0096   0000             ;
0097   0000             
0098   0000             ; ASCI Control Reg A
0099   0000             
0100   0000             SER_MPE         .EQU   $80    ; Multi Processor Enable
0101   0000             SER_RE          .EQU   $40    ; Receive Enable
0102   0000             SER_TE          .EQU   $20    ; Transmit Enable
0103   0000             SER_RTS0        .EQU   $10    ; _RTS Request To Send
0104   0000             SER_EFR         .EQU   $08    ; Error Flag Reset
0105   0000             
0106   0000             SER_7N1         .EQU   $00    ; 7 Bits No Parity 1 Stop Bit
0107   0000             SER_7N2         .EQU   $01    ; 7 Bits No Parity 2 Stop Bits
0108   0000             SER_7P1         .EQU   $02    ; 7 Bits    Parity 1 Stop Bit
0109   0000             SER_7P2         .EQU   $03    ; 7 Bits    Parity 2 Stop Bits
0110   0000             SER_8N1         .EQU   $04    ; 8 Bits No Parity 1 Stop Bit
0111   0000             SER_8N2         .EQU   $05    ; 8 Bits No Parity 2 Stop Bits
0112   0000             SER_8P1         .EQU   $06    ; 8 Bits    Parity 1 Stop Bit
0113   0000             SER_8P2         .EQU   $07    ; 8 Bits    Parity 2 Stop Bits
0114   0000             
0115   0000             ; ASCI Control Reg B
0116   0000             
0117   0000             SER_MPBT        .EQU   $80    ; Multi Processor Bit Transmit
0118   0000             SER_MP          .EQU   $40    ; Multi Processor
0119   0000             SER_PS          .EQU   $20    ; Prescale PHI by 10 (PS 0) or 30 (PS 1)
0120   0000             SER_PEO         .EQU   $10    ; Parity Even or Odd
0121   0000             SER_DR          .EQU   $08    ; Divide SS by 16 (DR 0) or 64 (DR 1)
0122   0000             
0123   0000                                           ; Baud Rate Selection
0124   0000             SER_SS_DIV_1    .EQU   $00    ; Divide PS by  1
0125   0000             SER_SS_DIV_2    .EQU   $01    ; Divide PS by  2
0126   0000             SER_SS_DIV_4    .EQU   $02    ; Divide PS by  4
0127   0000             SER_SS_DIV_8    .EQU   $03    ; Divide PS by  8
0128   0000             SER_SS_DIV_16   .EQU   $04    ; Divide PS by 16
0129   0000             SER_SS_DIV_32   .EQU   $05    ; Divide PS by 32
0130   0000             SER_SS_DIV_64   .EQU   $06    ; Divide PS by 64
0131   0000             SER_SS_EXT      .EQU   $07    ; External Clock Source <= PHI / 40
0132   0000             
0133   0000                                           ; BAUD Rate = PHI / PS / SS / DR
0134   0000             
0135   0000             ; ASCI Status Reg
0136   0000             
0137   0000             SER_RDRF        .EQU   $80    ; Receive Data Register Full
0138   0000             SER_OVRN        .EQU   $40    ; Overrun (Received Byte)
0139   0000             SER_PE          .EQU   $20    ; Parity Error (Received Byte)
0140   0000             SER_FE          .EQU   $10    ; Framing Error (Received Byte)
0141   0000             SER_RIE         .EQU   $08    ; Receive Interrupt Enabled
0142   0000             SER_DCD0        .EQU   $04    ; _DCD0 Data Carrier Detect USART0
0143   0000             SER_CTS1        .EQU   $04    ; _CTS1 Clear To Send USART1
0144   0000             SER_TDRE        .EQU   $02    ; Transmit Data Register Empty
0145   0000             SER_TIE         .EQU   $01    ; Transmit Interrupt Enabled
0146   0000             
0147   0000             ; CPU Clock Multiplier Reg (CMR) (Z8S180 & higher Only)
0148   0000             
0149   0000             CMR_X2          .EQU   $80    ; CPU x2 XTAL Multiplier Mode
0150   0000             CMR_LN_XTAL     .EQU   $40    ; Low Noise Crystal 
0151   0000             
0152   0000             ; CPU Control Reg (CCR) (Z8S180 & higher Only)
0153   0000             
0154   0000             CCR_XTAL_X2     .EQU   $80    ; PHI = XTAL Mode
0155   0000             CCR_STANDBY     .EQU   $40    ; STANDBY after SLEEP
0156   0000             CCR_BREXT       .EQU   $20    ; Exit STANDBY on BUSREQ
0157   0000             CCR_LNPHI       .EQU   $10    ; Low Noise PHI (30% Drive)
0158   0000             CCR_IDLE        .EQU   $08    ; IDLE after SLEEP
0159   0000             CCR_LNIO        .EQU   $04    ; Low Noise I/O Signals (30% Drive)
0160   0000             CCR_LNCPUCTL    .EQU   $02    ; Low Noise CPU Control Signals (30% Drive)
0161   0000             CCR_LNAD        .EQU   $01    ; Low Noise Address and Data Signals (30% Drive)
0162   0000             
0163   0000             ; Refresh Control Reg (RCR)
0164   0000             
0165   0000             RCR_REFE        .EQU   $80    ; DRAM Refresh Enable (0 Disabled)
0166   0000             RCR_REFW        .EQU   $40    ; DRAM Refresh 2 or 3 Wait states (0 2 Wait States)
0167   0000             
0168   0000             ; Operation Mode Control Reg
0169   0000             
0170   0000             OMCR_M1E        .EQU   $80    ; M1 Enable (0 Disabled)
0171   0000             OMCR_M1TE       .EQU   $40    ; M1 Temporary Enable
0172   0000             OMCR_IOC        .EQU   $20    ; IO Control (1 64180 Mode)
0173   0000             
0174   0000             ; Interrupt vectors (offsets) for Z180/HD64180 internal interrupts
0175   0000             
0176   0000             INT1_VECTOR     .EQU   $00    ; external /INT1 
0177   0000             INT2_VECTOR     .EQU   $02    ; external /INT2 
0178   0000             PRT0_VECTOR     .EQU   $04    ; PRT channel 0 
0179   0000             PRT1_VECTOR     .EQU   $06    ; PRT channel 1 
0180   0000             DMA0_VECTOR     .EQU   $08    ; DMA channel 0 
0181   0000             DMA1_VECTOR     .EQU   $0A    ; DMA Channel 1 
0182   0000             CSIO_VECTOR     .EQU   $0C    ; Clocked serial I/O 
0183   0000             ASCI0_VECTOR    .EQU   $0E    ; Async channel 0 
0184   0000             ASCI1_VECTOR    .EQU   $10    ; Async channel 1 
0185   0000             INCAP_VECTOR    .EQU   $12    ; input capture 
0186   0000             OUTCMP_VECTOR   .EQU   $14    ; output compare 
0187   0000             TIMOV_VECTOR    .EQU   $16    ; timer overflow 
0188   0000             
0189   0000             ;==================================================================================
0190   0000             ;
0191   0000             ; DEFINES SECTION
0192   0000             
0193   0000                                            ; end of ASCI stuff is $210D
0194   0000                                            ; set BASIC Work space WRKSPC $2120
0195   0000             
0196   0000             TEMPSTACK       .EQU     $21CB ; Top of BASIC line input buffer (CURPOS WRKSPC+0ABH)
0197   0000                                            ; so it is "free ram" when BASIC resets
0198   0000             
0199   0000             CR              .EQU     0DH
0200   0000             LF              .EQU     0AH
0201   0000             CS              .EQU     0CH   ; Clear screen
0202   0000             
0203   0000             ;==================================================================================
0204   0000             ;
0205   0000             ; VARIABLES SECTION
0206   0000             
0207   0000             SER_RX_BUFSIZE  .EQU     $F0  ; Size of the Rx Buffer, 239 Bytes
0208   0000             SER_TX_BUFSIZE  .EQU     $10  ; Size of the Tx Buffer, 15 Bytes
0209   0000                  
0210   0000             serRxBuf        .EQU     $2000
0211   0000             serRxInPtr      .EQU     serRxBuf+SER_RX_BUFSIZE+1
0212   0000             serRxOutPtr     .EQU     serRxInPtr+2
0213   0000             serRxBufUsed    .EQU     serRxOutPtr+2
0214   0000             serTxBuf        .EQU     serRxBufUsed+1
0215   0000             serTxInPtr      .EQU     serTxBuf+SER_TX_BUFSIZE+1
0216   0000             serTxOutPtr     .EQU     serTxInPtr+2
0217   0000             serTxBufUsed    .EQU     serTxOutPtr+2
0218   0000             basicStarted    .EQU     serTxBufUsed+1
0219   0000             
0220   0000             ;==================================================================================
0221   0000             ;
0222   0000             ; CODE SECTION 
0223   0000             
0224   0000                             .ORG $0000
0225   0000             ;------------------------------------------------------------------------------
0226   0000             ; Reset
0227   0000             
0228   0000 F3          RST00:          DI             ;Disable interrupts
0229   0001 C3 F3 00                    JP       INIT  ;Initialize Hardware and go
0230   0004             
0231   0004             ;------------------------------------------------------------------------------
0232   0004             ; TX a character over RS232 
0233   0004             
0234   0008                             .ORG     0008H
0235   0008 C3 BB 00    RST08:           JP      TXA
0236   000B             
0237   000B             ;------------------------------------------------------------------------------
0238   000B             ; RX a character over RS232 Channel A [Console], hold here until char ready.
0239   000B             
0240   0010                             .ORG 0010H
0241   0010 C3 9C 00    RST10:           JP      RXA
0242   0013             
0243   0013             ;------------------------------------------------------------------------------
0244   0013             ; Check serial status
0245   0013             
0246   0018                             .ORG 0018H
0247   0018 C3 E5 00    RST18:           JP      CKINCHAR
0248   001B             
0249   001B             ;------------------------------------------------------------------------------
0250   001B             ; INTERRUPT VECTOR ASCI Channel 0 [ IL = $01 for Vectors at $20 - $36 ]
0251   001B             
0252   0030                             .ORG     0020H+ASCI1_VECTOR
0253   0030 C3 40 00                    JP       serialInt
0254   0033             
0255   0033             ;------------------------------------------------------------------------------
0256   0033             ; RST 38 - INTERRUPT VECTOR INT0 [ with IM 1 ] - UNUSED
0257   0033             
0258   0038                             .ORG     0038H
0259   0038 F3          RST38:          DI             ;Disable interrupts
0260   0039 C3 F3 00                    JP       INIT  ;Initialize Hardware and go
0261   003C                             
0262   003C             ;------------------------------------------------------------------------------
0263   003C             ; ASCI Code
0264   003C             
0265   0040                             .ORG     0040H                              
0266   0040             serialInt:
0267   0040             
0268   0040 F5                  push af
0269   0041 E5                  push hl
0270   0042             
0271   0042             ; start doing the Rx stuff
0272   0042             
0273   0042 ED 38 05            in0 a, (STAT1)              ; get the status of the ASCI
0274   0045 E6 80               and SER_RDRF                ; check whether a byte has been received
0275   0047 28 20               jr z, tx_check              ; if not, go check for bytes to transmit 
0276   0049             
0277   0049 ED 38 09            in0 a, (RDR1)               ; Get the received byte from the ASCI 
0278   004C 6F                  ld l, a                     ; Move Rx byte to l
0279   004D             
0280   004D 3A F5 20            ld a, (serRxBufUsed)        ; Get the number of bytes in the Rx buffer
0281   0050 FE F0               cp SER_RX_BUFSIZE           ; check whether there is space in the buffer
0282   0052 30 15               jr nc, tx_check             ; buffer full, check if we can send something
0283   0054             
0284   0054 7D                  ld a, l                     ; get Rx byte from l
0285   0055 2A F1 20            ld hl, (serRxInPtr)         ; get the pointer to where we poke
0286   0058 77                  ld (hl), a                  ; write the Rx byte to the serRxInPtr address
0287   0059             
0288   0059 23                  inc hl                      ; move the Rx pointer along
0289   005A 7D                  ld a, l	                    ; move low byte of the Rx pointer
0290   005B FE F0               cp (serRxBuf + SER_RX_BUFSIZE) & $FF
0291   005D 20 03               jr nz, no_rx_wrap
0292   005F 21 00 20            ld hl, serRxBuf             ; we wrapped, so go back to start of buffer
0293   0062                 	
0294   0062             no_rx_wrap:
0295   0062             
0296   0062 22 F1 20            ld (serRxInPtr), hl         ; write where the next byte should be poked
0297   0065             
0298   0065 21 F5 20            ld hl, serRxBufUsed
0299   0068 34                  inc (hl)                    ; atomically increment Rx buffer count
0300   0069             
0301   0069             ; now start doing the Tx stuff
0302   0069             
0303   0069             tx_check:
0304   0069             
0305   0069 3A 0B 21            ld a, (serTxBufUsed)        ; get the number of bytes in the Tx buffer
0306   006C B7                  or a                        ; check whether it is zero
0307   006D 28 20               jr z, tie_clear             ; if the count is zero, then disable the Tx Interrupt
0308   006F             
0309   006F ED 38 05            in0 a, (STAT1)              ; get the status of the ASCI
0310   0072 E6 02               and SER_TDRE                ; check whether a byte can be transmitted
0311   0074 28 21               jr z, tx_end                ; if not, then end
0312   0076             
0313   0076 2A 09 21            ld hl, (serTxOutPtr)        ; get the pointer to place where we pop the Tx byte
0314   0079 7E                  ld a, (hl)                  ; get the Tx byte
0315   007A ED 39 07            out0 (TDR1), a              ; output the Tx byte to the ASCI
0316   007D             
0317   007D 23                  inc hl                      ; move the Tx pointer along
0318   007E 7D                  ld a, l                     ; get the low byte of the Tx pointer
0319   007F FE 06               cp (serTxBuf + SER_TX_BUFSIZE) & $FF
0320   0081 20 03               jr nz, no_tx_wrap
0321   0083 21 F6 20            ld hl, serTxBuf             ; we wrapped, so go back to start of buffer
0322   0086             
0323   0086             no_tx_wrap:
0324   0086             
0325   0086 22 09 21            ld (serTxOutPtr), hl        ; write where the next byte should be popped
0326   0089             
0327   0089 21 0B 21            ld hl, serTxBufUsed
0328   008C 35                  dec (hl)                    ; atomically decrement current Tx count
0329   008D 20 08               jr nz, tx_end               ; if we've more Tx bytes to send, we're done for now
0330   008F                     
0331   008F             tie_clear:
0332   008F             
0333   008F ED 38 05            in0 a, (STAT1)              ; get the ASCI status register
0334   0092 E6 FE               and ~SER_TIE                ; mask out (disable) the Tx Interrupt
0335   0094 ED 39 05            out0 (STAT1), a             ; set the ASCI status register
0336   0097             
0337   0097             tx_end:
0338   0097             
0339   0097 E1                  pop hl
0340   0098 F1                  pop af
0341   0099                     
0342   0099 FB                  ei
0343   009A ED 4D               reti
0344   009C             
0345   009C             ;------------------------------------------------------------------------------
0346   009C             RXA:
0347   009C             waitForRxChar:
0348   009C             
0349   009C 3A F5 20            ld a, (serRxBufUsed)        ; get the number of bytes in the Rx buffer
0350   009F             
0351   009F B7                  or a                        ; see if there are zero bytes available
0352   00A0 28 FA               jr z, waitForRxChar         ; wait, if there are no bytes available
0353   00A2                     
0354   00A2 E5                  push hl                     ; Store HL so we don't clobber it
0355   00A3             
0356   00A3 2A F3 20            ld hl, (serRxOutPtr)        ; get the pointer to place where we pop the Rx byte
0357   00A6 7E                  ld a, (hl)                  ; get the Rx byte
0358   00A7 F5                  push af                     ; save the Rx byte on stack
0359   00A8             
0360   00A8 23                  inc hl                      ; move the Rx pointer along
0361   00A9 7D                  ld a, l                     ; get the low byte of the Rx pointer
0362   00AA FE F0               cp (serRxBuf + SER_RX_BUFSIZE) & $FF
0363   00AC 20 03               jr nz, get_no_rx_wrap
0364   00AE 21 00 20            ld hl, serRxBuf             ; we wrapped, so go back to start of buffer
0365   00B1             
0366   00B1             get_no_rx_wrap:
0367   00B1             
0368   00B1 22 F3 20            ld (serRxOutPtr), hl        ; write where the next byte should be popped
0369   00B4             
0370   00B4 21 F5 20            ld hl,serRxBufUsed
0371   00B7 35                  dec (hl)                    ; atomically decrement Rx count
0372   00B8             
0373   00B8 F1                  pop af                      ; get the Rx byte from stack
0374   00B9 E1                  pop hl                      ; recover HL
0375   00BA             
0376   00BA C9                  ret                         ; char ready in A
0377   00BB             
0378   00BB             ;------------------------------------------------------------------------------
0379   00BB             TXA:
0380   00BB E5                  push hl                     ; Store HL so we don't clobber it        
0381   00BC 6F                  ld l, a                     ; Store Tx character 
0382   00BD             
0383   00BD 3A 0B 21            ld a, (serTxBufUsed)        ; Get the number of bytes in the Tx buffer
0384   00C0 FE 10               cp SER_TX_BUFSIZE           ; check whether there is space in the buffer
0385   00C2 30 1F               jr nc, clean_up_tx          ; buffer full, so abandon Tx
0386   00C4                     
0387   00C4 7D                  ld a, l                     ; Retrieve Tx character
0388   00C5 2A 07 21            ld hl, (serTxInPtr)         ; get the pointer to where we poke
0389   00C8 77                  ld (hl), a                  ; write the Tx byte to the serTxInPtr   
0390   00C9 23                  inc hl                      ; move the Tx pointer along
0391   00CA             
0392   00CA 7D                  ld a, l                     ; move low byte of the Tx pointer
0393   00CB FE 06               cp (serTxBuf + SER_TX_BUFSIZE) & $FF
0394   00CD 20 03               jr nz, put_no_tx_wrap
0395   00CF 21 F6 20            ld hl, serTxBuf             ; we wrapped, so go back to start of buffer
0396   00D2             
0397   00D2             put_no_tx_wrap:
0398   00D2             
0399   00D2 22 07 21            ld (serTxInPtr), hl         ; write where the next byte should be poked
0400   00D5             
0401   00D5 21 0B 21            ld hl, serTxBufUsed
0402   00D8 34                  inc (hl)                    ; atomic increment of Tx count
0403   00D9             
0404   00D9 F3                  di                          ; critical section begin
0405   00DA                    
0406   00DA ED 38 05            in0 a, (STAT1)              ; get the ASCI status register
0407   00DD F6 01               or SER_TIE                  ; mask in (enable) the Tx Interrupt
0408   00DF ED 39 05            out0 (STAT1), a             ; set the ASCI status register
0409   00E2                     
0410   00E2 FB                  ei                          ; critical section end
0411   00E3                     
0412   00E3             clean_up_tx:        
0413   00E3                     
0414   00E3 E1                  pop hl                      ; recover HL
0415   00E4             
0416   00E4 C9                  ret
0417   00E5             
0418   00E5             ;------------------------------------------------------------------------------
0419   00E5 3A F5 20    CKINCHAR:      LD        A,(serRxBufUsed)
0420   00E8 FE 00                      CP        $0
0421   00EA C9                         RET
0422   00EB             
0423   00EB 7E          PRINT:         LD        A,(HL)          ; Get character
0424   00EC B7                         OR        A               ; Is it $00 ?
0425   00ED C8                         RET       Z               ; Then RETurn on terminator
0426   00EE CF                         RST       08H             ; Print it
0427   00EF 23                         INC       HL              ; Next Character
0428   00F0 18 F9                      JR        PRINT           ; Continue until $00
0429   00F2 C9                         RET
0430   00F3             ;------------------------------------------------------------------------------
0431   00F3             INIT:
0432   00F3 AF                         XOR       A               ; $00
0433   00F4             
0434   00F4                                                      ; Disable external interrupts  
0435   00F4 ED 39 34                   OUT0      (ITC),A         ; until Int Vector Table initialized
0436   00F7             
0437   00F7                                                      ; Disable PRT downcounting,
0438   00F7 ED 39 10                   OUT0      (TCR),A         ; until Int Vector Table initialized
0439   00FA             
0440   00FA                                                      ; Clear I/O Control Reg (ICR)
0441   00FA ED 39 3F                   OUT0      (ICR),A         ; Standard I/O Mapping (0 Enabled)
0442   00FD             
0443   00FD                                                      ; Clear Refresh Control Reg (RCR)
0444   00FD ED 39 36                   OUT0      (RCR),A         ; DRAM Refresh Enable (0 Disabled)
0445   0100             
0446   0100                                                      ; Set Operation Mode Control Reg (OMCR)
0447   0100 3E 80                      LD        A,OMCR_M1E      ; Enable M1, but disable 64180 I/O RD Mode
0448   0102 ED 39 3E                   OUT0      (OMCR),A        ; X80 Mode (M1E Enabled, OIC Disabled)
0449   0105             
0450   0105                                                      ; Set internal clock = crystal x 2
0451   0105                                                      ; if using ZS8180 or Z80182 at High-Speed
0452   0105 3E 80                      LD        A,CMR_X2        ; Set Hi-Speed flag
0453   0107 ED 39 1E                   OUT0	     (CMR),A         ; CPU Clock Multiplier Reg (CMR)
0454   010A             
0455   010A                                                      ; Bypass PHI = internal clock / 2
0456   010A                                                      ; if using ZS8180 or Z80182 at High-Speed
0457   010A             ;              LD	     A,CCR_XTAL_X2   ; Set Hi-Speed flag: PHI = internal clock
0458   010A             ;              OUT0      (CCR),A         ; CPU Control Reg (CCR)
0459   010A                            
0460   010A FD E3                      EX        (SP),IY         ; (settle)
0461   010C FD E3                      EX        (SP),IY         ; (settle)               
0462   010E             
0463   010E                                                      ; Set Logical Addresses
0464   010E                                                      ; $8000-$FFFF RAM CA1 -> 80H
0465   010E                                                      ; $4000-$7FFF RAM BANK -> 04H
0466   010E                                                      ; $2000-$3FFF RAM CA0
0467   010E                                                      ; $0000-$1FFF Flash CA0
0468   010E 3E 84                      LD        A,84H           ; Set New Common / Bank Areas
0469   0110 ED 39 3A                   OUT0      (CBAR),A        ; for RAM
0470   0113             
0471   0113                                                      ; Physical Addresses
0472   0113 3E 80                      LD        A,80H           ; Set Common 1 Area $80000 -> 80H
0473   0115 ED 39 38                   OUT0      (CBR),A
0474   0118                            
0475   0118 3E 40                      LD        A,40H           ; Set Bank Area $40000 -> 40H
0476   011A ED 39 39                   OUT0      (BBR),A
0477   011D             
0478   011D 21 CB 21                   LD        HL,TEMPSTACK    ; Temp stack
0479   0120 F9                         LD        SP,HL           ; Set up a temporary stack
0480   0121             
0481   0121 21 00 20                   LD        HL,serRxBuf     ; Initialise Rx Buffer
0482   0124 22 F1 20                   LD        (serRxInPtr),HL
0483   0127 22 F3 20                   LD        (serRxOutPtr),HL
0484   012A             
0485   012A 21 F6 20                   LD        HL,serTxBuf     ; Initialise Tx Buffer
0486   012D 22 07 21                   LD        (serTxInPtr),HL
0487   0130 22 09 21                   LD        (serTxOutPtr),HL              
0488   0133             
0489   0133 AF                         XOR       A               ; 0 the accumulator
0490   0134 32 F5 20                   LD        (serRxBufUsed),A
0491   0137 32 0B 21                   LD        (serTxBufUsed),A
0492   013A             
0493   013A                                                      ; load the default ASCI configuration
0494   013A                                                      ; 
0495   013A                                                      ; BAUD = 115200 8n1
0496   013A                                                      ; receive enabled
0497   013A                                                      ; transmit enabled                                         
0498   013A                                                      ; receive interrupt enabled
0499   013A                                                      ; transmit interrupt disabled
0500   013A                                                      
0501   013A 3E 64                      LD        A,SER_RE|SER_TE|SER_8N1
0502   013C ED 39 01                   OUT0      (CNTLA1),A      ; output to the ASCI1 control A reg
0503   013F             
0504   013F                                                      ; PHI / PS / SS / DR = BAUD Rate
0505   013F                                                      ; PHI = 18.432MHz
0506   013F                                                      ; BAUD = 115200 = 18432000 / 10 / 1 / 16 
0507   013F                                                      ; PS 0, SS_DIV_1 0, DR 0           
0508   013F AF                         XOR        A              ; BAUD = 115200
0509   0140 ED 39 03                   OUT0      (CNTLB1),A      ; output to the ASCI0 control B reg
0510   0143                            
0511   0143                                                      ; set interrupt vector for ASCI Channel 1
0512   0143 3E 20                      LD        A,$20           ; IL = $20 [001xxxxx] for Vectors at $20 - $36
0513   0145 ED 39 33                   OUT0      (IL),A          ; output to the Interrupt Vector Low reg               
0514   0148                            
0515   0148 3E 08                      LD        A,SER_RIE       ; receive interrupt enabled
0516   014A ED 39 05                   OUT0      (STAT1),A       ; output to the ASCI1 status reg
0517   014D                                              
0518   014D ED 56                      IM        1               ; interrupt mode 1 for INT0 (unused)
0519   014F FB                         EI                        ; enable interrupts
0520   0150             
0521   0150 21 89 01                   LD        HL,SIGNON1      ; Sign-on message
0522   0153 CD EB 00                   CALL      PRINT           ; Output string
0523   0156 3A 0C 21                   LD        A,(basicStarted); Check the BASIC STARTED flag
0524   0159 FE 59                      CP        'Y'             ; to see if this is power-up
0525   015B 20 16                      JR        NZ,COLDSTART    ; If not BASIC started then always do cold start
0526   015D 21 9C 01                   LD        HL,SIGNON2      ; Cold/warm message
0527   0160 CD EB 00                   CALL      PRINT           ; Output string
0528   0163             CORW:
0529   0163 CD 9C 00                   CALL      RXA
0530   0166 E6 DF                      AND       %11011111       ; lower to uppercase
0531   0168 FE 43                      CP        'C'
0532   016A 20 0F                      JR        NZ, CHECKWARM
0533   016C CF                         RST       08H
0534   016D 3E 0D                      LD        A,$0D
0535   016F CF                         RST       08H
0536   0170 3E 0A                      LD        A,$0A
0537   0172 CF                         RST       08H
0538   0173 3E 59       COLDSTART:     LD        A,'Y'           ; Set the BASIC STARTED flag
0539   0175 32 0C 21                   LD        (basicStarted),A
0540   0178 C3 C0 01                   JP        $01C0           ; <<<< Start BASIC COLD
0541   017B             CHECKWARM:
0542   017B FE 57                      CP        'W'
0543   017D 20 E4                      JR        NZ, CORW
0544   017F CF                         RST       08H
0545   0180 3E 0D                      LD        A,$0D
0546   0182 CF                         RST       08H
0547   0183 3E 0A                      LD        A,$0A
0548   0185 CF                         RST       08H
0549   0186 C3 C3 01                   JP        $01C3           ; <<<< Start BASIC WARM
0550   0189             
0551   0189 59415A313830SIGNON1:       .BYTE     "YAZ180 - feilipu",CR,LF,0
0551   018F 202D206665696C6970750D0A00
0552   019C 0D 0A       SIGNON2:       .BYTE     CR,LF
0553   019E 436F6C64206F               .BYTE     "Cold or warm start (C|W) ?",0
0553   01A4 72207761726D2073746172742028437C5729203F00
0554   01B9             
0555   01B9                            .END



Label        Value      Label        Value      Label        Value
------------------      ------------------      ------------------
ASEXT0        0012      ASEXT1        0013      ASTC0L        001A      
ASTC0H        001B      ASTC1L        001C      ASTC1H        001D      
ASCI0_VECTOR  000E      ASCI1_VECTOR  0010      BCR0L         0026      
BCR0H         0027      BCR1L         002E      BCR1H         002F      
BBR           0039      CNTLA0        0000      CNTLA1        0001      
CNTLB0        0002      CNTLB1        0003      CNTR          000A      
CMR           001E      CCR           001F      CBR           0038      
CBAR          003A      CMR_X2        0080      CMR_LN_XTAL   0040      
CCR_XTAL_X2   0080      CCR_STANDBY   0040      CCR_BREXT     0020      
CCR_LNPHI     0010      CCR_IDLE      0008      CCR_LNIO      0004      
CCR_LNCPUCTL  0002      CCR_LNAD      0001      CSIO_VECTOR   000C      
CR            000D      CS            000C      CKINCHAR      00E5      
CORW          0163      COLDSTART     0173      CHECKWARM     017B      
DAR0L         0023      DAR0H         0024      DAR0B         0025      
DSTAT         0030      DMODE         0031      DCNTL         0032      
DMA0_VECTOR   0008      DMA1_VECTOR   000A      FRC           0018      
IAR1L         002B      IAR1H         002C      IL            0033      
ITC           0034      ICR           003F      INT1_VECTOR   0000      
INT2_VECTOR   0002      INCAP_VECTOR  0012      INIT          00F3      
LF            000A      MAR1L         0028      MAR1H         0029      
MAR1B         002A      OMCR          003E      OMCR_M1E      0080      
OMCR_M1TE     0040      OMCR_IOC      0020      OUTCMP_VECTOR 0014      
PRT0_VECTOR   0004      PRT1_VECTOR   0006      PRINT         00EB      
RDR0          0008      RDR1          0009      RLDR0L        000E      
RLDR0H        000F      RLDR1L        0016      RLDR1H        0017      
RCR           0036      RCR_REFE      0080      RCR_REFW      0040      
RST00         0000      RST08         0008      RST10         0010      
RST18         0018      RST38         0038      RXA           009C      
STAT0         0004      STAT1         0005      SAR0L         0020      
SAR0H         0021      SAR0B         0022      SER_MPE       0080      
SER_RE        0040      SER_TE        0020      SER_RTS0      0010      
SER_EFR       0008      SER_7N1       0000      SER_7N2       0001      
SER_7P1       0002      SER_7P2       0003      SER_8N1       0004      
SER_8N2       0005      SER_8P1       0006      SER_8P2       0007      
SER_MPBT      0080      SER_MP        0040      SER_PS        0020      
SER_PEO       0010      SER_DR        0008      SER_SS_DIV_1  0000      
SER_SS_DIV_2  0001      SER_SS_DIV_4  0002      SER_SS_DIV_8  0003      
SER_SS_DIV_16 0004      SER_SS_DIV_32 0005      SER_SS_DIV_64 0006      
SER_SS_EXT    0007      SER_RDRF      0080      SER_OVRN      0040      
SER_PE        0020      SER_FE        0010      SER_RIE       0008      
SER_DCD0      0004      SER_CTS1      0004      SER_TDRE      0002      
SER_TIE       0001      SER_RX_BUFSIZE 00F0      SER_TX_BUFSIZE 0010      
SIGNON1       0189      SIGNON2       019C      TDR0          0006      
TDR1          0007      TRDR          000B      TMDR0L        000C      
TMDR0H        000D      TCR           0010      TMDR1L        0014      
TMDR1H        0015      TIMOV_VECTOR  0016      TEMPSTACK     21CB      
TXA           00BB      basicStarted  210C      clean_up_tx   00E3      
get_no_rx_wrap 00B1      no_rx_wrap    0062      no_tx_wrap    0086      
put_no_tx_wrap 00D2      serRxBuf      2000      serRxInPtr    20F1      
serRxOutPtr   20F3      serRxBufUsed  20F5      serTxBuf      20F6      
serTxInPtr    2107      serTxOutPtr   2109      serTxBufUsed  210B      
serialInt     0040      tx_check      0069      tie_clear     008F      
tx_end        0097      waitForRxChar 009C      

tasm: Number of errors = 0
