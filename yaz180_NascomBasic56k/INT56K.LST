0001   0000             ;==================================================================================
0002   0000             ; Contents of this file are copyright Phillip Stevens
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; Initialisation routines to suit Z8S180 CPU, with internal USART.
0008   0000             ;
0009   0000             ; Internal USART interrupt driven serial I/O to run modified NASCOM Basic 4.7.
0010   0000             
0011   0000             ; Full input and output buffering with incoming data hardware handshaking.
0012   0000             ; Handshake shows full before the buffer is totally filled to
0013   0000             ; allow run-on from the sender.
0014   0000             ;
0015   0000             ; https://github.com/feilipu/
0016   0000             ;
0017   0000             ; https://feilipu.me/
0018   0000             ;
0019   0000             ;==================================================================================
0020   0000             ;
0021   0000             ; Z180 Register Mnemonics
0022   0000             ;
0023   0000             
0024   0000             IO_BASE         .EQU    $00     ; Internal I/O Base Address (ICR) <<< SET THIS AS DESIRED >>>
0025   0000             
0026   0000             CNTLA0          .EQU    IO_BASE+$00     ; ASCI Control Reg A Ch 0
0027   0000             CNTLA1          .EQU    IO_BASE+$01     ; ASCI Control Reg A Ch 1
0028   0000             CNTLB0          .EQU    IO_BASE+$02     ; ASCI Control Reg B Ch 0
0029   0000             CNTLB1          .EQU    IO_BASE+$03     ; ASCI Control Reg B Ch 1
0030   0000             STAT0           .EQU    IO_BASE+$04     ; ASCI Status  Reg   Ch 0
0031   0000             STAT1           .EQU    IO_BASE+$05     ; ASCI Status  Reg   Ch 1
0032   0000             TDR0            .EQU    IO_BASE+$06     ; ASCI Tx Data Reg   Ch 0
0033   0000             TDR1            .EQU    IO_BASE+$07     ; ASCI Tx Data Reg   Ch 1
0034   0000             RDR0            .EQU    IO_BASE+$08     ; ASCI Rx Data Reg   Ch 0
0035   0000             RDR1            .EQU    IO_BASE+$09     ; ASCI Rx Data Reg   Ch 1
0036   0000             
0037   0000             ASEXT0          .EQU    IO_BASE+$12     ; ASCI Extension Control Reg Ch 0 (Z8S180 & higher Only)
0038   0000             ASEXT1          .EQU    IO_BASE+$13     ; ASCI Extension Control Reg Ch 1 (Z8S180 & higher Only)
0039   0000             
0040   0000             ASTC0L          .EQU    IO_BASE+$1A     ; ASCI Time Constant Ch 0 Low (Z8S180 & higher Only)
0041   0000             ASTC0H          .EQU    IO_BASE+$1B     ; ASCI Time Constant Ch 0 High (Z8S180 & higher Only)
0042   0000             ASTC1L          .EQU    IO_BASE+$1C     ; ASCI Time Constant Ch 1 Low (Z8S180 & higher Only)
0043   0000             ASTC1H          .EQU    IO_BASE+$1D     ; ASCI Time Constant Ch 1 High (Z8S180 & higher Only)
0044   0000             
0045   0000             CNTR            .EQU    IO_BASE+$0A     ; CSI/O Control Reg
0046   0000             TRDR            .EQU    IO_BASE+$0B     ; CSI/O Tx/Rx Data Reg
0047   0000             
0048   0000             TMDR0L          .EQU    IO_BASE+$0C     ; Timer Data Reg Ch 0 Low
0049   0000             TMDR0H          .EQU    IO_BASE+$0D     ; Timer Data Reg Ch 0 High
0050   0000             RLDR0L          .EQU    IO_BASE+$0E     ; Timer Reload Reg Ch 0 Low
0051   0000             RLDR0H          .EQU    IO_BASE+$0F     ; Timer Reload Reg Ch 0 High
0052   0000             TCR             .EQU    IO_BASE+$10     ; Timer Control Reg
0053   0000             
0054   0000             TMDR1L          .EQU    IO_BASE+$14     ; Timer Data Reg Ch 1 Low
0055   0000             TMDR1H          .EQU    IO_BASE+$15     ; Timer Data Reg Ch 1 High
0056   0000             RLDR1L          .EQU    IO_BASE+$16     ; Timer Reload Reg Ch 1 Low
0057   0000             RLDR1H          .EQU    IO_BASE+$17     ; Timer Reload Reg Ch 1 High
0058   0000             
0059   0000             FRC             .EQU    IO_BASE+$18     ; Free-Running Counter
0060   0000             
0061   0000             CMR             .EQU    IO_BASE+$1E     ; CPU Clock Multiplier Reg (Z8S180 & higher Only)
0062   0000             CCR             .EQU    IO_BASE+$1F     ; CPU Control Reg (Z8S180 & higher Only)
0063   0000             
0064   0000             SAR0L           .EQU    IO_BASE+$20     ; DMA Source Addr Reg Ch0-Low
0065   0000             SAR0H           .EQU    IO_BASE+$21     ; DMA Source Addr Reg Ch0-High
0066   0000             SAR0B           .EQU    IO_BASE+$22     ; DMA Source Addr Reg Ch0-Bank
0067   0000             DAR0L           .EQU    IO_BASE+$23     ; DMA Dest Addr Reg Ch0-Low
0068   0000             DAR0H           .EQU    IO_BASE+$24     ; DMA Dest Addr Reg Ch0-High
0069   0000             DAR0B           .EQU    IO_BASE+$25     ; DMA Dest ADDR REG CH0-Bank
0070   0000             BCR0L           .EQU    IO_BASE+$26     ; DMA Byte Count Reg Ch0-Low
0071   0000             BCR0H           .EQU    IO_BASE+$27     ; DMA Byte Count Reg Ch0-High
0072   0000             MAR1L           .EQU    IO_BASE+$28     ; DMA Memory Addr Reg Ch1-Low
0073   0000             MAR1H           .EQU    IO_BASE+$29     ; DMA Memory Addr Reg Ch1-High
0074   0000             MAR1B           .EQU    IO_BASE+$2A     ; DMA Memory Addr Reg Ch1-Bank
0075   0000             IAR1L           .EQU    IO_BASE+$2B     ; DMA I/O Addr Reg Ch1-Low
0076   0000             IAR1H           .EQU    IO_BASE+$2C     ; DMA I/O Addr Reg Ch2-High
0077   0000             BCR1L           .EQU    IO_BASE+$2E     ; DMA Byte Count Reg Ch1-Low
0078   0000             BCR1H           .EQU    IO_BASE+$2F     ; DMA Byte Count Reg Ch1-High
0079   0000             DSTAT           .EQU    IO_BASE+$30     ; DMA Status Reg
0080   0000             DMODE           .EQU    IO_BASE+$31     ; DMA Mode Reg
0081   0000             DCNTL           .EQU    IO_BASE+$32     ; DMA/Wait Control Reg
0082   0000             
0083   0000             IL              .EQU    IO_BASE+$33     ; INT Vector Low Reg
0084   0000             ITC             .EQU    IO_BASE+$34     ; INT/TRAP Control Reg
0085   0000             
0086   0000             RCR             .EQU    IO_BASE+$36     ; Refresh Control Reg
0087   0000             
0088   0000             CBR             .EQU    IO_BASE+$38     ; MMU Common Base Reg
0089   0000             BBR             .EQU    IO_BASE+$39     ; MMU Bank Base Reg
0090   0000             CBAR            .EQU    IO_BASE+$3A     ; MMU Common/Bank Area Reg
0091   0000             
0092   0000             OMCR            .EQU    IO_BASE+$3E     ; Operation Mode Control Reg
0093   0000             ICR             .EQU    IO_BASE+$3F     ; I/O Control Reg
0094   0000             
0095   0000             
0096   0000             ;==================================================================================
0097   0000             ;
0098   0000             ; Interrupt vectors (offsets) for Z180/HD64180 internal interrupts
0099   0000             ;
0100   0000             
0101   0000             VECTOR_BASE     .EQU   $80      ; Vector Base address (IL) <<< SET THIS AS DESIRED >>>
0102   0000             
0103   0000             VECTOR_INT1     .EQU   VECTOR_BASE+$00    ; external /INT1 
0104   0000             VECTOR_INT2     .EQU   VECTOR_BASE+$02    ; external /INT2 
0105   0000             VECTOR_PRT0     .EQU   VECTOR_BASE+$04    ; PRT channel 0 
0106   0000             VECTOR_PRT1     .EQU   VECTOR_BASE+$06    ; PRT channel 1 
0107   0000             VECTOR_DMA0     .EQU   VECTOR_BASE+$08    ; DMA channel 0 
0108   0000             VECTOR_DMA1     .EQU   VECTOR_BASE+$0A    ; DMA Channel 1 
0109   0000             VECTOR_CSIO     .EQU   VECTOR_BASE+$0C    ; Clocked serial I/O 
0110   0000             VECTOR_ASCI0    .EQU   VECTOR_BASE+$0E    ; Async channel 0 
0111   0000             VECTOR_ASCI1    .EQU   VECTOR_BASE+$10    ; Async channel 1 
0112   0000             
0113   0000             ;==================================================================================
0114   0000             ;
0115   0000             ; Some bit definitions used with the Z-180 on-chip peripherals:
0116   0000             ;
0117   0000             
0118   0000             ; ASCI Control Reg A (CNTLAn)
0119   0000             
0120   0000             SER_MPE         .EQU   $80    ; Multi Processor Enable
0121   0000             SER_RE          .EQU   $40    ; Receive Enable
0122   0000             SER_TE          .EQU   $20    ; Transmit Enable
0123   0000             SER_RTS0        .EQU   $10    ; _RTS Request To Send
0124   0000             SER_EFR         .EQU   $08    ; Error Flag Reset
0125   0000             
0126   0000             SER_7N1         .EQU   $00    ; 7 Bits No Parity 1 Stop Bit
0127   0000             SER_7N2         .EQU   $01    ; 7 Bits No Parity 2 Stop Bits
0128   0000             SER_7P1         .EQU   $02    ; 7 Bits    Parity 1 Stop Bit
0129   0000             SER_7P2         .EQU   $03    ; 7 Bits    Parity 2 Stop Bits
0130   0000             SER_8N1         .EQU   $04    ; 8 Bits No Parity 1 Stop Bit
0131   0000             SER_8N2         .EQU   $05    ; 8 Bits No Parity 2 Stop Bits
0132   0000             SER_8P1         .EQU   $06    ; 8 Bits    Parity 1 Stop Bit
0133   0000             SER_8P2         .EQU   $07    ; 8 Bits    Parity 2 Stop Bits
0134   0000             
0135   0000             ; ASCI Control Reg B (CNTLBn)
0136   0000                                           ; BAUD Rate = PHI / PS / SS / DR
0137   0000             
0138   0000             SER_MPBT        .EQU   $80    ; Multi Processor Bit Transmit
0139   0000             SER_MP          .EQU   $40    ; Multi Processor
0140   0000             SER_PS          .EQU   $20    ; Prescale PHI by 10 (PS 0) or 30 (PS 1)
0141   0000             SER_PEO         .EQU   $10    ; Parity Even or Odd
0142   0000             SER_DR          .EQU   $08    ; Divide SS by 16 (DR 0) or 64 (DR 1)
0143   0000             
0144   0000             SER_SS_DIV_1    .EQU   $00    ; Divide PS by  1
0145   0000             SER_SS_DIV_2    .EQU   $01    ; Divide PS by  2
0146   0000             SER_SS_DIV_4    .EQU   $02    ; Divide PS by  4
0147   0000             SER_SS_DIV_8    .EQU   $03    ; Divide PS by  8
0148   0000             SER_SS_DIV_16   .EQU   $04    ; Divide PS by 16
0149   0000             SER_SS_DIV_32   .EQU   $05    ; Divide PS by 32
0150   0000             SER_SS_DIV_64   .EQU   $06    ; Divide PS by 64
0151   0000             SER_SS_EXT      .EQU   $07    ; External Clock Source <= PHI / 40
0152   0000             
0153   0000             ; ASCI Status Reg (STATn)
0154   0000             
0155   0000             SER_RDRF        .EQU   $80    ; Receive Data Register Full
0156   0000             SER_OVRN        .EQU   $40    ; Overrun (Received Byte)
0157   0000             SER_PE          .EQU   $20    ; Parity Error (Received Byte)
0158   0000             SER_FE          .EQU   $10    ; Framing Error (Received Byte)
0159   0000             SER_RIE         .EQU   $08    ; Receive Interrupt Enabled
0160   0000             SER_DCD0        .EQU   $04    ; _DCD0 Data Carrier Detect USART0
0161   0000             SER_CTS1        .EQU   $04    ; _CTS1 Clear To Send USART1
0162   0000             SER_TDRE        .EQU   $02    ; Transmit Data Register Empty
0163   0000             SER_TIE         .EQU   $01    ; Transmit Interrupt Enabled
0164   0000             
0165   0000             ; CPU Clock Multiplier Reg (CMR) (Z8S180 & higher Only)
0166   0000             
0167   0000             CMR_X2          .EQU   $80    ; CPU x2 XTAL Multiplier Mode
0168   0000             CMR_LN_XTAL     .EQU   $40    ; Low Noise Crystal 
0169   0000             
0170   0000             ; CPU Control Reg (CCR) (Z8S180 & higher Only)
0171   0000             
0172   0000             CCR_XTAL_X2     .EQU   $80    ; PHI = XTAL Mode
0173   0000             CCR_STANDBY     .EQU   $40    ; STANDBY after SLEEP
0174   0000             CCR_BREXT       .EQU   $20    ; Exit STANDBY on BUSREQ
0175   0000             CCR_LNPHI       .EQU   $10    ; Low Noise PHI (30% Drive)
0176   0000             CCR_IDLE        .EQU   $08    ; IDLE after SLEEP
0177   0000             CCR_LNIO        .EQU   $04    ; Low Noise I/O Signals (30% Drive)
0178   0000             CCR_LNCPUCTL    .EQU   $02    ; Low Noise CPU Control Signals (30% Drive)
0179   0000             CCR_LNAD        .EQU   $01    ; Low Noise Address and Data Signals (30% Drive)
0180   0000             
0181   0000             ; Refresh Control Reg (RCR)
0182   0000             
0183   0000             RCR_REFE        .EQU   $80    ; DRAM Refresh Enable (0 Disabled)
0184   0000             RCR_REFW        .EQU   $40    ; DRAM Refresh 2 or 3 Wait states (0 2 Wait States)
0185   0000             
0186   0000             ; Operation Mode Control Reg (OMCR)
0187   0000             
0188   0000             OMCR_M1E        .EQU   $80    ; M1 Enable (0 Disabled)
0189   0000             OMCR_M1TE       .EQU   $40    ; M1 Temporary Enable
0190   0000             OMCR_IOC        .EQU   $20    ; IO Control (1 64180 Mode)
0191   0000             
0192   0000             ;==================================================================================
0193   0000             ;
0194   0000             ; DEFINES SECTION
0195   0000             
0196   0000                                            ; end of ASCI stuff is $210D
0197   0000                                            ; set BASIC Work space WRKSPC $2120
0198   0000             
0199   0000             TEMPSTACK       .EQU     $21CB ; Top of BASIC line input buffer (CURPOS WRKSPC+0ABH)
0200   0000                                            ; so it is "free ram" when BASIC resets
0201   0000             
0202   0000             CR              .EQU     0DH
0203   0000             LF              .EQU     0AH
0204   0000             CS              .EQU     0CH   ; Clear screen
0205   0000             
0206   0000             ;==================================================================================
0207   0000             ;
0208   0000             ; VARIABLES SECTION
0209   0000             
0210   0000             SER_RX_BUFSIZE  .EQU     $F0  ; Size of the Rx Buffer, 239 Bytes
0211   0000             SER_TX_BUFSIZE  .EQU     $10  ; Size of the Tx Buffer, 15 Bytes
0212   0000                  
0213   0000             serRxBuf        .EQU     $2000
0214   0000             serRxInPtr      .EQU     serRxBuf+SER_RX_BUFSIZE+1
0215   0000             serRxOutPtr     .EQU     serRxInPtr+2
0216   0000             serRxBufUsed    .EQU     serRxOutPtr+2
0217   0000             serTxBuf        .EQU     serRxBufUsed+1
0218   0000             serTxInPtr      .EQU     serTxBuf+SER_TX_BUFSIZE+1
0219   0000             serTxOutPtr     .EQU     serTxInPtr+2
0220   0000             serTxBufUsed    .EQU     serTxOutPtr+2
0221   0000             basicStarted    .EQU     serTxBufUsed+1
0222   0000             
0223   0000             ;==================================================================================
0224   0000             ;
0225   0000             ; Z80 INTERRUPT VECTOR SECTION 
0226   0000             ;
0227   0000             
0228   0000             ;------------------------------------------------------------------------------
0229   0000             ; RESET - Reset
0230   0000             
0231   0000                             .ORG $0000
0232   0000 F3          RST00:          DI             ; Disable interrupts
0233   0001 C3 B3 01                    JP       INIT  ; Initialize Hardware and go
0234   0004             
0235   0004             ;------------------------------------------------------------------------------
0236   0004             ; RST08 - TX a character over ASCI
0237   0004             
0238   0008                             .ORG     0008H
0239   0008 C3 7B 01    RST08:          JP      TXA
0240   000B             
0241   000B             ;------------------------------------------------------------------------------
0242   000B             ; RST10 - RX a character over ASCI Channel [Console], hold here until char ready.
0243   000B             
0244   0010                             .ORG 0010H
0245   0010 C3 5C 01    RST10:          JP      RXA
0246   0013             
0247   0013             ;------------------------------------------------------------------------------
0248   0013             ; RST18 - Check serial status
0249   0013             
0250   0018                             .ORG 0018H
0251   0018 C3 A5 01    RST18:          JP      CKINCHAR
0252   001B             
0253   001B                             
0254   001B             ;------------------------------------------------------------------------------
0255   001B             ; RST 20
0256   001B             
0257   0020                             .ORG     0020H
0258   0020 ED 4D       RST20:          RETI           ; just return
0259   0022                        
0260   0022             ;------------------------------------------------------------------------------
0261   0022             ; RST 28
0262   0022             
0263   0028                             .ORG     0028H
0264   0028 ED 4D       RST28:          RETI           ; just return
0265   002A             
0266   002A             ;------------------------------------------------------------------------------
0267   002A             ; RST 30
0268   002A             ;
0269   0030                             .ORG     0030H
0270   0030 ED 4D       RST30:          RETI           ; just return
0271   0032             
0272   0032             ;------------------------------------------------------------------------------
0273   0032             ; RST 38 - INTERRUPT VECTOR INT0 [ with IM 1 ]
0274   0032             
0275   0038                             .ORG     0038H
0276   0038 ED 4D       RST38:          RETI           ; just return
0277   003A             
0278   003A             ;------------------------------------------------------------------------------
0279   003A             ; NMI - INTERRUPT VECTOR NMI
0280   003A             
0281   0066                             .ORG     0066H
0282   0066 ED 45       NMI:            RETN           ; just return
0283   0068               
0284   0068             
0285   0068             ;==================================================================================
0286   0068             ;
0287   0068             ; Z180 INTERRUPT VECTOR SECTION 
0288   0068             ;
0289   0068             
0290   0068             ;------------------------------------------------------------------------------
0291   0068             ; INTERRUPT VECTOR ASCI Channel 1 [ Vector at $90 ]
0292   0068             
0293   0090                             .ORG     VECTOR_ASCI1
0294   0090 C3 00 01                    JP       serialInt
0295   0093             
0296   0093             ;==================================================================================
0297   0093             ;
0298   0093             ; CODE SECTION
0299   0093             ;
0300   0093             
0301   0100                             .ORG     0100H                              
0302   0100             serialInt:
0303   0100             
0304   0100 F5                  push af
0305   0101 E5                  push hl
0306   0102             
0307   0102             ; start doing the Rx stuff
0308   0102             
0309   0102 3E 80               ld a, SER_RDRF              ; prepare Rx test
0310   0104 ED 74 05            tstio STAT1                 ; test whether we have received on ASCI1
0311   0107 28 20               jr z, tx_check              ; if not, go check for bytes to transmit 
0312   0109             
0313   0109 ED 38 09            in0 a, (RDR1)               ; Get the received byte from the ASCI 
0314   010C 6F                  ld l, a                     ; Move Rx byte to l
0315   010D             
0316   010D 3A F5 20            ld a, (serRxBufUsed)        ; Get the number of bytes in the Rx buffer
0317   0110 FE F0               cp SER_RX_BUFSIZE           ; check whether there is space in the buffer
0318   0112 30 15               jr nc, tx_check             ; buffer full, check if we can send something
0319   0114             
0320   0114 7D                  ld a, l                     ; get Rx byte from l
0321   0115 2A F1 20            ld hl, (serRxInPtr)         ; get the pointer to where we poke
0322   0118 77                  ld (hl), a                  ; write the Rx byte to the serRxInPtr address
0323   0119             
0324   0119 23                  inc hl                      ; move the Rx pointer along
0325   011A 7D                  ld a, l	                    ; move low byte of the Rx pointer
0326   011B FE F0               cp (serRxBuf + SER_RX_BUFSIZE) & $FF
0327   011D 20 03               jr nz, no_rx_wrap
0328   011F 21 00 20            ld hl, serRxBuf             ; we wrapped, so go back to start of buffer
0329   0122                 	
0330   0122             no_rx_wrap:
0331   0122             
0332   0122 22 F1 20            ld (serRxInPtr), hl         ; write where the next byte should be poked
0333   0125             
0334   0125 21 F5 20            ld hl, serRxBufUsed
0335   0128 34                  inc (hl)                    ; atomically increment Rx buffer count
0336   0129             
0337   0129             ; now start doing the Tx stuff
0338   0129             
0339   0129             tx_check:
0340   0129             
0341   0129 3A 0B 21            ld a, (serTxBufUsed)        ; get the number of bytes in the Tx buffer
0342   012C B7                  or a                        ; check whether it is zero
0343   012D 28 20               jr z, tie_clear             ; if the count is zero, then disable the Tx Interrupt
0344   012F             
0345   012F 3E 02               ld a, SER_TDRE              ; prepare Tx test
0346   0131 ED 74 05            tstio STAT1                 ; test whether we can transmit on ASCI1
0347   0134 28 21               jr z, tx_end                ; if not, then end
0348   0136             
0349   0136 2A 09 21            ld hl, (serTxOutPtr)        ; get the pointer to place where we pop the Tx byte
0350   0139 7E                  ld a, (hl)                  ; get the Tx byte
0351   013A ED 39 07            out0 (TDR1), a              ; output the Tx byte to the ASCI
0352   013D             
0353   013D 23                  inc hl                      ; move the Tx pointer along
0354   013E 7D                  ld a, l                     ; get the low byte of the Tx pointer
0355   013F FE 06               cp (serTxBuf + SER_TX_BUFSIZE) & $FF
0356   0141 20 03               jr nz, no_tx_wrap
0357   0143 21 F6 20            ld hl, serTxBuf             ; we wrapped, so go back to start of buffer
0358   0146             
0359   0146             no_tx_wrap:
0360   0146             
0361   0146 22 09 21            ld (serTxOutPtr), hl        ; write where the next byte should be popped
0362   0149             
0363   0149 21 0B 21            ld hl, serTxBufUsed
0364   014C 35                  dec (hl)                    ; atomically decrement current Tx count
0365   014D 20 08               jr nz, tx_end               ; if we've more Tx bytes to send, we're done for now
0366   014F                     
0367   014F             tie_clear:
0368   014F             
0369   014F ED 38 05            in0 a, (STAT1)              ; get the ASCI status register
0370   0152 E6 FE               and ~SER_TIE                ; mask out (disable) the Tx Interrupt
0371   0154 ED 39 05            out0 (STAT1), a             ; set the ASCI status register
0372   0157             
0373   0157             tx_end:
0374   0157             
0375   0157 E1                  pop hl
0376   0158 F1                  pop af
0377   0159                     
0378   0159 FB                  ei
0379   015A ED 4D               reti
0380   015C             
0381   015C             ;------------------------------------------------------------------------------
0382   015C             RXA:
0383   015C             waitForRxChar:
0384   015C             
0385   015C 3A F5 20            ld a, (serRxBufUsed)        ; get the number of bytes in the Rx buffer
0386   015F             
0387   015F B7                  or a                        ; see if there are zero bytes available
0388   0160 28 FA               jr z, waitForRxChar         ; wait, if there are no bytes available
0389   0162                     
0390   0162 E5                  push hl                     ; Store HL so we don't clobber it
0391   0163             
0392   0163 2A F3 20            ld hl, (serRxOutPtr)        ; get the pointer to place where we pop the Rx byte
0393   0166 7E                  ld a, (hl)                  ; get the Rx byte
0394   0167 F5                  push af                     ; save the Rx byte on stack
0395   0168             
0396   0168 23                  inc hl                      ; move the Rx pointer along
0397   0169 7D                  ld a, l                     ; get the low byte of the Rx pointer
0398   016A FE F0               cp (serRxBuf + SER_RX_BUFSIZE) & $FF
0399   016C 20 03               jr nz, get_no_rx_wrap
0400   016E 21 00 20            ld hl, serRxBuf             ; we wrapped, so go back to start of buffer
0401   0171             
0402   0171             get_no_rx_wrap:
0403   0171             
0404   0171 22 F3 20            ld (serRxOutPtr), hl        ; write where the next byte should be popped
0405   0174             
0406   0174 21 F5 20            ld hl,serRxBufUsed
0407   0177 35                  dec (hl)                    ; atomically decrement Rx count
0408   0178             
0409   0178 F1                  pop af                      ; get the Rx byte from stack
0410   0179 E1                  pop hl                      ; recover HL
0411   017A             
0412   017A C9                  ret                         ; char ready in A
0413   017B             
0414   017B             ;------------------------------------------------------------------------------
0415   017B             TXA:
0416   017B E5                  push hl                     ; Store HL so we don't clobber it        
0417   017C 6F                  ld l, a                     ; Store Tx character 
0418   017D             
0419   017D 3A 0B 21            ld a, (serTxBufUsed)        ; Get the number of bytes in the Tx buffer
0420   0180 FE 10               cp SER_TX_BUFSIZE           ; check whether there is space in the buffer
0421   0182 30 1F               jr nc, clean_up_tx          ; buffer full, so abandon Tx
0422   0184                     
0423   0184 7D                  ld a, l                     ; Retrieve Tx character
0424   0185 2A 07 21            ld hl, (serTxInPtr)         ; get the pointer to where we poke
0425   0188 77                  ld (hl), a                  ; write the Tx byte to the serTxInPtr   
0426   0189 23                  inc hl                      ; move the Tx pointer along
0427   018A             
0428   018A 7D                  ld a, l                     ; move low byte of the Tx pointer
0429   018B FE 06               cp (serTxBuf + SER_TX_BUFSIZE) & $FF
0430   018D 20 03               jr nz, put_no_tx_wrap
0431   018F 21 F6 20            ld hl, serTxBuf             ; we wrapped, so go back to start of buffer
0432   0192             
0433   0192             put_no_tx_wrap:
0434   0192             
0435   0192 22 07 21            ld (serTxInPtr), hl         ; write where the next byte should be poked
0436   0195             
0437   0195 21 0B 21            ld hl, serTxBufUsed
0438   0198 34                  inc (hl)                    ; atomic increment of Tx count
0439   0199             
0440   0199 F3                  di                          ; critical section begin
0441   019A                    
0442   019A ED 38 05            in0 a, (STAT1)              ; get the ASCI status register
0443   019D F6 01               or SER_TIE                  ; mask in (enable) the Tx Interrupt
0444   019F ED 39 05            out0 (STAT1), a             ; set the ASCI status register
0445   01A2                     
0446   01A2 FB                  ei                          ; critical section end
0447   01A3                     
0448   01A3             clean_up_tx:        
0449   01A3                     
0450   01A3 E1                  pop hl                      ; recover HL
0451   01A4             
0452   01A4 C9                  ret
0453   01A5             
0454   01A5             ;------------------------------------------------------------------------------
0455   01A5 3A F5 20    CKINCHAR:      LD        A,(serRxBufUsed)
0456   01A8 FE 00                      CP        $0
0457   01AA C9                         RET
0458   01AB             
0459   01AB 7E          PRINT:         LD        A,(HL)          ; Get character
0460   01AC B7                         OR        A               ; Is it $00 ?
0461   01AD C8                         RET       Z               ; Then RETurn on terminator
0462   01AE CF                         RST       08H             ; Print it
0463   01AF 23                         INC       HL              ; Next Character
0464   01B0 18 F9                      JR        PRINT           ; Continue until $00
0465   01B2 C9                         RET
0466   01B3             ;------------------------------------------------------------------------------
0467   01B3             INIT:
0468   01B3                                                      ; Set I/O Control Reg (ICR)
0469   01B3 3E 00                      LD        A,IO_BASE       ; ICR = $00 [xx00 0000] for I/O Registers at $00 - $3F
0470   01B5 ED 39 3F                   OUT0      (ICR),A         ; Standard I/O Mapping (0 Enabled)
0471   01B8             
0472   01B8                                                      ; Set interrupt vector base (IL)
0473   01B8 3E 80                      LD        A,VECTOR_BASE   ; IL = $20 [001x xxxx] for Vectors at $20 - $30
0474   01BA ED 39 33                   OUT0      (IL),A          ; Output to the Interrupt Vector Low reg
0475   01BD                                                     
0476   01BD ED 56                      IM        1               ; Interrupt mode 1 for INT0 (unused)
0477   01BF                                  
0478   01BF AF                         XOR       A               ; Zero Accumulator
0479   01C0             
0480   01C0 ED 39 34                   OUT0      (ITC),A         ; Disable external interrupts
0481   01C3 ED 39 10                   OUT0      (TCR),A         ; Disable PRT downcounting
0482   01C6                                                      ; Clear Refresh Control Reg (RCR)
0483   01C6 ED 39 36                   OUT0      (RCR),A         ; DRAM Refresh Enable (0 Disabled)
0484   01C9             
0485   01C9                                                      ; Set Operation Mode Control Reg (OMCR)
0486   01C9 3E 80                      LD        A,OMCR_M1E      ; Enable M1, but disable 64180 I/O _RD Mode
0487   01CB ED 39 3E                   OUT0      (OMCR),A        ; X80 Mode (M1E Enabled, OIC Disabled)
0488   01CE             
0489   01CE                                                      ; Set internal clock = crystal x 2 = 36.864MHz
0490   01CE                                                      ; if using ZS8180 or Z80182 at High-Speed
0491   01CE 3E 80                      LD        A,CMR_X2        ; Set Hi-Speed flag
0492   01D0 ED 39 1E                   OUT0      (CMR),A         ; CPU Clock Multiplier Reg (CMR)
0493   01D3             
0494   01D3               ;                                      ; Bypass PHI = internal clock / 2
0495   01D3               ;                                      ; if using ZS8180 or Z80182 at High-Speed
0496   01D3               ;            LD        A,CCR_XTAL_X2   ; Set Hi-Speed flag: PHI = internal clock
0497   01D3               ;            OUT0      (CCR),A         ; CPU Control Reg (CCR)
0498   01D3                            
0499   01D3 FD E3                      EX        (SP),IY         ; (settle)
0500   01D5 FD E3                      EX        (SP),IY         ; (settle)               
0501   01D7             
0502   01D7                                                      ; Set Logical Addresses
0503   01D7                                                      ; $8000-$FFFF RAM CA1 -> 80H
0504   01D7                                                      ; $4000-$7FFF RAM BANK -> 04H
0505   01D7                                                      ; $2000-$3FFF RAM CA0
0506   01D7                                                      ; $0000-$1FFF Flash CA0
0507   01D7 3E 84                      LD        A,84H           ; Set New Common / Bank Areas
0508   01D9 ED 39 3A                   OUT0      (CBAR),A        ; for RAM
0509   01DC             
0510   01DC                                                      ; Physical Addresses
0511   01DC 3E 78                      LD        A,78H           ; Set Common 1 Area Physical $80000 -> 78H
0512   01DE ED 39 38                   OUT0      (CBR),A
0513   01E1                            
0514   01E1 3E 3C                      LD        A,3CH           ; Set Bank Area Physical $40000 -> 3CH
0515   01E3 ED 39 39                   OUT0      (BBR),A
0516   01E6             
0517   01E6 21 CB 21                   LD        HL,TEMPSTACK    ; Temp stack
0518   01E9 F9                         LD        SP,HL           ; Set up a temporary stack
0519   01EA             
0520   01EA 21 00 20                   LD        HL,serRxBuf     ; Initialise Rx Buffer
0521   01ED 22 F1 20                   LD        (serRxInPtr),HL
0522   01F0 22 F3 20                   LD        (serRxOutPtr),HL
0523   01F3             
0524   01F3 21 F6 20                   LD        HL,serTxBuf     ; Initialise Tx Buffer
0525   01F6 22 07 21                   LD        (serTxInPtr),HL
0526   01F9 22 09 21                   LD        (serTxOutPtr),HL              
0527   01FC             
0528   01FC AF                         XOR       A               ; 0 the accumulator
0529   01FD 32 F5 20                   LD        (serRxBufUsed),A
0530   0200 32 0B 21                   LD        (serTxBufUsed),A
0531   0203             
0532   0203                                                      ; load the default ASCI configuration
0533   0203                                                      ; 
0534   0203                                                      ; BAUD = 115200 8n1
0535   0203                                                      ; receive enabled
0536   0203                                                      ; transmit enabled                                         
0537   0203                                                      ; receive interrupt enabled
0538   0203                                                      ; transmit interrupt disabled
0539   0203                                                      
0540   0203 3E 64                      LD        A,SER_RE|SER_TE|SER_8N1
0541   0205 ED 39 01                   OUT0      (CNTLA1),A      ; output to the ASCI1 control A reg
0542   0208             
0543   0208                                                      ; PHI / PS / SS / DR = BAUD Rate
0544   0208                                                      ; PHI = 18.432MHz
0545   0208                                                      ; BAUD = 115200 = 18432000 / 10 / 1 / 16 
0546   0208                                                      ; PS 0, SS_DIV_1 0, DR 0           
0547   0208 AF                         XOR        A              ; BAUD = 115200
0548   0209 ED 39 03                   OUT0      (CNTLB1),A      ; output to the ASCI1 control B reg
0549   020C                                           
0550   020C 3E 08                      LD        A,SER_RIE       ; receive interrupt enabled
0551   020E ED 39 05                   OUT0      (STAT1),A       ; output to the ASCI1 status reg
0552   0211             
0553   0211 FB                         EI                        ; enable interrupts
0554   0212                            
0555   0212             ;===============================================================
0556   0212             ;              BEGIN OF TEST SECTION
0557   0212             
0558   0212             TEST:
0559   0212 3E 02                      LD        A,SER_TDRE      ; prepare Tx test
0560   0214 ED 74 05                   TSTIO     STAT1           ; test whether we can transmit on ASCI1
0561   0217 28 F9                      JR        Z, TEST         ; if not, then loop
0562   0219             
0563   0219 3E 55                      LD        A,$55           ; load an 'U'
0564   021B ED 39 07                   OUT0      (TDR1),A        ; Tx it!
0565   021E C3 12 02                   JP        TEST            ; do it forever
0566   0221                            
0567   0221             ;              END OF TEST SECTION                 
0568   0221             ;===============================================================
0569   0221                        
0570   0221 21 5A 02                   LD        HL,SIGNON1      ; Sign-on message
0571   0224 CD AB 01                   CALL      PRINT           ; Output string
0572   0227 3A 0C 21                   LD        A,(basicStarted); Check the BASIC STARTED flag
0573   022A FE 59                      CP        'Y'             ; to see if this is power-up
0574   022C 20 16                      JR        NZ,COLDSTART    ; If not BASIC started then always do cold start
0575   022E 21 6D 02                   LD        HL,SIGNON2      ; Cold/warm message
0576   0231 CD AB 01                   CALL      PRINT           ; Output string
0577   0234             CORW:
0578   0234 CD 5C 01                   CALL      RXA
0579   0237 E6 DF                      AND       %11011111       ; lower to uppercase
0580   0239 FE 43                      CP        'C'
0581   023B 20 0F                      JR        NZ, CHECKWARM
0582   023D CF                         RST       08H
0583   023E 3E 0D                      LD        A,$0D
0584   0240 CF                         RST       08H
0585   0241 3E 0A                      LD        A,$0A
0586   0243 CF                         RST       08H
0587   0244 3E 59       COLDSTART:     LD        A,'Y'           ; Set the BASIC STARTED flag
0588   0246 32 0C 21                   LD        (basicStarted),A
0589   0249 C3 90 02                   JP        $0290           ; <<<< Start BASIC COLD
0590   024C             CHECKWARM:
0591   024C FE 57                      CP        'W'
0592   024E 20 E4                      JR        NZ, CORW
0593   0250 CF                         RST       08H
0594   0251 3E 0D                      LD        A,$0D
0595   0253 CF                         RST       08H
0596   0254 3E 0A                      LD        A,$0A
0597   0256 CF                         RST       08H
0598   0257 C3 93 02                   JP        $0293           ; <<<< Start BASIC WARM
0599   025A             
0600   025A 59415A313830SIGNON1:       .BYTE     "YAZ180 - feilipu",CR,LF,0
0600   0260 202D206665696C6970750D0A00
0601   026D 0D 0A       SIGNON2:       .BYTE     CR,LF
0602   026F 436F6C64206F               .BYTE     "Cold or warm start (C|W) ?",0
0602   0275 72207761726D2073746172742028437C5729203F00
0603   028A             
0604   028A                            .END



Label        Value      Label        Value      Label        Value
------------------      ------------------      ------------------
ASEXT0        0012      ASEXT1        0013      ASTC0L        001A      
ASTC0H        001B      ASTC1L        001C      ASTC1H        001D      
BCR0L         0026      BCR0H         0027      BCR1L         002E      
BCR1H         002F      BBR           0039      CNTLA0        0000      
CNTLA1        0001      CNTLB0        0002      CNTLB1        0003      
CNTR          000A      CMR           001E      CCR           001F      
CBR           0038      CBAR          003A      CMR_X2        0080      
CMR_LN_XTAL   0040      CCR_XTAL_X2   0080      CCR_STANDBY   0040      
CCR_BREXT     0020      CCR_LNPHI     0010      CCR_IDLE      0008      
CCR_LNIO      0004      CCR_LNCPUCTL  0002      CCR_LNAD      0001      
CR            000D      CS            000C      CKINCHAR      01A5      
CORW          0234      COLDSTART     0244      CHECKWARM     024C      
DAR0L         0023      DAR0H         0024      DAR0B         0025      
DSTAT         0030      DMODE         0031      DCNTL         0032      
FRC           0018      IO_BASE       0000      IAR1L         002B      
IAR1H         002C      IL            0033      ITC           0034      
ICR           003F      INIT          01B3      LF            000A      
MAR1L         0028      MAR1H         0029      MAR1B         002A      
NMI           0066      OMCR          003E      OMCR_M1E      0080      
OMCR_M1TE     0040      OMCR_IOC      0020      PRINT         01AB      
RDR0          0008      RDR1          0009      RLDR0L        000E      
RLDR0H        000F      RLDR1L        0016      RLDR1H        0017      
RCR           0036      RCR_REFE      0080      RCR_REFW      0040      
RST00         0000      RST08         0008      RST10         0010      
RST18         0018      RST20         0020      RST28         0028      
RST30         0030      RST38         0038      RXA           015C      
STAT0         0004      STAT1         0005      SAR0L         0020      
SAR0H         0021      SAR0B         0022      SER_MPE       0080      
SER_RE        0040      SER_TE        0020      SER_RTS0      0010      
SER_EFR       0008      SER_7N1       0000      SER_7N2       0001      
SER_7P1       0002      SER_7P2       0003      SER_8N1       0004      
SER_8N2       0005      SER_8P1       0006      SER_8P2       0007      
SER_MPBT      0080      SER_MP        0040      SER_PS        0020      
SER_PEO       0010      SER_DR        0008      SER_SS_DIV_1  0000      
SER_SS_DIV_2  0001      SER_SS_DIV_4  0002      SER_SS_DIV_8  0003      
SER_SS_DIV_16 0004      SER_SS_DIV_32 0005      SER_SS_DIV_64 0006      
SER_SS_EXT    0007      SER_RDRF      0080      SER_OVRN      0040      
SER_PE        0020      SER_FE        0010      SER_RIE       0008      
SER_DCD0      0004      SER_CTS1      0004      SER_TDRE      0002      
SER_TIE       0001      SER_RX_BUFSIZE 00F0      SER_TX_BUFSIZE 0010      
SIGNON1       025A      SIGNON2       026D      TDR0          0006      
TDR1          0007      TRDR          000B      TMDR0L        000C      
TMDR0H        000D      TCR           0010      TMDR1L        0014      
TMDR1H        0015      TEMPSTACK     21CB      TXA           017B      
TEST          0212      VECTOR_BASE   0080      VECTOR_INT1   0080      
VECTOR_INT2   0082      VECTOR_PRT0   0084      VECTOR_PRT1   0086      
VECTOR_DMA0   0088      VECTOR_DMA1   008A      VECTOR_CSIO   008C      
VECTOR_ASCI0  008E      VECTOR_ASCI1  0090      basicStarted  210C      
clean_up_tx   01A3      get_no_rx_wrap 0171      no_rx_wrap    0122      
no_tx_wrap    0146      put_no_tx_wrap 0192      serRxBuf      2000      
serRxInPtr    20F1      serRxOutPtr   20F3      serRxBufUsed  20F5      
serTxBuf      20F6      serTxInPtr    2107      serTxOutPtr   2109      
serTxBufUsed  210B      serialInt     0100      tx_check      0129      
tie_clear     014F      tx_end        0157      waitForRxChar 015C      

tasm: Number of errors = 0
