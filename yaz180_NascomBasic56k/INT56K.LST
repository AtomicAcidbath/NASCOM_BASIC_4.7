0001   0000             ;==================================================================================
0002   0000             ; Contents of this file are copyright Phillip Stevens
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; Initialisation routines to suit Z8S180 CPU, with internal USART.
0008   0000             ;
0009   0000             ; Internal USART interrupt driven serial I/O to run modified NASCOM Basic 4.7.
0010   0000             
0011   0000             ; Full input and output buffering with incoming data hardware handshaking.
0012   0000             ; Handshake shows full before the buffer is totally filled to
0013   0000             ; allow run-on from the sender.
0014   0000             ;
0015   0000             ; https://github.com/feilipu/
0016   0000             ;
0017   0000             ; https://feilipu.me/
0018   0000             ;
0019   0000             ;==================================================================================
0020   0000             ;
0021   0000             ; Z180 Register Mnemonics
0022   0000             ;
0023   0000             
0024   0000             CNTLA0          .EQU    $00     ; ASCI Control Reg A Ch 0
0025   0000             CNTLA1          .EQU    $01     ; ASCI Control Reg A Ch 1
0026   0000             CNTLB0          .EQU    $02     ; ASCI Control Reg B Ch 0
0027   0000             CNTLB1          .EQU    $03     ; ASCI Control Reg B Ch 1
0028   0000             STAT0           .EQU    $04     ; ASCI Status  Reg   Ch 0
0029   0000             STAT1           .EQU    $05     ; ASCI Status  Reg   Ch 1
0030   0000             TDR0            .EQU    $06     ; ASCI Tx Data Reg   Ch 0
0031   0000             TDR1            .EQU    $07     ; ASCI Tx Data Reg   Ch 1
0032   0000             RDR0            .EQU    $08     ; ASCI Rx Data Reg   Ch 0
0033   0000             RDR1            .EQU    $09     ; ASCI Rx Data Reg   Ch 1
0034   0000             
0035   0000             ASEXT0          .EQU    $12     ; ASCI Extension Control Reg Ch 0 (Z8S180 & higher Only)
0036   0000             ASEXT1          .EQU    $13     ; ASCI Extension Control Reg Ch 1 (Z8S180 & higher Only)
0037   0000             
0038   0000             ASTC0L          .EQU    $1A     ; ASCI Time Constant Ch 0 Low (Z8S180 & higher Only)
0039   0000             ASTC0H          .EQU    $1B     ; ASCI Time Constant Ch 0 High (Z8S180 & higher Only)
0040   0000             ASTC1L          .EQU    $1C     ; ASCI Time Constant Ch 1 Low (Z8S180 & higher Only)
0041   0000             ASTC1H          .EQU    $1D     ; ASCI Time Constant Ch 1 High (Z8S180 & higher Only)
0042   0000             
0043   0000             CNTR            .EQU    $0A     ; CSI/O Control Reg
0044   0000             TRDR            .EQU    $0B     ; CSI/O Tx/Rx Data Reg
0045   0000             
0046   0000             TMDR0L          .EQU    $0C     ; Timer Data Reg Ch 0 Low
0047   0000             TMDR0H          .EQU    $0D     ; Timer Data Reg Ch 0 High
0048   0000             RLDR0L          .EQU    $0E     ; Timer Reload Reg Ch 0 Low
0049   0000             RLDR0H          .EQU    $0F     ; Timer Reload Reg Ch 0 High
0050   0000             TCR             .EQU    $10     ; Timer Control Reg
0051   0000             
0052   0000             TMDR1L          .EQU    $14     ; Timer Data Reg Ch 1 Low
0053   0000             TMDR1H          .EQU    $15     ; Timer Data Reg Ch 1 High
0054   0000             RLDR1L          .EQU    $16     ; Timer Reload Reg Ch 1 Low
0055   0000             RLDR1H          .EQU    $17     ; Timer Reload Reg Ch 1 High
0056   0000             
0057   0000             FRC             .EQU    $18     ; Free-Running Counter
0058   0000             
0059   0000             CMR             .EQU    $1E     ; CPU Clock Multiplier Reg (Z8S180 & higher Only)
0060   0000             CCR             .EQU    $1F     ; CPU Control Reg (Z8S180 & higher Only)
0061   0000             
0062   0000             SAR0L           .EQU    $20     ; DMA Source Addr Reg Ch0-Low
0063   0000             SAR0H           .EQU    $21     ; DMA Source Addr Reg Ch0-High
0064   0000             SAR0B           .EQU    $22     ; DMA Source Addr Reg Ch0-Bank
0065   0000             DAR0L           .EQU    $23     ; DMA Dest Addr Reg Ch0-Low
0066   0000             DAR0H           .EQU    $24     ; DMA Dest Addr Reg Ch0-High
0067   0000             DAR0B           .EQU    $25     ; DMA Dest ADDR REG CH0-Bank
0068   0000             BCR0L           .EQU    $26     ; DMA Byte Count Reg Ch0-Low
0069   0000             BCR0H           .EQU    $27     ; DMA Byte Count Reg Ch0-High
0070   0000             MAR1L           .EQU    $28     ; DMA Memory Addr Reg Ch1-Low
0071   0000             MAR1H           .EQU    $29     ; DMA Memory Addr Reg Ch1-High
0072   0000             MAR1B           .EQU    $2A     ; DMA Memory Addr Reg Ch1-Bank
0073   0000             IAR1L           .EQU    $2B     ; DMA I/O Addr Reg Ch1-Low
0074   0000             IAR1H           .EQU    $2C     ; DMA I/O Addr Reg Ch2-High
0075   0000             BCR1L           .EQU    $2E     ; DMA Byte Count Reg Ch1-Low
0076   0000             BCR1H           .EQU    $2F     ; DMA Byte Count Reg Ch1-High
0077   0000             DSTAT           .EQU    $30     ; DMA Status Reg
0078   0000             DMODE           .EQU    $31     ; DMA Mode Reg
0079   0000             DCNTL           .EQU    $32     ; DMA/Wait Control Reg
0080   0000             
0081   0000             IL              .EQU    $33     ; INT Vector Low Reg
0082   0000             ITC             .EQU    $34     ; INT/TRAP Control Reg
0083   0000             
0084   0000             RCR             .EQU    $36     ; Refresh Control Reg
0085   0000             
0086   0000             CBR             .EQU    $38     ; MMU Common Base Reg
0087   0000             BBR             .EQU    $39     ; MMU Bank Base Reg
0088   0000             CBAR            .EQU    $3A     ; MMU Common/Bank Area Reg
0089   0000             
0090   0000             OMCR            .EQU    $3E     ; Operation Mode Control Reg
0091   0000             ICR             .EQU    $3F     ; I/O Control Reg
0092   0000             
0093   0000             
0094   0000             ;==================================================================================
0095   0000             ;
0096   0000             ; Interrupt vectors (offsets) for Z180/HD64180 internal interrupts
0097   0000             ;
0098   0000             
0099   0000             VECTOR_BASE     .EQU   $20      ; Vector Base address <<< SET THIS AS DESIRED >>>
0100   0000             
0101   0000             VECTOR_INT1     .EQU   VECTOR_BASE+$00    ; external /INT1 
0102   0000             VECTOR_INT2     .EQU   VECTOR_BASE+$02    ; external /INT2 
0103   0000             VECTOR_PRT0     .EQU   VECTOR_BASE+$04    ; PRT channel 0 
0104   0000             VECTOR_PRT1     .EQU   VECTOR_BASE+$06    ; PRT channel 1 
0105   0000             VECTOR_DMA0     .EQU   VECTOR_BASE+$08    ; DMA channel 0 
0106   0000             VECTOR_DMA1     .EQU   VECTOR_BASE+$0A    ; DMA Channel 1 
0107   0000             VECTOR_CSIO     .EQU   VECTOR_BASE+$0C    ; Clocked serial I/O 
0108   0000             VECTOR_ASCI0    .EQU   VECTOR_BASE+$0E    ; Async channel 0 
0109   0000             VECTOR_ASCI1    .EQU   VECTOR_BASE+$10    ; Async channel 1 
0110   0000             VECTOR_INCAP    .EQU   VECTOR_BASE+$12    ; input capture 
0111   0000             VECTOR_OUTCMP   .EQU   VECTOR_BASE+$14    ; output compare 
0112   0000             VECTOR_TIMOV    .EQU   VECTOR_BASE+$16    ; timer overflow 
0113   0000             
0114   0000             ;==================================================================================
0115   0000             ;
0116   0000             ; Some bit definitions used with the Z-180 on-chip peripherals:
0117   0000             ;
0118   0000             
0119   0000             ; ASCI Control Reg A (CNTLAn)
0120   0000             
0121   0000             SER_MPE         .EQU   $80    ; Multi Processor Enable
0122   0000             SER_RE          .EQU   $40    ; Receive Enable
0123   0000             SER_TE          .EQU   $20    ; Transmit Enable
0124   0000             SER_RTS0        .EQU   $10    ; _RTS Request To Send
0125   0000             SER_EFR         .EQU   $08    ; Error Flag Reset
0126   0000             
0127   0000             SER_7N1         .EQU   $00    ; 7 Bits No Parity 1 Stop Bit
0128   0000             SER_7N2         .EQU   $01    ; 7 Bits No Parity 2 Stop Bits
0129   0000             SER_7P1         .EQU   $02    ; 7 Bits    Parity 1 Stop Bit
0130   0000             SER_7P2         .EQU   $03    ; 7 Bits    Parity 2 Stop Bits
0131   0000             SER_8N1         .EQU   $04    ; 8 Bits No Parity 1 Stop Bit
0132   0000             SER_8N2         .EQU   $05    ; 8 Bits No Parity 2 Stop Bits
0133   0000             SER_8P1         .EQU   $06    ; 8 Bits    Parity 1 Stop Bit
0134   0000             SER_8P2         .EQU   $07    ; 8 Bits    Parity 2 Stop Bits
0135   0000             
0136   0000             ; ASCI Control Reg B (CNTLBn)
0137   0000                                           ; BAUD Rate = PHI / PS / SS / DR
0138   0000             
0139   0000             SER_MPBT        .EQU   $80    ; Multi Processor Bit Transmit
0140   0000             SER_MP          .EQU   $40    ; Multi Processor
0141   0000             SER_PS          .EQU   $20    ; Prescale PHI by 10 (PS 0) or 30 (PS 1)
0142   0000             SER_PEO         .EQU   $10    ; Parity Even or Odd
0143   0000             SER_DR          .EQU   $08    ; Divide SS by 16 (DR 0) or 64 (DR 1)
0144   0000             
0145   0000             SER_SS_DIV_1    .EQU   $00    ; Divide PS by  1
0146   0000             SER_SS_DIV_2    .EQU   $01    ; Divide PS by  2
0147   0000             SER_SS_DIV_4    .EQU   $02    ; Divide PS by  4
0148   0000             SER_SS_DIV_8    .EQU   $03    ; Divide PS by  8
0149   0000             SER_SS_DIV_16   .EQU   $04    ; Divide PS by 16
0150   0000             SER_SS_DIV_32   .EQU   $05    ; Divide PS by 32
0151   0000             SER_SS_DIV_64   .EQU   $06    ; Divide PS by 64
0152   0000             SER_SS_EXT      .EQU   $07    ; External Clock Source <= PHI / 40
0153   0000             
0154   0000             ; ASCI Status Reg (STATn)
0155   0000             
0156   0000             SER_RDRF        .EQU   $80    ; Receive Data Register Full
0157   0000             SER_OVRN        .EQU   $40    ; Overrun (Received Byte)
0158   0000             SER_PE          .EQU   $20    ; Parity Error (Received Byte)
0159   0000             SER_FE          .EQU   $10    ; Framing Error (Received Byte)
0160   0000             SER_RIE         .EQU   $08    ; Receive Interrupt Enabled
0161   0000             SER_DCD0        .EQU   $04    ; _DCD0 Data Carrier Detect USART0
0162   0000             SER_CTS1        .EQU   $04    ; _CTS1 Clear To Send USART1
0163   0000             SER_TDRE        .EQU   $02    ; Transmit Data Register Empty
0164   0000             SER_TIE         .EQU   $01    ; Transmit Interrupt Enabled
0165   0000             
0166   0000             ; CPU Clock Multiplier Reg (CMR) (Z8S180 & higher Only)
0167   0000             
0168   0000             CMR_X2          .EQU   $80    ; CPU x2 XTAL Multiplier Mode
0169   0000             CMR_LN_XTAL     .EQU   $40    ; Low Noise Crystal 
0170   0000             
0171   0000             ; CPU Control Reg (CCR) (Z8S180 & higher Only)
0172   0000             
0173   0000             CCR_XTAL_X2     .EQU   $80    ; PHI = XTAL Mode
0174   0000             CCR_STANDBY     .EQU   $40    ; STANDBY after SLEEP
0175   0000             CCR_BREXT       .EQU   $20    ; Exit STANDBY on BUSREQ
0176   0000             CCR_LNPHI       .EQU   $10    ; Low Noise PHI (30% Drive)
0177   0000             CCR_IDLE        .EQU   $08    ; IDLE after SLEEP
0178   0000             CCR_LNIO        .EQU   $04    ; Low Noise I/O Signals (30% Drive)
0179   0000             CCR_LNCPUCTL    .EQU   $02    ; Low Noise CPU Control Signals (30% Drive)
0180   0000             CCR_LNAD        .EQU   $01    ; Low Noise Address and Data Signals (30% Drive)
0181   0000             
0182   0000             ; Refresh Control Reg (RCR)
0183   0000             
0184   0000             RCR_REFE        .EQU   $80    ; DRAM Refresh Enable (0 Disabled)
0185   0000             RCR_REFW        .EQU   $40    ; DRAM Refresh 2 or 3 Wait states (0 2 Wait States)
0186   0000             
0187   0000             ; Operation Mode Control Reg (OMCR)
0188   0000             
0189   0000             OMCR_M1E        .EQU   $80    ; M1 Enable (0 Disabled)
0190   0000             OMCR_M1TE       .EQU   $40    ; M1 Temporary Enable
0191   0000             OMCR_IOC        .EQU   $20    ; IO Control (1 64180 Mode)
0192   0000             
0193   0000             ;==================================================================================
0194   0000             ;
0195   0000             ; DEFINES SECTION
0196   0000             
0197   0000                                            ; end of ASCI stuff is $210D
0198   0000                                            ; set BASIC Work space WRKSPC $2120
0199   0000             
0200   0000             TEMPSTACK       .EQU     $21CB ; Top of BASIC line input buffer (CURPOS WRKSPC+0ABH)
0201   0000                                            ; so it is "free ram" when BASIC resets
0202   0000             
0203   0000             CR              .EQU     0DH
0204   0000             LF              .EQU     0AH
0205   0000             CS              .EQU     0CH   ; Clear screen
0206   0000             
0207   0000             ;==================================================================================
0208   0000             ;
0209   0000             ; VARIABLES SECTION
0210   0000             
0211   0000             SER_RX_BUFSIZE  .EQU     $F0  ; Size of the Rx Buffer, 239 Bytes
0212   0000             SER_TX_BUFSIZE  .EQU     $10  ; Size of the Tx Buffer, 15 Bytes
0213   0000                  
0214   0000             serRxBuf        .EQU     $2000
0215   0000             serRxInPtr      .EQU     serRxBuf+SER_RX_BUFSIZE+1
0216   0000             serRxOutPtr     .EQU     serRxInPtr+2
0217   0000             serRxBufUsed    .EQU     serRxOutPtr+2
0218   0000             serTxBuf        .EQU     serRxBufUsed+1
0219   0000             serTxInPtr      .EQU     serTxBuf+SER_TX_BUFSIZE+1
0220   0000             serTxOutPtr     .EQU     serTxInPtr+2
0221   0000             serTxBufUsed    .EQU     serTxOutPtr+2
0222   0000             basicStarted    .EQU     serTxBufUsed+1
0223   0000             
0224   0000             ;==================================================================================
0225   0000             ;
0226   0000             ; CODE SECTION 
0227   0000             
0228   0000                             .ORG $0000
0229   0000             ;------------------------------------------------------------------------------
0230   0000             ; Reset
0231   0000             
0232   0000 F3          RST00:          DI             ;Disable interrupts
0233   0001 C3 33 01                    JP       INIT  ;Initialize Hardware and go
0234   0004             
0235   0004             ;------------------------------------------------------------------------------
0236   0004             ; TX a character over RS232 
0237   0004             
0238   0008                             .ORG     0008H
0239   0008 C3 FB 00    RST08:           JP      TXA
0240   000B             
0241   000B             ;------------------------------------------------------------------------------
0242   000B             ; RX a character over RS232 Channel A [Console], hold here until char ready.
0243   000B             
0244   0010                             .ORG 0010H
0245   0010 C3 DC 00    RST10:           JP      RXA
0246   0013             
0247   0013             ;------------------------------------------------------------------------------
0248   0013             ; Check serial status
0249   0013             
0250   0018                             .ORG 0018H
0251   0018 C3 25 01    RST18:           JP      CKINCHAR
0252   001B             
0253   001B             ;------------------------------------------------------------------------------
0254   001B             ; INTERRUPT VECTOR ASCI Channel 1 [ Vector at $30 ]
0255   001B             
0256   0030                             .ORG     VECTOR_ASCI1
0257   0030 C3 80 00                    JP       serialInt
0258   0033             
0259   0033             ;------------------------------------------------------------------------------
0260   0033             ; RST 38 - INTERRUPT VECTOR INT0 [ with IM 1 ] - UNUSED
0261   0033             
0262   0038                             .ORG     0038H
0263   0038 ED 4D       RST38:          RETI           ; just return
0264   003A             
0265   003A             ;------------------------------------------------------------------------------
0266   003A             ; NMI - INTERRUPT VECTOR NMI - UNUSED
0267   003A             
0268   0066                             .ORG     0066H
0269   0066 ED 45       NMI:            RETN           ; just return
0270   0068               
0271   0068             ;------------------------------------------------------------------------------
0272   0068             ; ASCI Code
0273   0068             
0274   0080                             .ORG     0080H                              
0275   0080             serialInt:
0276   0080             
0277   0080 F5                  push af
0278   0081 E5                  push hl
0279   0082             
0280   0082             ; start doing the Rx stuff
0281   0082             
0282   0082 ED 38 05            in0 a, (STAT1)              ; get the status of the ASCI
0283   0085 E6 80               and SER_RDRF                ; check whether a byte has been received
0284   0087 28 20               jr z, tx_check              ; if not, go check for bytes to transmit 
0285   0089             
0286   0089 ED 38 09            in0 a, (RDR1)               ; Get the received byte from the ASCI 
0287   008C 6F                  ld l, a                     ; Move Rx byte to l
0288   008D             
0289   008D 3A F5 20            ld a, (serRxBufUsed)        ; Get the number of bytes in the Rx buffer
0290   0090 FE F0               cp SER_RX_BUFSIZE           ; check whether there is space in the buffer
0291   0092 30 15               jr nc, tx_check             ; buffer full, check if we can send something
0292   0094             
0293   0094 7D                  ld a, l                     ; get Rx byte from l
0294   0095 2A F1 20            ld hl, (serRxInPtr)         ; get the pointer to where we poke
0295   0098 77                  ld (hl), a                  ; write the Rx byte to the serRxInPtr address
0296   0099             
0297   0099 23                  inc hl                      ; move the Rx pointer along
0298   009A 7D                  ld a, l	                    ; move low byte of the Rx pointer
0299   009B FE F0               cp (serRxBuf + SER_RX_BUFSIZE) & $FF
0300   009D 20 03               jr nz, no_rx_wrap
0301   009F 21 00 20            ld hl, serRxBuf             ; we wrapped, so go back to start of buffer
0302   00A2                 	
0303   00A2             no_rx_wrap:
0304   00A2             
0305   00A2 22 F1 20            ld (serRxInPtr), hl         ; write where the next byte should be poked
0306   00A5             
0307   00A5 21 F5 20            ld hl, serRxBufUsed
0308   00A8 34                  inc (hl)                    ; atomically increment Rx buffer count
0309   00A9             
0310   00A9             ; now start doing the Tx stuff
0311   00A9             
0312   00A9             tx_check:
0313   00A9             
0314   00A9 3A 0B 21            ld a, (serTxBufUsed)        ; get the number of bytes in the Tx buffer
0315   00AC B7                  or a                        ; check whether it is zero
0316   00AD 28 20               jr z, tie_clear             ; if the count is zero, then disable the Tx Interrupt
0317   00AF             
0318   00AF ED 38 05            in0 a, (STAT1)              ; get the status of the ASCI
0319   00B2 E6 02               and SER_TDRE                ; check whether a byte can be transmitted
0320   00B4 28 21               jr z, tx_end                ; if not, then end
0321   00B6             
0322   00B6 2A 09 21            ld hl, (serTxOutPtr)        ; get the pointer to place where we pop the Tx byte
0323   00B9 7E                  ld a, (hl)                  ; get the Tx byte
0324   00BA ED 39 07            out0 (TDR1), a              ; output the Tx byte to the ASCI
0325   00BD             
0326   00BD 23                  inc hl                      ; move the Tx pointer along
0327   00BE 7D                  ld a, l                     ; get the low byte of the Tx pointer
0328   00BF FE 06               cp (serTxBuf + SER_TX_BUFSIZE) & $FF
0329   00C1 20 03               jr nz, no_tx_wrap
0330   00C3 21 F6 20            ld hl, serTxBuf             ; we wrapped, so go back to start of buffer
0331   00C6             
0332   00C6             no_tx_wrap:
0333   00C6             
0334   00C6 22 09 21            ld (serTxOutPtr), hl        ; write where the next byte should be popped
0335   00C9             
0336   00C9 21 0B 21            ld hl, serTxBufUsed
0337   00CC 35                  dec (hl)                    ; atomically decrement current Tx count
0338   00CD 20 08               jr nz, tx_end               ; if we've more Tx bytes to send, we're done for now
0339   00CF                     
0340   00CF             tie_clear:
0341   00CF             
0342   00CF ED 38 05            in0 a, (STAT1)              ; get the ASCI status register
0343   00D2 E6 FE               and ~SER_TIE                ; mask out (disable) the Tx Interrupt
0344   00D4 ED 39 05            out0 (STAT1), a             ; set the ASCI status register
0345   00D7             
0346   00D7             tx_end:
0347   00D7             
0348   00D7 E1                  pop hl
0349   00D8 F1                  pop af
0350   00D9                     
0351   00D9 FB                  ei
0352   00DA ED 4D               reti
0353   00DC             
0354   00DC             ;------------------------------------------------------------------------------
0355   00DC             RXA:
0356   00DC             waitForRxChar:
0357   00DC             
0358   00DC 3A F5 20            ld a, (serRxBufUsed)        ; get the number of bytes in the Rx buffer
0359   00DF             
0360   00DF B7                  or a                        ; see if there are zero bytes available
0361   00E0 28 FA               jr z, waitForRxChar         ; wait, if there are no bytes available
0362   00E2                     
0363   00E2 E5                  push hl                     ; Store HL so we don't clobber it
0364   00E3             
0365   00E3 2A F3 20            ld hl, (serRxOutPtr)        ; get the pointer to place where we pop the Rx byte
0366   00E6 7E                  ld a, (hl)                  ; get the Rx byte
0367   00E7 F5                  push af                     ; save the Rx byte on stack
0368   00E8             
0369   00E8 23                  inc hl                      ; move the Rx pointer along
0370   00E9 7D                  ld a, l                     ; get the low byte of the Rx pointer
0371   00EA FE F0               cp (serRxBuf + SER_RX_BUFSIZE) & $FF
0372   00EC 20 03               jr nz, get_no_rx_wrap
0373   00EE 21 00 20            ld hl, serRxBuf             ; we wrapped, so go back to start of buffer
0374   00F1             
0375   00F1             get_no_rx_wrap:
0376   00F1             
0377   00F1 22 F3 20            ld (serRxOutPtr), hl        ; write where the next byte should be popped
0378   00F4             
0379   00F4 21 F5 20            ld hl,serRxBufUsed
0380   00F7 35                  dec (hl)                    ; atomically decrement Rx count
0381   00F8             
0382   00F8 F1                  pop af                      ; get the Rx byte from stack
0383   00F9 E1                  pop hl                      ; recover HL
0384   00FA             
0385   00FA C9                  ret                         ; char ready in A
0386   00FB             
0387   00FB             ;------------------------------------------------------------------------------
0388   00FB             TXA:
0389   00FB E5                  push hl                     ; Store HL so we don't clobber it        
0390   00FC 6F                  ld l, a                     ; Store Tx character 
0391   00FD             
0392   00FD 3A 0B 21            ld a, (serTxBufUsed)        ; Get the number of bytes in the Tx buffer
0393   0100 FE 10               cp SER_TX_BUFSIZE           ; check whether there is space in the buffer
0394   0102 30 1F               jr nc, clean_up_tx          ; buffer full, so abandon Tx
0395   0104                     
0396   0104 7D                  ld a, l                     ; Retrieve Tx character
0397   0105 2A 07 21            ld hl, (serTxInPtr)         ; get the pointer to where we poke
0398   0108 77                  ld (hl), a                  ; write the Tx byte to the serTxInPtr   
0399   0109 23                  inc hl                      ; move the Tx pointer along
0400   010A             
0401   010A 7D                  ld a, l                     ; move low byte of the Tx pointer
0402   010B FE 06               cp (serTxBuf + SER_TX_BUFSIZE) & $FF
0403   010D 20 03               jr nz, put_no_tx_wrap
0404   010F 21 F6 20            ld hl, serTxBuf             ; we wrapped, so go back to start of buffer
0405   0112             
0406   0112             put_no_tx_wrap:
0407   0112             
0408   0112 22 07 21            ld (serTxInPtr), hl         ; write where the next byte should be poked
0409   0115             
0410   0115 21 0B 21            ld hl, serTxBufUsed
0411   0118 34                  inc (hl)                    ; atomic increment of Tx count
0412   0119             
0413   0119 F3                  di                          ; critical section begin
0414   011A                    
0415   011A ED 38 05            in0 a, (STAT1)              ; get the ASCI status register
0416   011D F6 01               or SER_TIE                  ; mask in (enable) the Tx Interrupt
0417   011F ED 39 05            out0 (STAT1), a             ; set the ASCI status register
0418   0122                     
0419   0122 FB                  ei                          ; critical section end
0420   0123                     
0421   0123             clean_up_tx:        
0422   0123                     
0423   0123 E1                  pop hl                      ; recover HL
0424   0124             
0425   0124 C9                  ret
0426   0125             
0427   0125             ;------------------------------------------------------------------------------
0428   0125 3A F5 20    CKINCHAR:      LD        A,(serRxBufUsed)
0429   0128 FE 00                      CP        $0
0430   012A C9                         RET
0431   012B             
0432   012B 7E          PRINT:         LD        A,(HL)          ; Get character
0433   012C B7                         OR        A               ; Is it $00 ?
0434   012D C8                         RET       Z               ; Then RETurn on terminator
0435   012E CF                         RST       08H             ; Print it
0436   012F 23                         INC       HL              ; Next Character
0437   0130 18 F9                      JR        PRINT           ; Continue until $00
0438   0132 C9                         RET
0439   0133             ;------------------------------------------------------------------------------
0440   0133             INIT:
0441   0133                                                      ; set interrupt vector base
0442   0133 3E 20                      LD        A,VECTOR_BASE   ; IL = $20 [001xxxxx] for Vectors at $20 - $36
0443   0135 ED 39 33                   OUT0      (IL),A          ; output to the Interrupt Vector Low reg
0444   0138                                                     
0445   0138 ED 56                      IM        1               ; interrupt mode 1 for INT0 (unused)
0446   013A                                  
0447   013A AF                         XOR       A               ; Zero Accumulator
0448   013B             
0449   013B                                                      ; Disable external interrupts  
0450   013B ED 39 34                   OUT0      (ITC),A         ; until Int Vector Table initialized
0451   013E                            
0452   013E                                                      ; Disable PRT downcounting,
0453   013E ED 39 10                   OUT0      (TCR),A         ; until Int Vector Table initialized
0454   0141                            
0455   0141                                                      ; Clear Refresh Control Reg (RCR)
0456   0141 ED 39 36                   OUT0      (RCR),A         ; DRAM Refresh Enable (0 Disabled)
0457   0144             
0458   0144                                                      ; Clear I/O Control Reg (ICR)
0459   0144 ED 39 3F                   OUT0      (ICR),A         ; Standard I/O Mapping (0 Enabled)
0460   0147             
0461   0147                                                      ; Set Operation Mode Control Reg (OMCR)
0462   0147 3E 80                      LD        A,OMCR_M1E      ; Enable M1, but disable 64180 I/O RD Mode
0463   0149 ED 39 3E                   OUT0      (OMCR),A        ; X80 Mode (M1E Enabled, OIC Disabled)
0464   014C             
0465   014C                                                      ; Set internal clock = crystal x 2
0466   014C                                                      ; if using ZS8180 or Z80182 at High-Speed
0467   014C 3E 80                      LD        A,CMR_X2        ; Set Hi-Speed flag
0468   014E ED 39 1E                   OUT0	     (CMR),A         ; CPU Clock Multiplier Reg (CMR)
0469   0151             
0470   0151               ;                                      ; Bypass PHI = internal clock / 2
0471   0151               ;                                      ; if using ZS8180 or Z80182 at High-Speed
0472   0151               ;            LD	     A,CCR_XTAL_X2   ; Set Hi-Speed flag: PHI = internal clock
0473   0151               ;            OUT0      (CCR),A         ; CPU Control Reg (CCR)
0474   0151                            
0475   0151 FD E3                      EX        (SP),IY         ; (settle)
0476   0153 FD E3                      EX        (SP),IY         ; (settle)               
0477   0155             
0478   0155                                                      ; Set Logical Addresses
0479   0155                                                      ; $8000-$FFFF RAM CA1 -> 80H
0480   0155                                                      ; $4000-$7FFF RAM BANK -> 04H
0481   0155                                                      ; $2000-$3FFF RAM CA0
0482   0155                                                      ; $0000-$1FFF Flash CA0
0483   0155 3E 84                      LD        A,84H           ; Set New Common / Bank Areas
0484   0157 ED 39 3A                   OUT0      (CBAR),A        ; for RAM
0485   015A             
0486   015A                                                      ; Physical Addresses
0487   015A 3E 78                      LD        A,78H           ; Set Common 1 Area - Physical $80000 -> 78H
0488   015C ED 39 38                   OUT0      (CBR),A
0489   015F                            
0490   015F 3E 3C                      LD        A,3CH           ; Set Bank Area - Physical $40000 -> 3CH
0491   0161 ED 39 39                   OUT0      (BBR),A
0492   0164             
0493   0164 21 CB 21                   LD        HL,TEMPSTACK    ; Temp stack
0494   0167 F9                         LD        SP,HL           ; Set up a temporary stack
0495   0168             
0496   0168 21 00 20                   LD        HL,serRxBuf     ; Initialise Rx Buffer
0497   016B 22 F1 20                   LD        (serRxInPtr),HL
0498   016E 22 F3 20                   LD        (serRxOutPtr),HL
0499   0171             
0500   0171 21 F6 20                   LD        HL,serTxBuf     ; Initialise Tx Buffer
0501   0174 22 07 21                   LD        (serTxInPtr),HL
0502   0177 22 09 21                   LD        (serTxOutPtr),HL              
0503   017A             
0504   017A AF                         XOR       A               ; 0 the accumulator
0505   017B 32 F5 20                   LD        (serRxBufUsed),A
0506   017E 32 0B 21                   LD        (serTxBufUsed),A
0507   0181             
0508   0181                                                      ; load the default ASCI configuration
0509   0181                                                      ; 
0510   0181                                                      ; BAUD = 115200 8n1
0511   0181                                                      ; receive enabled
0512   0181                                                      ; transmit enabled                                         
0513   0181                                                      ; receive interrupt enabled
0514   0181                                                      ; transmit interrupt disabled
0515   0181                                                      
0516   0181 3E 64                      LD        A,SER_RE|SER_TE|SER_8N1
0517   0183 ED 39 01                   OUT0      (CNTLA1),A      ; output to the ASCI1 control A reg
0518   0186             
0519   0186                                                      ; PHI / PS / SS / DR = BAUD Rate
0520   0186                                                      ; PHI = 18.432MHz
0521   0186                                                      ; BAUD = 115200 = 18432000 / 10 / 1 / 16 
0522   0186                                                      ; PS 0, SS_DIV_1 0, DR 0           
0523   0186 AF                         XOR        A              ; BAUD = 115200
0524   0187 ED 39 03                   OUT0      (CNTLB1),A      ; output to the ASCI0 control B reg
0525   018A                                           
0526   018A 3E 08                      LD        A,SER_RIE       ; receive interrupt enabled
0527   018C ED 39 05                   OUT0      (STAT1),A       ; output to the ASCI1 status reg
0528   018F             
0529   018F FB                         EI                        ; enable interrupts
0530   0190                            
0531   0190             ;===============================================================
0532   0190             ;              BEGIN OF TEST SECTION
0533   0190             
0534   0190             TEST:
0535   0190 3E 02                      LD        A,SER_TDRE      ; prepare Tx test
0536   0192 ED 74 05                   TSTIO     STAT1           ; test whether we can transmit on ASCI1
0537   0195 28 F9                      JR        Z, TEST         ; if not, then loop
0538   0197             
0539   0197 3E 55                      LD        A,$55           ; load an 'U'
0540   0199 ED 39 07                   OUT0      (TDR1),A        ; Tx it!
0541   019C C3 90 01                   JP        TEST            ; do it forever
0542   019F                            
0543   019F             ;              END OF TEST SECTION                 
0544   019F             ;===============================================================
0545   019F                        
0546   019F 21 D8 01                   LD        HL,SIGNON1      ; Sign-on message
0547   01A2 CD 2B 01                   CALL      PRINT           ; Output string
0548   01A5 3A 0C 21                   LD        A,(basicStarted); Check the BASIC STARTED flag
0549   01A8 FE 59                      CP        'Y'             ; to see if this is power-up
0550   01AA 20 16                      JR        NZ,COLDSTART    ; If not BASIC started then always do cold start
0551   01AC 21 EB 01                   LD        HL,SIGNON2      ; Cold/warm message
0552   01AF CD 2B 01                   CALL      PRINT           ; Output string
0553   01B2             CORW:
0554   01B2 CD DC 00                   CALL      RXA
0555   01B5 E6 DF                      AND       %11011111       ; lower to uppercase
0556   01B7 FE 43                      CP        'C'
0557   01B9 20 0F                      JR        NZ, CHECKWARM
0558   01BB CF                         RST       08H
0559   01BC 3E 0D                      LD        A,$0D
0560   01BE CF                         RST       08H
0561   01BF 3E 0A                      LD        A,$0A
0562   01C1 CF                         RST       08H
0563   01C2 3E 59       COLDSTART:     LD        A,'Y'           ; Set the BASIC STARTED flag
0564   01C4 32 0C 21                   LD        (basicStarted),A
0565   01C7 C3 00 02                   JP        $0200           ; <<<< Start BASIC COLD
0566   01CA             CHECKWARM:
0567   01CA FE 57                      CP        'W'
0568   01CC 20 E4                      JR        NZ, CORW
0569   01CE CF                         RST       08H
0570   01CF 3E 0D                      LD        A,$0D
0571   01D1 CF                         RST       08H
0572   01D2 3E 0A                      LD        A,$0A
0573   01D4 CF                         RST       08H
0574   01D5 C3 03 02                   JP        $0203           ; <<<< Start BASIC WARM
0575   01D8             
0576   01D8 59415A313830SIGNON1:       .BYTE     "YAZ180 - feilipu",CR,LF,0
0576   01DE 202D206665696C6970750D0A00
0577   01EB 0D 0A       SIGNON2:       .BYTE     CR,LF
0578   01ED 436F6C64206F               .BYTE     "Cold or warm start (C|W) ?",0
0578   01F3 72207761726D2073746172742028437C5729203F00
0579   0208             
0580   0208                            .END



Label        Value      Label        Value      Label        Value
------------------      ------------------      ------------------
ASEXT0        0012      ASEXT1        0013      ASTC0L        001A      
ASTC0H        001B      ASTC1L        001C      ASTC1H        001D      
BCR0L         0026      BCR0H         0027      BCR1L         002E      
BCR1H         002F      BBR           0039      CNTLA0        0000      
CNTLA1        0001      CNTLB0        0002      CNTLB1        0003      
CNTR          000A      CMR           001E      CCR           001F      
CBR           0038      CBAR          003A      CMR_X2        0080      
CMR_LN_XTAL   0040      CCR_XTAL_X2   0080      CCR_STANDBY   0040      
CCR_BREXT     0020      CCR_LNPHI     0010      CCR_IDLE      0008      
CCR_LNIO      0004      CCR_LNCPUCTL  0002      CCR_LNAD      0001      
CR            000D      CS            000C      CKINCHAR      0125      
CORW          01B2      COLDSTART     01C2      CHECKWARM     01CA      
DAR0L         0023      DAR0H         0024      DAR0B         0025      
DSTAT         0030      DMODE         0031      DCNTL         0032      
FRC           0018      IAR1L         002B      IAR1H         002C      
IL            0033      ITC           0034      ICR           003F      
INIT          0133      LF            000A      MAR1L         0028      
MAR1H         0029      MAR1B         002A      NMI           0066      
OMCR          003E      OMCR_M1E      0080      OMCR_M1TE     0040      
OMCR_IOC      0020      PRINT         012B      RDR0          0008      
RDR1          0009      RLDR0L        000E      RLDR0H        000F      
RLDR1L        0016      RLDR1H        0017      RCR           0036      
RCR_REFE      0080      RCR_REFW      0040      RST00         0000      
RST08         0008      RST10         0010      RST18         0018      
RST38         0038      RXA           00DC      STAT0         0004      
STAT1         0005      SAR0L         0020      SAR0H         0021      
SAR0B         0022      SER_MPE       0080      SER_RE        0040      
SER_TE        0020      SER_RTS0      0010      SER_EFR       0008      
SER_7N1       0000      SER_7N2       0001      SER_7P1       0002      
SER_7P2       0003      SER_8N1       0004      SER_8N2       0005      
SER_8P1       0006      SER_8P2       0007      SER_MPBT      0080      
SER_MP        0040      SER_PS        0020      SER_PEO       0010      
SER_DR        0008      SER_SS_DIV_1  0000      SER_SS_DIV_2  0001      
SER_SS_DIV_4  0002      SER_SS_DIV_8  0003      SER_SS_DIV_16 0004      
SER_SS_DIV_32 0005      SER_SS_DIV_64 0006      SER_SS_EXT    0007      
SER_RDRF      0080      SER_OVRN      0040      SER_PE        0020      
SER_FE        0010      SER_RIE       0008      SER_DCD0      0004      
SER_CTS1      0004      SER_TDRE      0002      SER_TIE       0001      
SER_RX_BUFSIZE 00F0      SER_TX_BUFSIZE 0010      SIGNON1       01D8      
SIGNON2       01EB      TDR0          0006      TDR1          0007      
TRDR          000B      TMDR0L        000C      TMDR0H        000D      
TCR           0010      TMDR1L        0014      TMDR1H        0015      
TEMPSTACK     21CB      TXA           00FB      TEST          0190      
VECTOR_BASE   0020      VECTOR_INT1   0020      VECTOR_INT2   0022      
VECTOR_PRT0   0024      VECTOR_PRT1   0026      VECTOR_DMA0   0028      
VECTOR_DMA1   002A      VECTOR_CSIO   002C      VECTOR_ASCI0  002E      
VECTOR_ASCI1  0030      VECTOR_INCAP  0032      VECTOR_OUTCMP 0034      
VECTOR_TIMOV  0036      basicStarted  210C      clean_up_tx   0123      
get_no_rx_wrap 00F1      no_rx_wrap    00A2      no_tx_wrap    00C6      
put_no_tx_wrap 0112      serRxBuf      2000      serRxInPtr    20F1      
serRxOutPtr   20F3      serRxBufUsed  20F5      serTxBuf      20F6      
serTxInPtr    2107      serTxOutPtr   2109      serTxBufUsed  210B      
serialInt     0080      tx_check      00A9      tie_clear     00CF      
tx_end        00D7      waitForRxChar 00DC      

tasm: Number of errors = 0
