0001   0000             ;==================================================================================
0002   0000             ; Contents of this file are copyright Phillip Stevens
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; Initialisation routines to suit Z8S180 CPU, with internal USART.
0008   0000             ;
0009   0000             ; Internal USART interrupt driven serial I/O to run modified NASCOM Basic 4.7.
0010   0000             
0011   0000             ; Full input and output buffering with incoming data hardware handshaking.
0012   0000             ; Handshake shows full before the buffer is totally filled to
0013   0000             ; allow run-on from the sender.
0014   0000             ;
0015   0000             ; https://github.com/feilipu/
0016   0000             ;
0017   0000             ; https://feilipu.me/
0018   0000             ;
0019   0000             ;==================================================================================
0020   0000             ;
0021   0000             ; Z180 Register Mnemonics
0022   0000             ;
0023   0000             
0024   0000             IO_BASE         .EQU    $00     ; Internal I/O Base Address (ICR) <<< SET THIS AS DESIRED >>>
0025   0000             
0026   0000             CNTLA0          .EQU    IO_BASE+$00     ; ASCI Control Reg A Ch 0
0027   0000             CNTLA1          .EQU    IO_BASE+$01     ; ASCI Control Reg A Ch 1
0028   0000             CNTLB0          .EQU    IO_BASE+$02     ; ASCI Control Reg B Ch 0
0029   0000             CNTLB1          .EQU    IO_BASE+$03     ; ASCI Control Reg B Ch 1
0030   0000             STAT0           .EQU    IO_BASE+$04     ; ASCI Status  Reg   Ch 0
0031   0000             STAT1           .EQU    IO_BASE+$05     ; ASCI Status  Reg   Ch 1
0032   0000             TDR0            .EQU    IO_BASE+$06     ; ASCI Tx Data Reg   Ch 0
0033   0000             TDR1            .EQU    IO_BASE+$07     ; ASCI Tx Data Reg   Ch 1
0034   0000             RDR0            .EQU    IO_BASE+$08     ; ASCI Rx Data Reg   Ch 0
0035   0000             RDR1            .EQU    IO_BASE+$09     ; ASCI Rx Data Reg   Ch 1
0036   0000             
0037   0000             ASEXT0          .EQU    IO_BASE+$12     ; ASCI Extension Control Reg Ch 0 (Z8S180 & higher Only)
0038   0000             ASEXT1          .EQU    IO_BASE+$13     ; ASCI Extension Control Reg Ch 1 (Z8S180 & higher Only)
0039   0000             
0040   0000             ASTC0L          .EQU    IO_BASE+$1A     ; ASCI Time Constant Ch 0 Low (Z8S180 & higher Only)
0041   0000             ASTC0H          .EQU    IO_BASE+$1B     ; ASCI Time Constant Ch 0 High (Z8S180 & higher Only)
0042   0000             ASTC1L          .EQU    IO_BASE+$1C     ; ASCI Time Constant Ch 1 Low (Z8S180 & higher Only)
0043   0000             ASTC1H          .EQU    IO_BASE+$1D     ; ASCI Time Constant Ch 1 High (Z8S180 & higher Only)
0044   0000             
0045   0000             CNTR            .EQU    IO_BASE+$0A     ; CSI/O Control Reg
0046   0000             TRDR            .EQU    IO_BASE+$0B     ; CSI/O Tx/Rx Data Reg
0047   0000             
0048   0000             TMDR0L          .EQU    IO_BASE+$0C     ; Timer Data Reg Ch 0 Low
0049   0000             TMDR0H          .EQU    IO_BASE+$0D     ; Timer Data Reg Ch 0 High
0050   0000             RLDR0L          .EQU    IO_BASE+$0E     ; Timer Reload Reg Ch 0 Low
0051   0000             RLDR0H          .EQU    IO_BASE+$0F     ; Timer Reload Reg Ch 0 High
0052   0000             TCR             .EQU    IO_BASE+$10     ; Timer Control Reg
0053   0000             
0054   0000             TMDR1L          .EQU    IO_BASE+$14     ; Timer Data Reg Ch 1 Low
0055   0000             TMDR1H          .EQU    IO_BASE+$15     ; Timer Data Reg Ch 1 High
0056   0000             RLDR1L          .EQU    IO_BASE+$16     ; Timer Reload Reg Ch 1 Low
0057   0000             RLDR1H          .EQU    IO_BASE+$17     ; Timer Reload Reg Ch 1 High
0058   0000             
0059   0000             FRC             .EQU    IO_BASE+$18     ; Free-Running Counter
0060   0000             
0061   0000             CMR             .EQU    IO_BASE+$1E     ; CPU Clock Multiplier Reg (Z8S180 & higher Only)
0062   0000             CCR             .EQU    IO_BASE+$1F     ; CPU Control Reg (Z8S180 & higher Only)
0063   0000             
0064   0000             SAR0L           .EQU    IO_BASE+$20     ; DMA Source Addr Reg Ch0-Low
0065   0000             SAR0H           .EQU    IO_BASE+$21     ; DMA Source Addr Reg Ch0-High
0066   0000             SAR0B           .EQU    IO_BASE+$22     ; DMA Source Addr Reg Ch0-Bank
0067   0000             DAR0L           .EQU    IO_BASE+$23     ; DMA Dest Addr Reg Ch0-Low
0068   0000             DAR0H           .EQU    IO_BASE+$24     ; DMA Dest Addr Reg Ch0-High
0069   0000             DAR0B           .EQU    IO_BASE+$25     ; DMA Dest ADDR REG CH0-Bank
0070   0000             BCR0L           .EQU    IO_BASE+$26     ; DMA Byte Count Reg Ch0-Low
0071   0000             BCR0H           .EQU    IO_BASE+$27     ; DMA Byte Count Reg Ch0-High
0072   0000             MAR1L           .EQU    IO_BASE+$28     ; DMA Memory Addr Reg Ch1-Low
0073   0000             MAR1H           .EQU    IO_BASE+$29     ; DMA Memory Addr Reg Ch1-High
0074   0000             MAR1B           .EQU    IO_BASE+$2A     ; DMA Memory Addr Reg Ch1-Bank
0075   0000             IAR1L           .EQU    IO_BASE+$2B     ; DMA I/O Addr Reg Ch1-Low
0076   0000             IAR1H           .EQU    IO_BASE+$2C     ; DMA I/O Addr Reg Ch2-High
0077   0000             BCR1L           .EQU    IO_BASE+$2E     ; DMA Byte Count Reg Ch1-Low
0078   0000             BCR1H           .EQU    IO_BASE+$2F     ; DMA Byte Count Reg Ch1-High
0079   0000             DSTAT           .EQU    IO_BASE+$30     ; DMA Status Reg
0080   0000             DMODE           .EQU    IO_BASE+$31     ; DMA Mode Reg
0081   0000             DCNTL           .EQU    IO_BASE+$32     ; DMA/Wait Control Reg
0082   0000             
0083   0000             IL              .EQU    IO_BASE+$33     ; INT Vector Low Reg
0084   0000             ITC             .EQU    IO_BASE+$34     ; INT/TRAP Control Reg
0085   0000             
0086   0000             RCR             .EQU    IO_BASE+$36     ; Refresh Control Reg
0087   0000             
0088   0000             CBR             .EQU    IO_BASE+$38     ; MMU Common Base Reg
0089   0000             BBR             .EQU    IO_BASE+$39     ; MMU Bank Base Reg
0090   0000             CBAR            .EQU    IO_BASE+$3A     ; MMU Common/Bank Area Reg
0091   0000             
0092   0000             OMCR            .EQU    IO_BASE+$3E     ; Operation Mode Control Reg
0093   0000             ICR             .EQU    IO_BASE+$3F     ; I/O Control Reg
0094   0000             
0095   0000             
0096   0000             ;==================================================================================
0097   0000             ;
0098   0000             ; Interrupt vectors (offsets) for Z180/HD64180 internal interrupts
0099   0000             ;
0100   0000             
0101   0000             VECTOR_BASE     .EQU   $20      ; Vector Base address (IL) <<< SET THIS AS DESIRED >>>
0102   0000             
0103   0000             VECTOR_INT1     .EQU   VECTOR_BASE+$00    ; external /INT1 
0104   0000             VECTOR_INT2     .EQU   VECTOR_BASE+$02    ; external /INT2 
0105   0000             VECTOR_PRT0     .EQU   VECTOR_BASE+$04    ; PRT channel 0 
0106   0000             VECTOR_PRT1     .EQU   VECTOR_BASE+$06    ; PRT channel 1 
0107   0000             VECTOR_DMA0     .EQU   VECTOR_BASE+$08    ; DMA channel 0 
0108   0000             VECTOR_DMA1     .EQU   VECTOR_BASE+$0A    ; DMA Channel 1 
0109   0000             VECTOR_CSIO     .EQU   VECTOR_BASE+$0C    ; Clocked serial I/O 
0110   0000             VECTOR_ASCI0    .EQU   VECTOR_BASE+$0E    ; Async channel 0 
0111   0000             VECTOR_ASCI1    .EQU   VECTOR_BASE+$10    ; Async channel 1 
0112   0000             
0113   0000             ;==================================================================================
0114   0000             ;
0115   0000             ; Some bit definitions used with the Z-180 on-chip peripherals:
0116   0000             ;
0117   0000             
0118   0000             ; ASCI Control Reg A (CNTLAn)
0119   0000             
0120   0000             SER_MPE         .EQU   $80    ; Multi Processor Enable
0121   0000             SER_RE          .EQU   $40    ; Receive Enable
0122   0000             SER_TE          .EQU   $20    ; Transmit Enable
0123   0000             SER_RTS0        .EQU   $10    ; _RTS Request To Send
0124   0000             SER_EFR         .EQU   $08    ; Error Flag Reset
0125   0000             
0126   0000             SER_7N1         .EQU   $00    ; 7 Bits No Parity 1 Stop Bit
0127   0000             SER_7N2         .EQU   $01    ; 7 Bits No Parity 2 Stop Bits
0128   0000             SER_7P1         .EQU   $02    ; 7 Bits    Parity 1 Stop Bit
0129   0000             SER_7P2         .EQU   $03    ; 7 Bits    Parity 2 Stop Bits
0130   0000             SER_8N1         .EQU   $04    ; 8 Bits No Parity 1 Stop Bit
0131   0000             SER_8N2         .EQU   $05    ; 8 Bits No Parity 2 Stop Bits
0132   0000             SER_8P1         .EQU   $06    ; 8 Bits    Parity 1 Stop Bit
0133   0000             SER_8P2         .EQU   $07    ; 8 Bits    Parity 2 Stop Bits
0134   0000             
0135   0000             ; ASCI Control Reg B (CNTLBn)
0136   0000                                           ; BAUD Rate = PHI / PS / SS / DR
0137   0000             
0138   0000             SER_MPBT        .EQU   $80    ; Multi Processor Bit Transmit
0139   0000             SER_MP          .EQU   $40    ; Multi Processor
0140   0000             SER_PS          .EQU   $20    ; Prescale PHI by 10 (PS 0) or 30 (PS 1)
0141   0000             SER_PEO         .EQU   $10    ; Parity Even or Odd
0142   0000             SER_DR          .EQU   $08    ; Divide SS by 16 (DR 0) or 64 (DR 1)
0143   0000             
0144   0000             SER_SS_DIV_1    .EQU   $00    ; Divide PS by  1
0145   0000             SER_SS_DIV_2    .EQU   $01    ; Divide PS by  2
0146   0000             SER_SS_DIV_4    .EQU   $02    ; Divide PS by  4
0147   0000             SER_SS_DIV_8    .EQU   $03    ; Divide PS by  8
0148   0000             SER_SS_DIV_16   .EQU   $04    ; Divide PS by 16
0149   0000             SER_SS_DIV_32   .EQU   $05    ; Divide PS by 32
0150   0000             SER_SS_DIV_64   .EQU   $06    ; Divide PS by 64
0151   0000             SER_SS_EXT      .EQU   $07    ; External Clock Source <= PHI / 40
0152   0000             
0153   0000             ; ASCI Status Reg (STATn)
0154   0000             
0155   0000             SER_RDRF        .EQU   $80    ; Receive Data Register Full
0156   0000             SER_OVRN        .EQU   $40    ; Overrun (Received Byte)
0157   0000             SER_PE          .EQU   $20    ; Parity Error (Received Byte)
0158   0000             SER_FE          .EQU   $10    ; Framing Error (Received Byte)
0159   0000             SER_RIE         .EQU   $08    ; Receive Interrupt Enabled
0160   0000             SER_DCD0        .EQU   $04    ; _DCD0 Data Carrier Detect USART0
0161   0000             SER_CTS1        .EQU   $04    ; _CTS1 Clear To Send USART1
0162   0000             SER_TDRE        .EQU   $02    ; Transmit Data Register Empty
0163   0000             SER_TIE         .EQU   $01    ; Transmit Interrupt Enabled
0164   0000             
0165   0000             ; CPU Clock Multiplier Reg (CMR) (Z8S180 & higher Only)
0166   0000             
0167   0000             CMR_X2          .EQU   $80    ; CPU x2 XTAL Multiplier Mode
0168   0000             CMR_LN_XTAL     .EQU   $40    ; Low Noise Crystal 
0169   0000             
0170   0000             ; CPU Control Reg (CCR) (Z8S180 & higher Only)
0171   0000             
0172   0000             CCR_XTAL_X2     .EQU   $80    ; PHI = XTAL Mode
0173   0000             CCR_STANDBY     .EQU   $40    ; STANDBY after SLEEP
0174   0000             CCR_BREXT       .EQU   $20    ; Exit STANDBY on BUSREQ
0175   0000             CCR_LNPHI       .EQU   $10    ; Low Noise PHI (30% Drive)
0176   0000             CCR_IDLE        .EQU   $08    ; IDLE after SLEEP
0177   0000             CCR_LNIO        .EQU   $04    ; Low Noise I/O Signals (30% Drive)
0178   0000             CCR_LNCPUCTL    .EQU   $02    ; Low Noise CPU Control Signals (30% Drive)
0179   0000             CCR_LNAD        .EQU   $01    ; Low Noise Address and Data Signals (30% Drive)
0180   0000             
0181   0000             ; Refresh Control Reg (RCR)
0182   0000             
0183   0000             RCR_REFE        .EQU   $80    ; DRAM Refresh Enable (0 Disabled)
0184   0000             RCR_REFW        .EQU   $40    ; DRAM Refresh 2 or 3 Wait states (0 2 Wait States)
0185   0000             
0186   0000             ; Operation Mode Control Reg (OMCR)
0187   0000             
0188   0000             OMCR_M1E        .EQU   $80    ; M1 Enable (0 Disabled)
0189   0000             OMCR_M1TE       .EQU   $40    ; M1 Temporary Enable
0190   0000             OMCR_IOC        .EQU   $20    ; IO Control (1 64180 Mode)
0191   0000             
0192   0000             ;==================================================================================
0193   0000             ;
0194   0000             ; DEFINES SECTION
0195   0000             
0196   0000                                            ; end of ASCI stuff is $210D
0197   0000                                            ; set BASIC Work space WRKSPC $2120
0198   0000             
0199   0000             TEMPSTACK       .EQU     $21CB ; Top of BASIC line input buffer (CURPOS WRKSPC+0ABH)
0200   0000                                            ; so it is "free ram" when BASIC resets
0201   0000             
0202   0000             CR              .EQU     0DH
0203   0000             LF              .EQU     0AH
0204   0000             CS              .EQU     0CH   ; Clear screen
0205   0000             
0206   0000             ;==================================================================================
0207   0000             ;
0208   0000             ; VARIABLES SECTION
0209   0000             
0210   0000             SER_RX_BUFSIZE  .EQU     $F0  ; Size of the Rx Buffer, 239 Bytes
0211   0000             SER_TX_BUFSIZE  .EQU     $10  ; Size of the Tx Buffer, 15 Bytes
0212   0000                  
0213   0000             serRxBuf        .EQU     $2000
0214   0000             serRxInPtr      .EQU     serRxBuf+SER_RX_BUFSIZE+1
0215   0000             serRxOutPtr     .EQU     serRxInPtr+2
0216   0000             serRxBufUsed    .EQU     serRxOutPtr+2
0217   0000             serTxBuf        .EQU     serRxBufUsed+1
0218   0000             serTxInPtr      .EQU     serTxBuf+SER_TX_BUFSIZE+1
0219   0000             serTxOutPtr     .EQU     serTxInPtr+2
0220   0000             serTxBufUsed    .EQU     serTxOutPtr+2
0221   0000             basicStarted    .EQU     serTxBufUsed+1
0222   0000             
0223   0000             ;==================================================================================
0224   0000             ;
0225   0000             ; INTERRUPT VECTOR SECTION 
0226   0000             
0227   0000                             .ORG $0000
0228   0000             ;------------------------------------------------------------------------------
0229   0000             ; Reset
0230   0000             
0231   0000 F3          RST00:          DI             ; Disable interrupts
0232   0001 C3 33 01                    JP       INIT  ; Initialize Hardware and go
0233   0004             
0234   0004             ;------------------------------------------------------------------------------
0235   0004             ; TX a character over RS232 
0236   0004             
0237   0008                             .ORG     0008H
0238   0008 C3 FB 00    RST08:           JP      TXA
0239   000B             
0240   000B             ;------------------------------------------------------------------------------
0241   000B             ; RX a character over RS232 Channel A [Console], hold here until char ready.
0242   000B             
0243   0010                             .ORG 0010H
0244   0010 C3 DC 00    RST10:           JP      RXA
0245   0013             
0246   0013             ;------------------------------------------------------------------------------
0247   0013             ; Check serial status
0248   0013             
0249   0018                             .ORG 0018H
0250   0018 C3 25 01    RST18:           JP      CKINCHAR
0251   001B             
0252   001B             ;------------------------------------------------------------------------------
0253   001B             ; INTERRUPT VECTOR ASCI Channel 1 [ Vector at $30 ]
0254   001B             
0255   0030                             .ORG     VECTOR_ASCI1
0256   0030 C3 80 00                    JP       serialInt
0257   0033             
0258   0033             ;------------------------------------------------------------------------------
0259   0033             ; RST 38 - INTERRUPT VECTOR INT0 [ with IM 1 ] - UNUSED
0260   0033             
0261   0038                             .ORG     0038H
0262   0038 ED 4D       RST38:          RET            ; just return
0263   003A             
0264   003A             ;------------------------------------------------------------------------------
0265   003A             ; NMI - INTERRUPT VECTOR NMI - UNUSED
0266   003A             
0267   0066                             .ORG     0066H
0268   0066 ED 45       NMI:            RETN           ; just return
0269   0068               
0270   0068             ;------------------------------------------------------------------------------
0271   0068             ; ASCI Code
0272   0068             
0273   0080                             .ORG     0080H                              
0274   0080             serialInt:
0275   0080             
0276   0080 F5                  push af
0277   0081 E5                  push hl
0278   0082             
0279   0082             ; start doing the Rx stuff
0280   0082             
0281   0082 3E 80               ld a, SER_RDRF              ; prepare Rx test
0282   0084 ED 74 05            tstio STAT1                 ; test whether we have received on ASCI1
0283   0087 28 20               jr z, tx_check              ; if not, go check for bytes to transmit 
0284   0089             
0285   0089 ED 38 09            in0 a, (RDR1)               ; Get the received byte from the ASCI 
0286   008C 6F                  ld l, a                     ; Move Rx byte to l
0287   008D             
0288   008D 3A F5 20            ld a, (serRxBufUsed)        ; Get the number of bytes in the Rx buffer
0289   0090 FE F0               cp SER_RX_BUFSIZE           ; check whether there is space in the buffer
0290   0092 30 15               jr nc, tx_check             ; buffer full, check if we can send something
0291   0094             
0292   0094 7D                  ld a, l                     ; get Rx byte from l
0293   0095 2A F1 20            ld hl, (serRxInPtr)         ; get the pointer to where we poke
0294   0098 77                  ld (hl), a                  ; write the Rx byte to the serRxInPtr address
0295   0099             
0296   0099 23                  inc hl                      ; move the Rx pointer along
0297   009A 7D                  ld a, l	                    ; move low byte of the Rx pointer
0298   009B FE F0               cp (serRxBuf + SER_RX_BUFSIZE) & $FF
0299   009D 20 03               jr nz, no_rx_wrap
0300   009F 21 00 20            ld hl, serRxBuf             ; we wrapped, so go back to start of buffer
0301   00A2                 	
0302   00A2             no_rx_wrap:
0303   00A2             
0304   00A2 22 F1 20            ld (serRxInPtr), hl         ; write where the next byte should be poked
0305   00A5             
0306   00A5 21 F5 20            ld hl, serRxBufUsed
0307   00A8 34                  inc (hl)                    ; atomically increment Rx buffer count
0308   00A9             
0309   00A9             ; now start doing the Tx stuff
0310   00A9             
0311   00A9             tx_check:
0312   00A9             
0313   00A9 3A 0B 21            ld a, (serTxBufUsed)        ; get the number of bytes in the Tx buffer
0314   00AC B7                  or a                        ; check whether it is zero
0315   00AD 28 20               jr z, tie_clear             ; if the count is zero, then disable the Tx Interrupt
0316   00AF             
0317   00AF 3E 02               ld a, SER_TDRE              ; prepare Tx test
0318   00B1 ED 74 05            tstio STAT1                 ; test whether we can transmit on ASCI1
0319   00B4 28 21               jr z, tx_end                ; if not, then end
0320   00B6             
0321   00B6 2A 09 21            ld hl, (serTxOutPtr)        ; get the pointer to place where we pop the Tx byte
0322   00B9 7E                  ld a, (hl)                  ; get the Tx byte
0323   00BA ED 39 07            out0 (TDR1), a              ; output the Tx byte to the ASCI
0324   00BD             
0325   00BD 23                  inc hl                      ; move the Tx pointer along
0326   00BE 7D                  ld a, l                     ; get the low byte of the Tx pointer
0327   00BF FE 06               cp (serTxBuf + SER_TX_BUFSIZE) & $FF
0328   00C1 20 03               jr nz, no_tx_wrap
0329   00C3 21 F6 20            ld hl, serTxBuf             ; we wrapped, so go back to start of buffer
0330   00C6             
0331   00C6             no_tx_wrap:
0332   00C6             
0333   00C6 22 09 21            ld (serTxOutPtr), hl        ; write where the next byte should be popped
0334   00C9             
0335   00C9 21 0B 21            ld hl, serTxBufUsed
0336   00CC 35                  dec (hl)                    ; atomically decrement current Tx count
0337   00CD 20 08               jr nz, tx_end               ; if we've more Tx bytes to send, we're done for now
0338   00CF                     
0339   00CF             tie_clear:
0340   00CF             
0341   00CF ED 38 05            in0 a, (STAT1)              ; get the ASCI status register
0342   00D2 E6 FE               and ~SER_TIE                ; mask out (disable) the Tx Interrupt
0343   00D4 ED 39 05            out0 (STAT1), a             ; set the ASCI status register
0344   00D7             
0345   00D7             tx_end:
0346   00D7             
0347   00D7 E1                  pop hl
0348   00D8 F1                  pop af
0349   00D9                     
0350   00D9 FB                  ei
0351   00DA ED 4D               reti
0352   00DC             
0353   00DC             ;------------------------------------------------------------------------------
0354   00DC             RXA:
0355   00DC             waitForRxChar:
0356   00DC             
0357   00DC 3A F5 20            ld a, (serRxBufUsed)        ; get the number of bytes in the Rx buffer
0358   00DF             
0359   00DF B7                  or a                        ; see if there are zero bytes available
0360   00E0 28 FA               jr z, waitForRxChar         ; wait, if there are no bytes available
0361   00E2                     
0362   00E2 E5                  push hl                     ; Store HL so we don't clobber it
0363   00E3             
0364   00E3 2A F3 20            ld hl, (serRxOutPtr)        ; get the pointer to place where we pop the Rx byte
0365   00E6 7E                  ld a, (hl)                  ; get the Rx byte
0366   00E7 F5                  push af                     ; save the Rx byte on stack
0367   00E8             
0368   00E8 23                  inc hl                      ; move the Rx pointer along
0369   00E9 7D                  ld a, l                     ; get the low byte of the Rx pointer
0370   00EA FE F0               cp (serRxBuf + SER_RX_BUFSIZE) & $FF
0371   00EC 20 03               jr nz, get_no_rx_wrap
0372   00EE 21 00 20            ld hl, serRxBuf             ; we wrapped, so go back to start of buffer
0373   00F1             
0374   00F1             get_no_rx_wrap:
0375   00F1             
0376   00F1 22 F3 20            ld (serRxOutPtr), hl        ; write where the next byte should be popped
0377   00F4             
0378   00F4 21 F5 20            ld hl,serRxBufUsed
0379   00F7 35                  dec (hl)                    ; atomically decrement Rx count
0380   00F8             
0381   00F8 F1                  pop af                      ; get the Rx byte from stack
0382   00F9 E1                  pop hl                      ; recover HL
0383   00FA             
0384   00FA C9                  ret                         ; char ready in A
0385   00FB             
0386   00FB             ;------------------------------------------------------------------------------
0387   00FB             TXA:
0388   00FB E5                  push hl                     ; Store HL so we don't clobber it        
0389   00FC 6F                  ld l, a                     ; Store Tx character 
0390   00FD             
0391   00FD 3A 0B 21            ld a, (serTxBufUsed)        ; Get the number of bytes in the Tx buffer
0392   0100 FE 10               cp SER_TX_BUFSIZE           ; check whether there is space in the buffer
0393   0102 30 1F               jr nc, clean_up_tx          ; buffer full, so abandon Tx
0394   0104                     
0395   0104 7D                  ld a, l                     ; Retrieve Tx character
0396   0105 2A 07 21            ld hl, (serTxInPtr)         ; get the pointer to where we poke
0397   0108 77                  ld (hl), a                  ; write the Tx byte to the serTxInPtr   
0398   0109 23                  inc hl                      ; move the Tx pointer along
0399   010A             
0400   010A 7D                  ld a, l                     ; move low byte of the Tx pointer
0401   010B FE 06               cp (serTxBuf + SER_TX_BUFSIZE) & $FF
0402   010D 20 03               jr nz, put_no_tx_wrap
0403   010F 21 F6 20            ld hl, serTxBuf             ; we wrapped, so go back to start of buffer
0404   0112             
0405   0112             put_no_tx_wrap:
0406   0112             
0407   0112 22 07 21            ld (serTxInPtr), hl         ; write where the next byte should be poked
0408   0115             
0409   0115 21 0B 21            ld hl, serTxBufUsed
0410   0118 34                  inc (hl)                    ; atomic increment of Tx count
0411   0119             
0412   0119 F3                  di                          ; critical section begin
0413   011A                    
0414   011A ED 38 05            in0 a, (STAT1)              ; get the ASCI status register
0415   011D F6 01               or SER_TIE                  ; mask in (enable) the Tx Interrupt
0416   011F ED 39 05            out0 (STAT1), a             ; set the ASCI status register
0417   0122                     
0418   0122 FB                  ei                          ; critical section end
0419   0123                     
0420   0123             clean_up_tx:        
0421   0123                     
0422   0123 E1                  pop hl                      ; recover HL
0423   0124             
0424   0124 C9                  ret
0425   0125             
0426   0125             ;------------------------------------------------------------------------------
0427   0125 3A F5 20    CKINCHAR:      LD        A,(serRxBufUsed)
0428   0128 FE 00                      CP        $0
0429   012A C9                         RET
0430   012B             
0431   012B 7E          PRINT:         LD        A,(HL)          ; Get character
0432   012C B7                         OR        A               ; Is it $00 ?
0433   012D C8                         RET       Z               ; Then RETurn on terminator
0434   012E CF                         RST       08H             ; Print it
0435   012F 23                         INC       HL              ; Next Character
0436   0130 18 F9                      JR        PRINT           ; Continue until $00
0437   0132 C9                         RET
0438   0133             ;------------------------------------------------------------------------------
0439   0133             INIT:
0440   0133                                                      ; Set I/O Control Reg (ICR)
0441   0133 3E 00                      LD        A,IO_BASE       ; ICR = $00 [xx00 0000] for I/O Registers at $00 - $3F
0442   0135 ED 39 3F                   OUT0      (ICR),A         ; Standard I/O Mapping (0 Enabled)
0443   0138             
0444   0138                                                      ; Set interrupt vector base (IL)
0445   0138 3E 20                      LD        A,VECTOR_BASE   ; IL = $20 [001x xxxx] for Vectors at $20 - $30
0446   013A ED 39 33                   OUT0      (IL),A          ; Output to the Interrupt Vector Low reg
0447   013D                                                     
0448   013D ED 56                      IM        1               ; Interrupt mode 1 for INT0 (unused)
0449   013F                                  
0450   013F AF                         XOR       A               ; Zero Accumulator
0451   0140             
0452   0140 ED 39 34                   OUT0      (ITC),A         ; Disable external interrupts
0453   0143 ED 39 10                   OUT0      (TCR),A         ; Disable PRT downcounting
0454   0146                                                      ; Clear Refresh Control Reg (RCR)
0455   0146 ED 39 36                   OUT0      (RCR),A         ; DRAM Refresh Enable (0 Disabled)
0456   0149             
0457   0149                                                      ; Set Operation Mode Control Reg (OMCR)
0458   0149 3E 80                      LD        A,OMCR_M1E      ; Enable M1, but disable 64180 I/O _RD Mode
0459   014B ED 39 3E                   OUT0      (OMCR),A        ; X80 Mode (M1E Enabled, OIC Disabled)
0460   014E             
0461   014E                                                      ; Set internal clock = crystal x 2 = 36.864MHz
0462   014E                                                      ; if using ZS8180 or Z80182 at High-Speed
0463   014E 3E 80                      LD        A,CMR_X2        ; Set Hi-Speed flag
0464   0150 ED 39 1E                   OUT0      (CMR),A         ; CPU Clock Multiplier Reg (CMR)
0465   0153             
0466   0153               ;                                      ; Bypass PHI = internal clock / 2
0467   0153               ;                                      ; if using ZS8180 or Z80182 at High-Speed
0468   0153               ;            LD        A,CCR_XTAL_X2   ; Set Hi-Speed flag: PHI = internal clock
0469   0153               ;            OUT0      (CCR),A         ; CPU Control Reg (CCR)
0470   0153                            
0471   0153 FD E3                      EX        (SP),IY         ; (settle)
0472   0155 FD E3                      EX        (SP),IY         ; (settle)               
0473   0157             
0474   0157                                                      ; Set Logical Addresses
0475   0157                                                      ; $8000-$FFFF RAM CA1 -> 80H
0476   0157                                                      ; $4000-$7FFF RAM BANK -> 04H
0477   0157                                                      ; $2000-$3FFF RAM CA0
0478   0157                                                      ; $0000-$1FFF Flash CA0
0479   0157 3E 84                      LD        A,84H           ; Set New Common / Bank Areas
0480   0159 ED 39 3A                   OUT0      (CBAR),A        ; for RAM
0481   015C             
0482   015C                                                      ; Physical Addresses
0483   015C 3E 78                      LD        A,78H           ; Set Common 1 Area Physical $80000 -> 78H
0484   015E ED 39 38                   OUT0      (CBR),A
0485   0161                            
0486   0161 3E 3C                      LD        A,3CH           ; Set Bank Area Physical $40000 -> 3CH
0487   0163 ED 39 39                   OUT0      (BBR),A
0488   0166             
0489   0166 21 CB 21                   LD        HL,TEMPSTACK    ; Temp stack
0490   0169 F9                         LD        SP,HL           ; Set up a temporary stack
0491   016A             
0492   016A 21 00 20                   LD        HL,serRxBuf     ; Initialise Rx Buffer
0493   016D 22 F1 20                   LD        (serRxInPtr),HL
0494   0170 22 F3 20                   LD        (serRxOutPtr),HL
0495   0173             
0496   0173 21 F6 20                   LD        HL,serTxBuf     ; Initialise Tx Buffer
0497   0176 22 07 21                   LD        (serTxInPtr),HL
0498   0179 22 09 21                   LD        (serTxOutPtr),HL              
0499   017C             
0500   017C AF                         XOR       A               ; 0 the accumulator
0501   017D 32 F5 20                   LD        (serRxBufUsed),A
0502   0180 32 0B 21                   LD        (serTxBufUsed),A
0503   0183             
0504   0183                                                      ; load the default ASCI configuration
0505   0183                                                      ; 
0506   0183                                                      ; BAUD = 115200 8n1
0507   0183                                                      ; receive enabled
0508   0183                                                      ; transmit enabled                                         
0509   0183                                                      ; receive interrupt enabled
0510   0183                                                      ; transmit interrupt disabled
0511   0183                                                      
0512   0183 3E 64                      LD        A,SER_RE|SER_TE|SER_8N1
0513   0185 ED 39 01                   OUT0      (CNTLA1),A      ; output to the ASCI1 control A reg
0514   0188             
0515   0188                                                      ; PHI / PS / SS / DR = BAUD Rate
0516   0188                                                      ; PHI = 18.432MHz
0517   0188                                                      ; BAUD = 115200 = 18432000 / 10 / 1 / 16 
0518   0188                                                      ; PS 0, SS_DIV_1 0, DR 0           
0519   0188 AF                         XOR        A              ; BAUD = 115200
0520   0189 ED 39 03                   OUT0      (CNTLB1),A      ; output to the ASCI1 control B reg
0521   018C                                           
0522   018C 3E 08                      LD        A,SER_RIE       ; receive interrupt enabled
0523   018E ED 39 05                   OUT0      (STAT1),A       ; output to the ASCI1 status reg
0524   0191             
0525   0191 FB                         EI                        ; enable interrupts
0526   0192                            
0527   0192             ;===============================================================
0528   0192             ;              BEGIN OF TEST SECTION
0529   0192             
0530   0192             TEST:
0531   0192 3E 02                      LD        A,SER_TDRE      ; prepare Tx test
0532   0194 ED 74 05                   TSTIO     STAT1           ; test whether we can transmit on ASCI1
0533   0197 28 F9                      JR        Z, TEST         ; if not, then loop
0534   0199             
0535   0199 3E 55                      LD        A,$55           ; load an 'U'
0536   019B ED 39 07                   OUT0      (TDR1),A        ; Tx it!
0537   019E C3 92 01                   JP        TEST            ; do it forever
0538   01A1                            
0539   01A1             ;              END OF TEST SECTION                 
0540   01A1             ;===============================================================
0541   01A1                        
0542   01A1 21 DA 01                   LD        HL,SIGNON1      ; Sign-on message
0543   01A4 CD 2B 01                   CALL      PRINT           ; Output string
0544   01A7 3A 0C 21                   LD        A,(basicStarted); Check the BASIC STARTED flag
0545   01AA FE 59                      CP        'Y'             ; to see if this is power-up
0546   01AC 20 16                      JR        NZ,COLDSTART    ; If not BASIC started then always do cold start
0547   01AE 21 ED 01                   LD        HL,SIGNON2      ; Cold/warm message
0548   01B1 CD 2B 01                   CALL      PRINT           ; Output string
0549   01B4             CORW:
0550   01B4 CD DC 00                   CALL      RXA
0551   01B7 E6 DF                      AND       %11011111       ; lower to uppercase
0552   01B9 FE 43                      CP        'C'
0553   01BB 20 0F                      JR        NZ, CHECKWARM
0554   01BD CF                         RST       08H
0555   01BE 3E 0D                      LD        A,$0D
0556   01C0 CF                         RST       08H
0557   01C1 3E 0A                      LD        A,$0A
0558   01C3 CF                         RST       08H
0559   01C4 3E 59       COLDSTART:     LD        A,'Y'           ; Set the BASIC STARTED flag
0560   01C6 32 0C 21                   LD        (basicStarted),A
0561   01C9 C3 00 02                   JP        $0200           ; <<<< Start BASIC COLD
0562   01CC             CHECKWARM:
0563   01CC FE 57                      CP        'W'
0564   01CE 20 E4                      JR        NZ, CORW
0565   01D0 CF                         RST       08H
0566   01D1 3E 0D                      LD        A,$0D
0567   01D3 CF                         RST       08H
0568   01D4 3E 0A                      LD        A,$0A
0569   01D6 CF                         RST       08H
0570   01D7 C3 03 02                   JP        $0203           ; <<<< Start BASIC WARM
0571   01DA             
0572   01DA 59415A313830SIGNON1:       .BYTE     "YAZ180 - feilipu",CR,LF,0
0572   01E0 202D206665696C6970750D0A00
0573   01ED 0D 0A       SIGNON2:       .BYTE     CR,LF
0574   01EF 436F6C64206F               .BYTE     "Cold or warm start (C|W) ?",0
0574   01F5 72207761726D2073746172742028437C5729203F00
0575   020A             
0576   020A                            .END



Label        Value      Label        Value      Label        Value
------------------      ------------------      ------------------
ASEXT0        0012      ASEXT1        0013      ASTC0L        001A      
ASTC0H        001B      ASTC1L        001C      ASTC1H        001D      
BCR0L         0026      BCR0H         0027      BCR1L         002E      
BCR1H         002F      BBR           0039      CNTLA0        0000      
CNTLA1        0001      CNTLB0        0002      CNTLB1        0003      
CNTR          000A      CMR           001E      CCR           001F      
CBR           0038      CBAR          003A      CMR_X2        0080      
CMR_LN_XTAL   0040      CCR_XTAL_X2   0080      CCR_STANDBY   0040      
CCR_BREXT     0020      CCR_LNPHI     0010      CCR_IDLE      0008      
CCR_LNIO      0004      CCR_LNCPUCTL  0002      CCR_LNAD      0001      
CR            000D      CS            000C      CKINCHAR      0125      
CORW          01B4      COLDSTART     01C4      CHECKWARM     01CC      
DAR0L         0023      DAR0H         0024      DAR0B         0025      
DSTAT         0030      DMODE         0031      DCNTL         0032      
FRC           0018      IO_BASE       0000      IAR1L         002B      
IAR1H         002C      IL            0033      ITC           0034      
ICR           003F      INIT          0133      LF            000A      
MAR1L         0028      MAR1H         0029      MAR1B         002A      
NMI           0066      OMCR          003E      OMCR_M1E      0080      
OMCR_M1TE     0040      OMCR_IOC      0020      PRINT         012B      
RDR0          0008      RDR1          0009      RLDR0L        000E      
RLDR0H        000F      RLDR1L        0016      RLDR1H        0017      
RCR           0036      RCR_REFE      0080      RCR_REFW      0040      
RST00         0000      RST08         0008      RST10         0010      
RST18         0018      RST38         0038      RXA           00DC      
STAT0         0004      STAT1         0005      SAR0L         0020      
SAR0H         0021      SAR0B         0022      SER_MPE       0080      
SER_RE        0040      SER_TE        0020      SER_RTS0      0010      
SER_EFR       0008      SER_7N1       0000      SER_7N2       0001      
SER_7P1       0002      SER_7P2       0003      SER_8N1       0004      
SER_8N2       0005      SER_8P1       0006      SER_8P2       0007      
SER_MPBT      0080      SER_MP        0040      SER_PS        0020      
SER_PEO       0010      SER_DR        0008      SER_SS_DIV_1  0000      
SER_SS_DIV_2  0001      SER_SS_DIV_4  0002      SER_SS_DIV_8  0003      
SER_SS_DIV_16 0004      SER_SS_DIV_32 0005      SER_SS_DIV_64 0006      
SER_SS_EXT    0007      SER_RDRF      0080      SER_OVRN      0040      
SER_PE        0020      SER_FE        0010      SER_RIE       0008      
SER_DCD0      0004      SER_CTS1      0004      SER_TDRE      0002      
SER_TIE       0001      SER_RX_BUFSIZE 00F0      SER_TX_BUFSIZE 0010      
SIGNON1       01DA      SIGNON2       01ED      TDR0          0006      
TDR1          0007      TRDR          000B      TMDR0L        000C      
TMDR0H        000D      TCR           0010      TMDR1L        0014      
TMDR1H        0015      TEMPSTACK     21CB      TXA           00FB      
TEST          0192      VECTOR_BASE   0020      VECTOR_INT1   0020      
VECTOR_INT2   0022      VECTOR_PRT0   0024      VECTOR_PRT1   0026      
VECTOR_DMA0   0028      VECTOR_DMA1   002A      VECTOR_CSIO   002C      
VECTOR_ASCI0  002E      VECTOR_ASCI1  0030      basicStarted  210C      
clean_up_tx   0123      get_no_rx_wrap 00F1      no_rx_wrap    00A2      
no_tx_wrap    00C6      put_no_tx_wrap 0112      serRxBuf      2000      
serRxInPtr    20F1      serRxOutPtr   20F3      serRxBufUsed  20F5      
serTxBuf      20F6      serTxInPtr    2107      serTxOutPtr   2109      
serTxBufUsed  210B      serialInt     0080      tx_check      00A9      
tie_clear     00CF      tx_end        00D7      waitForRxChar 00DC      

tasm: Number of errors = 0
